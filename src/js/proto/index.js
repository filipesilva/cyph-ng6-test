/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    
    $root.AccountFileRecord = (function() {
    
        /**
         * Properties of an AccountFileRecord.
         * @exports IAccountFileRecord
         * @interface IAccountFileRecord
         * @property {string} id File ID.
         * @property {string} mediaType File MIME type.
         * @property {string} name File name.
         * @property {AccountFileRecord.RecordTypes} recordType Type of file record.
         * @property {number} size Size in bytes.
         * @property {number} timestamp Timestamp of upload or last save.
         * @property {boolean|undefined} [wasAnonymousShare] Indicates whether this file was originally an anonymous share.
         */
    
        /**
         * Constructs a new AccountFileRecord.
         * @exports AccountFileRecord
         * @classdesc Metadata of one file stored in an account.
         * @implements IAccountFileRecord
         * @constructor
         * @param {IAccountFileRecord=} [properties] Properties to set
         */
        function AccountFileRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * File ID.
         * @member {string} id
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.id = "";
    
        /**
         * File MIME type.
         * @member {string} mediaType
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.mediaType = "";
    
        /**
         * File name.
         * @member {string} name
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.name = "";
    
        /**
         * Type of file record.
         * @member {AccountFileRecord.RecordTypes} recordType
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.recordType = 0;
    
        /**
         * Size in bytes.
         * @member {number} size
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.size = 0;
    
        /**
         * Timestamp of upload or last save.
         * @member {number} timestamp
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.timestamp = 0;
    
        /**
         * Indicates whether this file was originally an anonymous share.
         * @member {boolean} wasAnonymousShare
         * @memberof AccountFileRecord
         * @instance
         */
        AccountFileRecord.prototype.wasAnonymousShare = false;
    
        /**
         * Creates a new AccountFileRecord instance using the specified properties.
         * @function create
         * @memberof AccountFileRecord
         * @static
         * @param {IAccountFileRecord=} [properties] Properties to set
         * @returns {AccountFileRecord} AccountFileRecord instance
         */
        AccountFileRecord.create = function create(properties) {
            return new AccountFileRecord(properties);
        };
    
        /**
         * Encodes the specified AccountFileRecord message. Does not implicitly {@link AccountFileRecord.verify|verify} messages.
         * @function encode
         * @memberof AccountFileRecord
         * @static
         * @param {IAccountFileRecord} message AccountFileRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.mediaType);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.recordType);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.size);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.timestamp);
            if (message.wasAnonymousShare != undefined && message.hasOwnProperty("wasAnonymousShare"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.wasAnonymousShare);
            return writer;
        };
    
        /**
         * Encodes the specified AccountFileRecord message, length delimited. Does not implicitly {@link AccountFileRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountFileRecord
         * @static
         * @param {IAccountFileRecord} message AccountFileRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountFileRecord message from the specified reader or buffer.
         * @function decode
         * @memberof AccountFileRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountFileRecord} AccountFileRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountFileRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.mediaType = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.recordType = reader.int32();
                    break;
                case 5:
                    message.size = reader.double();
                    break;
                case 6:
                    message.timestamp = reader.double();
                    break;
                case 7:
                    message.wasAnonymousShare = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("mediaType"))
                throw $util.ProtocolError("missing required 'mediaType'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("recordType"))
                throw $util.ProtocolError("missing required 'recordType'", { instance: message });
            if (!message.hasOwnProperty("size"))
                throw $util.ProtocolError("missing required 'size'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountFileRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountFileRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountFileRecord} AccountFileRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountFileRecord message.
         * @function verify
         * @memberof AccountFileRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountFileRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (!$util.isString(message.mediaType))
                return "mediaType: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            switch (message.recordType) {
            default:
                return "recordType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            }
            if (typeof message.size !== "number")
                return "size: number expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (message.wasAnonymousShare != undefined && message.hasOwnProperty("wasAnonymousShare"))
                if (typeof message.wasAnonymousShare !== "boolean")
                    return "wasAnonymousShare: boolean expected";
            return undefined;
        };
    
        /**
         * Creates an AccountFileRecord message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountFileRecord
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountFileRecord} AccountFileRecord
         */
        AccountFileRecord.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountFileRecord)
                return object;
            var message = new $root.AccountFileRecord();
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.mediaType != undefined)
                message.mediaType = String(object.mediaType);
            if (object.name != undefined)
                message.name = String(object.name);
            switch (object.recordType) {
            case "Appointment":
            case 0:
                message.recordType = 0;
                break;
            case "File":
            case 1:
                message.recordType = 1;
                break;
            case "Doc":
            case 2:
                message.recordType = 2;
                break;
            case "EhrApiKey":
            case 3:
                message.recordType = 3;
                break;
            case "Form":
            case 4:
                message.recordType = 4;
                break;
            case "Note":
            case 5:
                message.recordType = 5;
                break;
            }
            if (object.size != undefined)
                message.size = Number(object.size);
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            if (object.wasAnonymousShare != undefined)
                message.wasAnonymousShare = Boolean(object.wasAnonymousShare);
            return message;
        };
    
        /**
         * Creates a plain object from an AccountFileRecord message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountFileRecord
         * @static
         * @param {AccountFileRecord} message AccountFileRecord
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountFileRecord.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.mediaType = "";
                object.name = "";
                object.recordType = options.enums === String ? "Appointment" : 0;
                object.size = 0;
                object.timestamp = 0;
                object.wasAnonymousShare = false;
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.mediaType != undefined && message.hasOwnProperty("mediaType"))
                object.mediaType = message.mediaType;
            if (message.name != undefined && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.recordType != undefined && message.hasOwnProperty("recordType"))
                object.recordType = options.enums === String ? $root.AccountFileRecord.RecordTypes[message.recordType] : message.recordType;
            if (message.size != undefined && message.hasOwnProperty("size"))
                object.size = options.json && !isFinite(message.size) ? String(message.size) : message.size;
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.wasAnonymousShare != undefined && message.hasOwnProperty("wasAnonymousShare"))
                object.wasAnonymousShare = message.wasAnonymousShare;
            return object;
        };
    
        /**
         * Converts this AccountFileRecord to JSON.
         * @function toJSON
         * @memberof AccountFileRecord
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountFileRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Possible file record types.
         * @name AccountFileRecord.RecordTypes
         * @enum {string}
         * @property {number} Appointment=0 Appointment value
         * @property {number} File=1 File value
         * @property {number} Doc=2 Doc value
         * @property {number} EhrApiKey=3 EhrApiKey value
         * @property {number} Form=4 Form value
         * @property {number} Note=5 Note value
         */
        AccountFileRecord.RecordTypes = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Appointment"] = 0;
            values[valuesById[1] = "File"] = 1;
            values[valuesById[2] = "Doc"] = 2;
            values[valuesById[3] = "EhrApiKey"] = 3;
            values[valuesById[4] = "Form"] = 4;
            values[valuesById[5] = "Note"] = 5;
            return values;
        })();
    
        return AccountFileRecord;
    })();
    
    $root.AccountFileReference = (function() {
    
        /**
         * Properties of an AccountFileReference.
         * @exports IAccountFileReference
         * @interface IAccountFileReference
         * @property {string} id File record ID.
         * @property {Uint8Array} key Symmetric key used for encrypting file.
         * @property {string} owner Username of owner.
         */
    
        /**
         * Constructs a new AccountFileReference.
         * @exports AccountFileReference
         * @classdesc Shareable reference to a file record.
         * @implements IAccountFileReference
         * @constructor
         * @param {IAccountFileReference=} [properties] Properties to set
         */
        function AccountFileReference(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * File record ID.
         * @member {string} id
         * @memberof AccountFileReference
         * @instance
         */
        AccountFileReference.prototype.id = "";
    
        /**
         * Symmetric key used for encrypting file.
         * @member {Uint8Array} key
         * @memberof AccountFileReference
         * @instance
         */
        AccountFileReference.prototype.key = $util.newBuffer([]);
    
        /**
         * Username of owner.
         * @member {string} owner
         * @memberof AccountFileReference
         * @instance
         */
        AccountFileReference.prototype.owner = "";
    
        /**
         * Creates a new AccountFileReference instance using the specified properties.
         * @function create
         * @memberof AccountFileReference
         * @static
         * @param {IAccountFileReference=} [properties] Properties to set
         * @returns {AccountFileReference} AccountFileReference instance
         */
        AccountFileReference.create = function create(properties) {
            return new AccountFileReference(properties);
        };
    
        /**
         * Encodes the specified AccountFileReference message. Does not implicitly {@link AccountFileReference.verify|verify} messages.
         * @function encode
         * @memberof AccountFileReference
         * @static
         * @param {IAccountFileReference} message AccountFileReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileReference.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.owner);
            return writer;
        };
    
        /**
         * Encodes the specified AccountFileReference message, length delimited. Does not implicitly {@link AccountFileReference.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountFileReference
         * @static
         * @param {IAccountFileReference} message AccountFileReference message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileReference.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountFileReference message from the specified reader or buffer.
         * @function decode
         * @memberof AccountFileReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountFileReference} AccountFileReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileReference.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountFileReference();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.key = reader.bytes();
                    break;
                case 3:
                    message.owner = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("owner"))
                throw $util.ProtocolError("missing required 'owner'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountFileReference message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountFileReference
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountFileReference} AccountFileReference
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileReference.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountFileReference message.
         * @function verify
         * @memberof AccountFileReference
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountFileReference.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
            if (!$util.isString(message.owner))
                return "owner: string expected";
            return undefined;
        };
    
        /**
         * Creates an AccountFileReference message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountFileReference
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountFileReference} AccountFileReference
         */
        AccountFileReference.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountFileReference)
                return object;
            var message = new $root.AccountFileReference();
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.key != undefined)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.owner != undefined)
                message.owner = String(object.owner);
            return message;
        };
    
        /**
         * Creates a plain object from an AccountFileReference message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountFileReference
         * @static
         * @param {AccountFileReference} message AccountFileReference
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountFileReference.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.key = options.bytes === String ? "" : [];
                object.owner = "";
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.key != undefined && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.owner != undefined && message.hasOwnProperty("owner"))
                object.owner = message.owner;
            return object;
        };
    
        /**
         * Converts this AccountFileReference to JSON.
         * @function toJSON
         * @memberof AccountFileReference
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountFileReference.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AccountFileReference;
    })();
    
    $root.AccountFileReferenceContainer = (function() {
    
        /**
         * Properties of an AccountFileReferenceContainer.
         * @exports IAccountFileReferenceContainer
         * @interface IAccountFileReferenceContainer
         * @property {AccountFileReferenceContainer.IAnonymousShare|undefined} [anonymousShare] AccountFileReferenceContainer anonymousShare
         * @property {AccountFileReferenceContainer.ISignedShare|undefined} [signedShare] AccountFileReferenceContainer signedShare
         */
    
        /**
         * Constructs a new AccountFileReferenceContainer.
         * @exports AccountFileReferenceContainer
         * @classdesc Contains a file reference.
         * @implements IAccountFileReferenceContainer
         * @constructor
         * @param {IAccountFileReferenceContainer=} [properties] Properties to set
         */
        function AccountFileReferenceContainer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * AccountFileReferenceContainer anonymousShare.
         * @member {AccountFileReferenceContainer.IAnonymousShare|undefined|undefined} anonymousShare
         * @memberof AccountFileReferenceContainer
         * @instance
         */
        AccountFileReferenceContainer.prototype.anonymousShare = undefined;
    
        /**
         * AccountFileReferenceContainer signedShare.
         * @member {AccountFileReferenceContainer.ISignedShare|undefined|undefined} signedShare
         * @memberof AccountFileReferenceContainer
         * @instance
         */
        AccountFileReferenceContainer.prototype.signedShare = undefined;
    
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
    
        /**
         * Value.
         * @member {"anonymousShare"|"signedShare"|undefined} value
         * @memberof AccountFileReferenceContainer
         * @instance
         */
        Object.defineProperty(AccountFileReferenceContainer.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["anonymousShare", "signedShare"]),
            set: $util.oneOfSetter($oneOfFields)
        });
    
        /**
         * Creates a new AccountFileReferenceContainer instance using the specified properties.
         * @function create
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {IAccountFileReferenceContainer=} [properties] Properties to set
         * @returns {AccountFileReferenceContainer} AccountFileReferenceContainer instance
         */
        AccountFileReferenceContainer.create = function create(properties) {
            return new AccountFileReferenceContainer(properties);
        };
    
        /**
         * Encodes the specified AccountFileReferenceContainer message. Does not implicitly {@link AccountFileReferenceContainer.verify|verify} messages.
         * @function encode
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {IAccountFileReferenceContainer} message AccountFileReferenceContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileReferenceContainer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.anonymousShare != undefined && message.hasOwnProperty("anonymousShare"))
                $root.AccountFileReferenceContainer.AnonymousShare.encode(message.anonymousShare, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.signedShare != undefined && message.hasOwnProperty("signedShare"))
                $root.AccountFileReferenceContainer.SignedShare.encode(message.signedShare, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified AccountFileReferenceContainer message, length delimited. Does not implicitly {@link AccountFileReferenceContainer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {IAccountFileReferenceContainer} message AccountFileReferenceContainer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountFileReferenceContainer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountFileReferenceContainer message from the specified reader or buffer.
         * @function decode
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountFileReferenceContainer} AccountFileReferenceContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileReferenceContainer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountFileReferenceContainer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.anonymousShare = $root.AccountFileReferenceContainer.AnonymousShare.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.signedShare = $root.AccountFileReferenceContainer.SignedShare.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an AccountFileReferenceContainer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountFileReferenceContainer} AccountFileReferenceContainer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountFileReferenceContainer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountFileReferenceContainer message.
         * @function verify
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountFileReferenceContainer.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            var properties = {};
            if (message.anonymousShare != undefined && message.hasOwnProperty("anonymousShare")) {
                properties.value = 1;
                {
                    var error = $root.AccountFileReferenceContainer.AnonymousShare.verify(message.anonymousShare);
                    if (error)
                        return "anonymousShare." + error;
                }
            }
            if (message.signedShare != undefined && message.hasOwnProperty("signedShare")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.AccountFileReferenceContainer.SignedShare.verify(message.signedShare);
                    if (error)
                        return "signedShare." + error;
                }
            }
            return undefined;
        };
    
        /**
         * Creates an AccountFileReferenceContainer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountFileReferenceContainer} AccountFileReferenceContainer
         */
        AccountFileReferenceContainer.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountFileReferenceContainer)
                return object;
            var message = new $root.AccountFileReferenceContainer();
            if (object.anonymousShare != undefined) {
                if (typeof object.anonymousShare !== "object")
                    throw TypeError(".AccountFileReferenceContainer.anonymousShare: object expected");
                message.anonymousShare = $root.AccountFileReferenceContainer.AnonymousShare.fromObject(object.anonymousShare);
            }
            if (object.signedShare != undefined) {
                if (typeof object.signedShare !== "object")
                    throw TypeError(".AccountFileReferenceContainer.signedShare: object expected");
                message.signedShare = $root.AccountFileReferenceContainer.SignedShare.fromObject(object.signedShare);
            }
            return message;
        };
    
        /**
         * Creates a plain object from an AccountFileReferenceContainer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountFileReferenceContainer
         * @static
         * @param {AccountFileReferenceContainer} message AccountFileReferenceContainer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountFileReferenceContainer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.anonymousShare != undefined && message.hasOwnProperty("anonymousShare")) {
                object.anonymousShare = $root.AccountFileReferenceContainer.AnonymousShare.toObject(message.anonymousShare, options);
                if (options.oneofs)
                    object.value = "anonymousShare";
            }
            if (message.signedShare != undefined && message.hasOwnProperty("signedShare")) {
                object.signedShare = $root.AccountFileReferenceContainer.SignedShare.toObject(message.signedShare, options);
                if (options.oneofs)
                    object.value = "signedShare";
            }
            return object;
        };
    
        /**
         * Converts this AccountFileReferenceContainer to JSON.
         * @function toJSON
         * @memberof AccountFileReferenceContainer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountFileReferenceContainer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        AccountFileReferenceContainer.AnonymousShare = (function() {
    
            /**
             * Properties of an AnonymousShare.
             * @memberof AccountFileReferenceContainer
             * @interface IAnonymousShare
             * @property {IAccountFileRecord} accountFileRecord @see AccountFileRecord
             * @property {Uint8Array} key @see AccountFileReference.key
             */
    
            /**
             * Constructs a new AnonymousShare.
             * @memberof AccountFileReferenceContainer
             * @classdesc Anonymously shared file data.
             * @implements IAnonymousShare
             * @constructor
             * @param {AccountFileReferenceContainer.IAnonymousShare=} [properties] Properties to set
             */
            function AnonymousShare(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see AccountFileRecord
             * @member {IAccountFileRecord} accountFileRecord
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @instance
             */
            AnonymousShare.prototype.accountFileRecord = undefined;
    
            /**
             * @see AccountFileReference.key
             * @member {Uint8Array} key
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @instance
             */
            AnonymousShare.prototype.key = $util.newBuffer([]);
    
            /**
             * Creates a new AnonymousShare instance using the specified properties.
             * @function create
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {AccountFileReferenceContainer.IAnonymousShare=} [properties] Properties to set
             * @returns {AccountFileReferenceContainer.AnonymousShare} AnonymousShare instance
             */
            AnonymousShare.create = function create(properties) {
                return new AnonymousShare(properties);
            };
    
            /**
             * Encodes the specified AnonymousShare message. Does not implicitly {@link AccountFileReferenceContainer.AnonymousShare.verify|verify} messages.
             * @function encode
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {AccountFileReferenceContainer.IAnonymousShare} message AnonymousShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousShare.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                $root.AccountFileRecord.encode(message.accountFileRecord, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.key);
                return writer;
            };
    
            /**
             * Encodes the specified AnonymousShare message, length delimited. Does not implicitly {@link AccountFileReferenceContainer.AnonymousShare.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {AccountFileReferenceContainer.IAnonymousShare} message AnonymousShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AnonymousShare.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AnonymousShare message from the specified reader or buffer.
             * @function decode
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AccountFileReferenceContainer.AnonymousShare} AnonymousShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousShare.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountFileReferenceContainer.AnonymousShare();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountFileRecord = $root.AccountFileRecord.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.key = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("accountFileRecord"))
                    throw $util.ProtocolError("missing required 'accountFileRecord'", { instance: message });
                if (!message.hasOwnProperty("key"))
                    throw $util.ProtocolError("missing required 'key'", { instance: message });
                return message;
            };
    
            /**
             * Decodes an AnonymousShare message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AccountFileReferenceContainer.AnonymousShare} AnonymousShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AnonymousShare.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AnonymousShare message.
             * @function verify
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            AnonymousShare.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                {
                    var error = $root.AccountFileRecord.verify(message.accountFileRecord);
                    if (error)
                        return "accountFileRecord." + error;
                }
                if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                    return "key: buffer expected";
                return undefined;
            };
    
            /**
             * Creates an AnonymousShare message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AccountFileReferenceContainer.AnonymousShare} AnonymousShare
             */
            AnonymousShare.fromObject = function fromObject(object) {
                if (object instanceof $root.AccountFileReferenceContainer.AnonymousShare)
                    return object;
                var message = new $root.AccountFileReferenceContainer.AnonymousShare();
                if (object.accountFileRecord != undefined) {
                    if (typeof object.accountFileRecord !== "object")
                        throw TypeError(".AccountFileReferenceContainer.AnonymousShare.accountFileRecord: object expected");
                    message.accountFileRecord = $root.AccountFileRecord.fromObject(object.accountFileRecord);
                }
                if (object.key != undefined)
                    if (typeof object.key === "string")
                        $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                    else if (object.key.length)
                        message.key = object.key;
                return message;
            };
    
            /**
             * Creates a plain object from an AnonymousShare message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @static
             * @param {AccountFileReferenceContainer.AnonymousShare} message AnonymousShare
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AnonymousShare.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.accountFileRecord = undefined;
                    object.key = options.bytes === String ? "" : [];
                }
                if (message.accountFileRecord != undefined && message.hasOwnProperty("accountFileRecord"))
                    object.accountFileRecord = $root.AccountFileRecord.toObject(message.accountFileRecord, options);
                if (message.key != undefined && message.hasOwnProperty("key"))
                    object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
                return object;
            };
    
            /**
             * Converts this AnonymousShare to JSON.
             * @function toJSON
             * @memberof AccountFileReferenceContainer.AnonymousShare
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AnonymousShare.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AnonymousShare;
        })();
    
        AccountFileReferenceContainer.SignedShare = (function() {
    
            /**
             * Properties of a SignedShare.
             * @memberof AccountFileReferenceContainer
             * @interface ISignedShare
             * @property {Uint8Array} accountFileReference @see AccountFileReference
             * @property {string} owner @see AccountFileReference.owner
             */
    
            /**
             * Constructs a new SignedShare.
             * @memberof AccountFileReferenceContainer
             * @classdesc Signed file data.
             * @implements ISignedShare
             * @constructor
             * @param {AccountFileReferenceContainer.ISignedShare=} [properties] Properties to set
             */
            function SignedShare(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see AccountFileReference
             * @member {Uint8Array} accountFileReference
             * @memberof AccountFileReferenceContainer.SignedShare
             * @instance
             */
            SignedShare.prototype.accountFileReference = $util.newBuffer([]);
    
            /**
             * @see AccountFileReference.owner
             * @member {string} owner
             * @memberof AccountFileReferenceContainer.SignedShare
             * @instance
             */
            SignedShare.prototype.owner = "";
    
            /**
             * Creates a new SignedShare instance using the specified properties.
             * @function create
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {AccountFileReferenceContainer.ISignedShare=} [properties] Properties to set
             * @returns {AccountFileReferenceContainer.SignedShare} SignedShare instance
             */
            SignedShare.create = function create(properties) {
                return new SignedShare(properties);
            };
    
            /**
             * Encodes the specified SignedShare message. Does not implicitly {@link AccountFileReferenceContainer.SignedShare.verify|verify} messages.
             * @function encode
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {AccountFileReferenceContainer.ISignedShare} message SignedShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedShare.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountFileReference);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.owner);
                return writer;
            };
    
            /**
             * Encodes the specified SignedShare message, length delimited. Does not implicitly {@link AccountFileReferenceContainer.SignedShare.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {AccountFileReferenceContainer.ISignedShare} message SignedShare message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignedShare.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a SignedShare message from the specified reader or buffer.
             * @function decode
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AccountFileReferenceContainer.SignedShare} SignedShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedShare.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountFileReferenceContainer.SignedShare();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountFileReference = reader.bytes();
                        break;
                    case 2:
                        message.owner = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("accountFileReference"))
                    throw $util.ProtocolError("missing required 'accountFileReference'", { instance: message });
                if (!message.hasOwnProperty("owner"))
                    throw $util.ProtocolError("missing required 'owner'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a SignedShare message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AccountFileReferenceContainer.SignedShare} SignedShare
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignedShare.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a SignedShare message.
             * @function verify
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            SignedShare.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (!(message.accountFileReference && typeof message.accountFileReference.length === "number" || $util.isString(message.accountFileReference)))
                    return "accountFileReference: buffer expected";
                if (!$util.isString(message.owner))
                    return "owner: string expected";
                return undefined;
            };
    
            /**
             * Creates a SignedShare message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AccountFileReferenceContainer.SignedShare} SignedShare
             */
            SignedShare.fromObject = function fromObject(object) {
                if (object instanceof $root.AccountFileReferenceContainer.SignedShare)
                    return object;
                var message = new $root.AccountFileReferenceContainer.SignedShare();
                if (object.accountFileReference != undefined)
                    if (typeof object.accountFileReference === "string")
                        $util.base64.decode(object.accountFileReference, message.accountFileReference = $util.newBuffer($util.base64.length(object.accountFileReference)), 0);
                    else if (object.accountFileReference.length)
                        message.accountFileReference = object.accountFileReference;
                if (object.owner != undefined)
                    message.owner = String(object.owner);
                return message;
            };
    
            /**
             * Creates a plain object from a SignedShare message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AccountFileReferenceContainer.SignedShare
             * @static
             * @param {AccountFileReferenceContainer.SignedShare} message SignedShare
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignedShare.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.accountFileReference = options.bytes === String ? "" : [];
                    object.owner = "";
                }
                if (message.accountFileReference != undefined && message.hasOwnProperty("accountFileReference"))
                    object.accountFileReference = options.bytes === String ? $util.base64.encode(message.accountFileReference, 0, message.accountFileReference.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountFileReference) : message.accountFileReference;
                if (message.owner != undefined && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                return object;
            };
    
            /**
             * Converts this SignedShare to JSON.
             * @function toJSON
             * @memberof AccountFileReferenceContainer.SignedShare
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignedShare.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return SignedShare;
        })();
    
        return AccountFileReferenceContainer;
    })();
    
    $root.AccountLoginData = (function() {
    
        /**
         * Properties of an AccountLoginData.
         * @exports IAccountLoginData
         * @interface IAccountLoginData
         * @property {string} secondaryPassword Randomly generated password for database authentication.
         * @property {Uint8Array} symmetricKey Symmetric key for encrypting user data.
         */
    
        /**
         * Constructs a new AccountLoginData.
         * @exports AccountLoginData
         * @classdesc Augmented PAKE login data.
         * @implements IAccountLoginData
         * @constructor
         * @param {IAccountLoginData=} [properties] Properties to set
         */
        function AccountLoginData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Randomly generated password for database authentication.
         * @member {string} secondaryPassword
         * @memberof AccountLoginData
         * @instance
         */
        AccountLoginData.prototype.secondaryPassword = "";
    
        /**
         * Symmetric key for encrypting user data.
         * @member {Uint8Array} symmetricKey
         * @memberof AccountLoginData
         * @instance
         */
        AccountLoginData.prototype.symmetricKey = $util.newBuffer([]);
    
        /**
         * Creates a new AccountLoginData instance using the specified properties.
         * @function create
         * @memberof AccountLoginData
         * @static
         * @param {IAccountLoginData=} [properties] Properties to set
         * @returns {AccountLoginData} AccountLoginData instance
         */
        AccountLoginData.create = function create(properties) {
            return new AccountLoginData(properties);
        };
    
        /**
         * Encodes the specified AccountLoginData message. Does not implicitly {@link AccountLoginData.verify|verify} messages.
         * @function encode
         * @memberof AccountLoginData
         * @static
         * @param {IAccountLoginData} message AccountLoginData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.secondaryPassword);
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.symmetricKey);
            return writer;
        };
    
        /**
         * Encodes the specified AccountLoginData message, length delimited. Does not implicitly {@link AccountLoginData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountLoginData
         * @static
         * @param {IAccountLoginData} message AccountLoginData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountLoginData message from the specified reader or buffer.
         * @function decode
         * @memberof AccountLoginData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountLoginData} AccountLoginData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountLoginData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.secondaryPassword = reader.string();
                    break;
                case 2:
                    message.symmetricKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("secondaryPassword"))
                throw $util.ProtocolError("missing required 'secondaryPassword'", { instance: message });
            if (!message.hasOwnProperty("symmetricKey"))
                throw $util.ProtocolError("missing required 'symmetricKey'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountLoginData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountLoginData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountLoginData} AccountLoginData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountLoginData message.
         * @function verify
         * @memberof AccountLoginData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountLoginData.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.secondaryPassword))
                return "secondaryPassword: string expected";
            if (!(message.symmetricKey && typeof message.symmetricKey.length === "number" || $util.isString(message.symmetricKey)))
                return "symmetricKey: buffer expected";
            return undefined;
        };
    
        /**
         * Creates an AccountLoginData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountLoginData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountLoginData} AccountLoginData
         */
        AccountLoginData.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountLoginData)
                return object;
            var message = new $root.AccountLoginData();
            if (object.secondaryPassword != undefined)
                message.secondaryPassword = String(object.secondaryPassword);
            if (object.symmetricKey != undefined)
                if (typeof object.symmetricKey === "string")
                    $util.base64.decode(object.symmetricKey, message.symmetricKey = $util.newBuffer($util.base64.length(object.symmetricKey)), 0);
                else if (object.symmetricKey.length)
                    message.symmetricKey = object.symmetricKey;
            return message;
        };
    
        /**
         * Creates a plain object from an AccountLoginData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountLoginData
         * @static
         * @param {AccountLoginData} message AccountLoginData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountLoginData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.secondaryPassword = "";
                object.symmetricKey = options.bytes === String ? "" : [];
            }
            if (message.secondaryPassword != undefined && message.hasOwnProperty("secondaryPassword"))
                object.secondaryPassword = message.secondaryPassword;
            if (message.symmetricKey != undefined && message.hasOwnProperty("symmetricKey"))
                object.symmetricKey = options.bytes === String ? $util.base64.encode(message.symmetricKey, 0, message.symmetricKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.symmetricKey) : message.symmetricKey;
            return object;
        };
    
        /**
         * Converts this AccountLoginData to JSON.
         * @function toJSON
         * @memberof AccountLoginData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountLoginData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AccountLoginData;
    })();
    
    $root.AccountUserPresence = (function() {
    
        /**
         * Properties of an AccountUserPresence.
         * @exports IAccountUserPresence
         * @interface IAccountUserPresence
         * @property {AccountUserPresence.Statuses} status Current presence status.
         */
    
        /**
         * Constructs a new AccountUserPresence.
         * @exports AccountUserPresence
         * @classdesc User presence.
         * @implements IAccountUserPresence
         * @constructor
         * @param {IAccountUserPresence=} [properties] Properties to set
         */
        function AccountUserPresence(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Current presence status.
         * @member {AccountUserPresence.Statuses} status
         * @memberof AccountUserPresence
         * @instance
         */
        AccountUserPresence.prototype.status = 0;
    
        /**
         * Creates a new AccountUserPresence instance using the specified properties.
         * @function create
         * @memberof AccountUserPresence
         * @static
         * @param {IAccountUserPresence=} [properties] Properties to set
         * @returns {AccountUserPresence} AccountUserPresence instance
         */
        AccountUserPresence.create = function create(properties) {
            return new AccountUserPresence(properties);
        };
    
        /**
         * Encodes the specified AccountUserPresence message. Does not implicitly {@link AccountUserPresence.verify|verify} messages.
         * @function encode
         * @memberof AccountUserPresence
         * @static
         * @param {IAccountUserPresence} message AccountUserPresence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserPresence.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
            return writer;
        };
    
        /**
         * Encodes the specified AccountUserPresence message, length delimited. Does not implicitly {@link AccountUserPresence.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountUserPresence
         * @static
         * @param {IAccountUserPresence} message AccountUserPresence message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserPresence.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountUserPresence message from the specified reader or buffer.
         * @function decode
         * @memberof AccountUserPresence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountUserPresence} AccountUserPresence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserPresence.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserPresence();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.status = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("status"))
                throw $util.ProtocolError("missing required 'status'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountUserPresence message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountUserPresence
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountUserPresence} AccountUserPresence
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserPresence.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountUserPresence message.
         * @function verify
         * @memberof AccountUserPresence
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountUserPresence.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            switch (message.status) {
            default:
                return "status: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            return undefined;
        };
    
        /**
         * Creates an AccountUserPresence message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountUserPresence
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountUserPresence} AccountUserPresence
         */
        AccountUserPresence.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountUserPresence)
                return object;
            var message = new $root.AccountUserPresence();
            switch (object.status) {
            case "Offline":
            case 0:
                message.status = 0;
                break;
            case "Away":
            case 1:
                message.status = 1;
                break;
            case "Busy":
            case 2:
                message.status = 2;
                break;
            case "Online":
            case 3:
                message.status = 3;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from an AccountUserPresence message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountUserPresence
         * @static
         * @param {AccountUserPresence} message AccountUserPresence
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserPresence.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.status = options.enums === String ? "Offline" : 0;
            if (message.status != undefined && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.AccountUserPresence.Statuses[message.status] : message.status;
            return object;
        };
    
        /**
         * Converts this AccountUserPresence to JSON.
         * @function toJSON
         * @memberof AccountUserPresence
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserPresence.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Possible presence statuses.
         * @name AccountUserPresence.Statuses
         * @enum {string}
         * @property {number} Offline=0 Offline value
         * @property {number} Away=1 Away value
         * @property {number} Busy=2 Busy value
         * @property {number} Online=3 Online value
         */
        AccountUserPresence.Statuses = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Offline"] = 0;
            values[valuesById[1] = "Away"] = 1;
            values[valuesById[2] = "Busy"] = 2;
            values[valuesById[3] = "Online"] = 3;
            return values;
        })();
    
        return AccountUserPresence;
    })();
    
    $root.AccountUserProfile = (function() {
    
        /**
         * Properties of an AccountUserProfile.
         * @exports IAccountUserProfile
         * @interface IAccountUserProfile
         * @property {string} description Description.
         * @property {Object.<string,string>|undefined} [externalUsernames] Usernames and similar identifiers for external services like social media.
         * @property {boolean} hasPremium Premium account.
         * @property {string} name Full name.
         * @property {string} realUsername Username (capitalized according to user preference).
         * @property {AccountUserTypes} userType @see AccountUserTypes
         */
    
        /**
         * Constructs a new AccountUserProfile.
         * @exports AccountUserProfile
         * @classdesc User public profile.
         * @implements IAccountUserProfile
         * @constructor
         * @param {IAccountUserProfile=} [properties] Properties to set
         */
        function AccountUserProfile(properties) {
            this.externalUsernames = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Description.
         * @member {string} description
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.description = "";
    
        /**
         * Usernames and similar identifiers for external services like social media.
         * @member {Object.<string,string>} externalUsernames
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.externalUsernames = $util.emptyObject;
    
        /**
         * Premium account.
         * @member {boolean} hasPremium
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.hasPremium = false;
    
        /**
         * Full name.
         * @member {string} name
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.name = "";
    
        /**
         * Username (capitalized according to user preference).
         * @member {string} realUsername
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.realUsername = "";
    
        /**
         * @see AccountUserTypes
         * @member {AccountUserTypes} userType
         * @memberof AccountUserProfile
         * @instance
         */
        AccountUserProfile.prototype.userType = 0;
    
        /**
         * Creates a new AccountUserProfile instance using the specified properties.
         * @function create
         * @memberof AccountUserProfile
         * @static
         * @param {IAccountUserProfile=} [properties] Properties to set
         * @returns {AccountUserProfile} AccountUserProfile instance
         */
        AccountUserProfile.create = function create(properties) {
            return new AccountUserProfile(properties);
        };
    
        /**
         * Encodes the specified AccountUserProfile message. Does not implicitly {@link AccountUserProfile.verify|verify} messages.
         * @function encode
         * @memberof AccountUserProfile
         * @static
         * @param {IAccountUserProfile} message AccountUserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserProfile.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.description);
            if (message.externalUsernames != undefined && message.hasOwnProperty("externalUsernames"))
                for (var keys = Object.keys(message.externalUsernames), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.externalUsernames[keys[i]]).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasPremium);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
            writer.uint32(/* id 5, wireType 2 =*/42).string(message.realUsername);
            writer.uint32(/* id 6, wireType 0 =*/48).int32(message.userType);
            return writer;
        };
    
        /**
         * Encodes the specified AccountUserProfile message, length delimited. Does not implicitly {@link AccountUserProfile.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountUserProfile
         * @static
         * @param {IAccountUserProfile} message AccountUserProfile message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserProfile.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountUserProfile message from the specified reader or buffer.
         * @function decode
         * @memberof AccountUserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountUserProfile} AccountUserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserProfile.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserProfile(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.externalUsernames === $util.emptyObject)
                        message.externalUsernames = {};
                    key = reader.string();
                    reader.pos++;
                    message.externalUsernames[key] = reader.string();
                    break;
                case 3:
                    message.hasPremium = reader.bool();
                    break;
                case 4:
                    message.name = reader.string();
                    break;
                case 5:
                    message.realUsername = reader.string();
                    break;
                case 6:
                    message.userType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("description"))
                throw $util.ProtocolError("missing required 'description'", { instance: message });
            if (!message.hasOwnProperty("hasPremium"))
                throw $util.ProtocolError("missing required 'hasPremium'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("realUsername"))
                throw $util.ProtocolError("missing required 'realUsername'", { instance: message });
            if (!message.hasOwnProperty("userType"))
                throw $util.ProtocolError("missing required 'userType'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountUserProfile message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountUserProfile
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountUserProfile} AccountUserProfile
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserProfile.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountUserProfile message.
         * @function verify
         * @memberof AccountUserProfile
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountUserProfile.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.description))
                return "description: string expected";
            if (message.externalUsernames != undefined && message.hasOwnProperty("externalUsernames")) {
                if (!$util.isObject(message.externalUsernames))
                    return "externalUsernames: object expected";
                var key = Object.keys(message.externalUsernames);
                for (var i = 0; i < key.length; ++i)
                    if (!$util.isString(message.externalUsernames[key[i]]))
                        return "externalUsernames: string{k:string} expected";
            }
            if (typeof message.hasPremium !== "boolean")
                return "hasPremium: boolean expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (!$util.isString(message.realUsername))
                return "realUsername: string expected";
            switch (message.userType) {
            default:
                return "userType: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
                break;
            }
            return undefined;
        };
    
        /**
         * Creates an AccountUserProfile message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountUserProfile
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountUserProfile} AccountUserProfile
         */
        AccountUserProfile.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountUserProfile)
                return object;
            var message = new $root.AccountUserProfile();
            if (object.description != undefined)
                message.description = String(object.description);
            if (object.externalUsernames) {
                if (typeof object.externalUsernames !== "object")
                    throw TypeError(".AccountUserProfile.externalUsernames: object expected");
                message.externalUsernames = {};
                for (var keys = Object.keys(object.externalUsernames), i = 0; i < keys.length; ++i)
                    message.externalUsernames[keys[i]] = String(object.externalUsernames[keys[i]]);
            }
            if (object.hasPremium != undefined)
                message.hasPremium = Boolean(object.hasPremium);
            if (object.name != undefined)
                message.name = String(object.name);
            if (object.realUsername != undefined)
                message.realUsername = String(object.realUsername);
            switch (object.userType) {
            case "Standard":
            case 0:
                message.userType = 0;
                break;
            case "Org":
            case 1:
                message.userType = 1;
                break;
            case "TelehealthAdmin":
            case 2:
                message.userType = 2;
                break;
            case "TelehealthDoctor":
            case 3:
                message.userType = 3;
                break;
            }
            return message;
        };
    
        /**
         * Creates a plain object from an AccountUserProfile message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountUserProfile
         * @static
         * @param {AccountUserProfile} message AccountUserProfile
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserProfile.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.externalUsernames = {};
            if (options.defaults) {
                object.description = "";
                object.hasPremium = false;
                object.name = "";
                object.realUsername = "";
                object.userType = options.enums === String ? "Standard" : 0;
            }
            if (message.description != undefined && message.hasOwnProperty("description"))
                object.description = message.description;
            var keys2;
            if (message.externalUsernames && (keys2 = Object.keys(message.externalUsernames)).length) {
                object.externalUsernames = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.externalUsernames[keys2[j]] = message.externalUsernames[keys2[j]];
            }
            if (message.hasPremium != undefined && message.hasOwnProperty("hasPremium"))
                object.hasPremium = message.hasPremium;
            if (message.name != undefined && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.realUsername != undefined && message.hasOwnProperty("realUsername"))
                object.realUsername = message.realUsername;
            if (message.userType != undefined && message.hasOwnProperty("userType"))
                object.userType = options.enums === String ? $root.AccountUserTypes[message.userType] : message.userType;
            return object;
        };
    
        /**
         * Converts this AccountUserProfile to JSON.
         * @function toJSON
         * @memberof AccountUserProfile
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserProfile.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AccountUserProfile;
    })();
    
    $root.AccountUserProfileExtra = (function() {
    
        /**
         * Properties of an AccountUserProfileExtra.
         * @exports IAccountUserProfileExtra
         * @interface IAccountUserProfileExtra
         * @property {string|undefined} [address] Physical address.
         * @property {Array.<AccountUserProfileExtra.IPosition>|undefined} [education] Educational history.
         * @property {string|undefined} [gender] Gender.
         * @property {Array.<string>|undefined} [insurance] Insurance.
         * @property {Array.<AccountUserProfileExtra.ILanguage>|undefined} [languages] Languages.
         * @property {Array.<string>|undefined} [npis] NPI numbers.
         * @property {string|undefined} [organization] Username of parent organization.
         * @property {Array.<string>|undefined} [specialties] Specialties.
         * @property {Array.<AccountUserProfileExtra.IPosition>|undefined} [work] Work history.
         */
    
        /**
         * Constructs a new AccountUserProfileExtra.
         * @exports AccountUserProfileExtra
         * @classdesc User public profile additional data.
         * @implements IAccountUserProfileExtra
         * @constructor
         * @param {IAccountUserProfileExtra=} [properties] Properties to set
         */
        function AccountUserProfileExtra(properties) {
            this.education = [];
            this.insurance = [];
            this.languages = [];
            this.npis = [];
            this.specialties = [];
            this.work = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Physical address.
         * @member {string} address
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.address = "";
    
        /**
         * Educational history.
         * @member {Array.<AccountUserProfileExtra.IPosition>} education
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.education = $util.emptyArray;
    
        /**
         * Gender.
         * @member {string} gender
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.gender = "";
    
        /**
         * Insurance.
         * @member {Array.<string>} insurance
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.insurance = $util.emptyArray;
    
        /**
         * Languages.
         * @member {Array.<AccountUserProfileExtra.ILanguage>} languages
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.languages = $util.emptyArray;
    
        /**
         * NPI numbers.
         * @member {Array.<string>} npis
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.npis = $util.emptyArray;
    
        /**
         * Username of parent organization.
         * @member {string} organization
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.organization = "";
    
        /**
         * Specialties.
         * @member {Array.<string>} specialties
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.specialties = $util.emptyArray;
    
        /**
         * Work history.
         * @member {Array.<AccountUserProfileExtra.IPosition>} work
         * @memberof AccountUserProfileExtra
         * @instance
         */
        AccountUserProfileExtra.prototype.work = $util.emptyArray;
    
        /**
         * Creates a new AccountUserProfileExtra instance using the specified properties.
         * @function create
         * @memberof AccountUserProfileExtra
         * @static
         * @param {IAccountUserProfileExtra=} [properties] Properties to set
         * @returns {AccountUserProfileExtra} AccountUserProfileExtra instance
         */
        AccountUserProfileExtra.create = function create(properties) {
            return new AccountUserProfileExtra(properties);
        };
    
        /**
         * Encodes the specified AccountUserProfileExtra message. Does not implicitly {@link AccountUserProfileExtra.verify|verify} messages.
         * @function encode
         * @memberof AccountUserProfileExtra
         * @static
         * @param {IAccountUserProfileExtra} message AccountUserProfileExtra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserProfileExtra.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != undefined && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
            if (message.education != undefined && message.education.length)
                for (var i = 0; i < message.education.length; ++i)
                    $root.AccountUserProfileExtra.Position.encode(message.education[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.gender != undefined && message.hasOwnProperty("gender"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.gender);
            if (message.insurance != undefined && message.insurance.length)
                for (var i = 0; i < message.insurance.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.insurance[i]);
            if (message.languages != undefined && message.languages.length)
                for (var i = 0; i < message.languages.length; ++i)
                    $root.AccountUserProfileExtra.Language.encode(message.languages[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.npis != undefined && message.npis.length)
                for (var i = 0; i < message.npis.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.npis[i]);
            if (message.organization != undefined && message.hasOwnProperty("organization"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.organization);
            if (message.specialties != undefined && message.specialties.length)
                for (var i = 0; i < message.specialties.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.specialties[i]);
            if (message.work != undefined && message.work.length)
                for (var i = 0; i < message.work.length; ++i)
                    $root.AccountUserProfileExtra.Position.encode(message.work[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified AccountUserProfileExtra message, length delimited. Does not implicitly {@link AccountUserProfileExtra.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountUserProfileExtra
         * @static
         * @param {IAccountUserProfileExtra} message AccountUserProfileExtra message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserProfileExtra.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountUserProfileExtra message from the specified reader or buffer.
         * @function decode
         * @memberof AccountUserProfileExtra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountUserProfileExtra} AccountUserProfileExtra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserProfileExtra.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserProfileExtra();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                case 2:
                    if (!(message.education && message.education.length))
                        message.education = [];
                    message.education.push($root.AccountUserProfileExtra.Position.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.gender = reader.string();
                    break;
                case 4:
                    if (!(message.insurance && message.insurance.length))
                        message.insurance = [];
                    message.insurance.push(reader.string());
                    break;
                case 5:
                    if (!(message.languages && message.languages.length))
                        message.languages = [];
                    message.languages.push($root.AccountUserProfileExtra.Language.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.npis && message.npis.length))
                        message.npis = [];
                    message.npis.push(reader.string());
                    break;
                case 7:
                    message.organization = reader.string();
                    break;
                case 8:
                    if (!(message.specialties && message.specialties.length))
                        message.specialties = [];
                    message.specialties.push(reader.string());
                    break;
                case 9:
                    if (!(message.work && message.work.length))
                        message.work = [];
                    message.work.push($root.AccountUserProfileExtra.Position.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an AccountUserProfileExtra message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountUserProfileExtra
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountUserProfileExtra} AccountUserProfileExtra
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserProfileExtra.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountUserProfileExtra message.
         * @function verify
         * @memberof AccountUserProfileExtra
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountUserProfileExtra.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.address != undefined && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.education != undefined && message.hasOwnProperty("education")) {
                if (!Array.isArray(message.education))
                    return "education: array expected";
                for (var i = 0; i < message.education.length; ++i) {
                    var error = $root.AccountUserProfileExtra.Position.verify(message.education[i]);
                    if (error)
                        return "education." + error;
                }
            }
            if (message.gender != undefined && message.hasOwnProperty("gender"))
                if (!$util.isString(message.gender))
                    return "gender: string expected";
            if (message.insurance != undefined && message.hasOwnProperty("insurance")) {
                if (!Array.isArray(message.insurance))
                    return "insurance: array expected";
                for (var i = 0; i < message.insurance.length; ++i)
                    if (!$util.isString(message.insurance[i]))
                        return "insurance: string[] expected";
            }
            if (message.languages != undefined && message.hasOwnProperty("languages")) {
                if (!Array.isArray(message.languages))
                    return "languages: array expected";
                for (var i = 0; i < message.languages.length; ++i) {
                    var error = $root.AccountUserProfileExtra.Language.verify(message.languages[i]);
                    if (error)
                        return "languages." + error;
                }
            }
            if (message.npis != undefined && message.hasOwnProperty("npis")) {
                if (!Array.isArray(message.npis))
                    return "npis: array expected";
                for (var i = 0; i < message.npis.length; ++i)
                    if (!$util.isString(message.npis[i]))
                        return "npis: string[] expected";
            }
            if (message.organization != undefined && message.hasOwnProperty("organization"))
                if (!$util.isString(message.organization))
                    return "organization: string expected";
            if (message.specialties != undefined && message.hasOwnProperty("specialties")) {
                if (!Array.isArray(message.specialties))
                    return "specialties: array expected";
                for (var i = 0; i < message.specialties.length; ++i)
                    if (!$util.isString(message.specialties[i]))
                        return "specialties: string[] expected";
            }
            if (message.work != undefined && message.hasOwnProperty("work")) {
                if (!Array.isArray(message.work))
                    return "work: array expected";
                for (var i = 0; i < message.work.length; ++i) {
                    var error = $root.AccountUserProfileExtra.Position.verify(message.work[i]);
                    if (error)
                        return "work." + error;
                }
            }
            return undefined;
        };
    
        /**
         * Creates an AccountUserProfileExtra message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountUserProfileExtra
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountUserProfileExtra} AccountUserProfileExtra
         */
        AccountUserProfileExtra.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountUserProfileExtra)
                return object;
            var message = new $root.AccountUserProfileExtra();
            if (object.address != undefined)
                message.address = String(object.address);
            if (object.education) {
                if (!Array.isArray(object.education))
                    throw TypeError(".AccountUserProfileExtra.education: array expected");
                message.education = [];
                for (var i = 0; i < object.education.length; ++i) {
                    if (typeof object.education[i] !== "object")
                        throw TypeError(".AccountUserProfileExtra.education: object expected");
                    message.education[i] = $root.AccountUserProfileExtra.Position.fromObject(object.education[i]);
                }
            }
            if (object.gender != undefined)
                message.gender = String(object.gender);
            if (object.insurance) {
                if (!Array.isArray(object.insurance))
                    throw TypeError(".AccountUserProfileExtra.insurance: array expected");
                message.insurance = [];
                for (var i = 0; i < object.insurance.length; ++i)
                    message.insurance[i] = String(object.insurance[i]);
            }
            if (object.languages) {
                if (!Array.isArray(object.languages))
                    throw TypeError(".AccountUserProfileExtra.languages: array expected");
                message.languages = [];
                for (var i = 0; i < object.languages.length; ++i) {
                    if (typeof object.languages[i] !== "object")
                        throw TypeError(".AccountUserProfileExtra.languages: object expected");
                    message.languages[i] = $root.AccountUserProfileExtra.Language.fromObject(object.languages[i]);
                }
            }
            if (object.npis) {
                if (!Array.isArray(object.npis))
                    throw TypeError(".AccountUserProfileExtra.npis: array expected");
                message.npis = [];
                for (var i = 0; i < object.npis.length; ++i)
                    message.npis[i] = String(object.npis[i]);
            }
            if (object.organization != undefined)
                message.organization = String(object.organization);
            if (object.specialties) {
                if (!Array.isArray(object.specialties))
                    throw TypeError(".AccountUserProfileExtra.specialties: array expected");
                message.specialties = [];
                for (var i = 0; i < object.specialties.length; ++i)
                    message.specialties[i] = String(object.specialties[i]);
            }
            if (object.work) {
                if (!Array.isArray(object.work))
                    throw TypeError(".AccountUserProfileExtra.work: array expected");
                message.work = [];
                for (var i = 0; i < object.work.length; ++i) {
                    if (typeof object.work[i] !== "object")
                        throw TypeError(".AccountUserProfileExtra.work: object expected");
                    message.work[i] = $root.AccountUserProfileExtra.Position.fromObject(object.work[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from an AccountUserProfileExtra message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountUserProfileExtra
         * @static
         * @param {AccountUserProfileExtra} message AccountUserProfileExtra
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserProfileExtra.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.education = [];
                object.insurance = [];
                object.languages = [];
                object.npis = [];
                object.specialties = [];
                object.work = [];
            }
            if (options.defaults) {
                object.address = "";
                object.gender = "";
                object.organization = "";
            }
            if (message.address != undefined && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.education && message.education.length) {
                object.education = [];
                for (var j = 0; j < message.education.length; ++j)
                    object.education[j] = $root.AccountUserProfileExtra.Position.toObject(message.education[j], options);
            }
            if (message.gender != undefined && message.hasOwnProperty("gender"))
                object.gender = message.gender;
            if (message.insurance && message.insurance.length) {
                object.insurance = [];
                for (var j = 0; j < message.insurance.length; ++j)
                    object.insurance[j] = message.insurance[j];
            }
            if (message.languages && message.languages.length) {
                object.languages = [];
                for (var j = 0; j < message.languages.length; ++j)
                    object.languages[j] = $root.AccountUserProfileExtra.Language.toObject(message.languages[j], options);
            }
            if (message.npis && message.npis.length) {
                object.npis = [];
                for (var j = 0; j < message.npis.length; ++j)
                    object.npis[j] = message.npis[j];
            }
            if (message.organization != undefined && message.hasOwnProperty("organization"))
                object.organization = message.organization;
            if (message.specialties && message.specialties.length) {
                object.specialties = [];
                for (var j = 0; j < message.specialties.length; ++j)
                    object.specialties[j] = message.specialties[j];
            }
            if (message.work && message.work.length) {
                object.work = [];
                for (var j = 0; j < message.work.length; ++j)
                    object.work[j] = $root.AccountUserProfileExtra.Position.toObject(message.work[j], options);
            }
            return object;
        };
    
        /**
         * Converts this AccountUserProfileExtra to JSON.
         * @function toJSON
         * @memberof AccountUserProfileExtra
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserProfileExtra.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        AccountUserProfileExtra.Language = (function() {
    
            /**
             * Properties of a Language.
             * @memberof AccountUserProfileExtra
             * @interface ILanguage
             * @property {string|undefined} [language] Language name.
             * @property {AccountUserProfileExtra.Proficiency|undefined} [proficiency] @see Proficiency
             */
    
            /**
             * Constructs a new Language.
             * @memberof AccountUserProfileExtra
             * @classdesc Language skill.
             * @implements ILanguage
             * @constructor
             * @param {AccountUserProfileExtra.ILanguage=} [properties] Properties to set
             */
            function Language(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Language name.
             * @member {string} language
             * @memberof AccountUserProfileExtra.Language
             * @instance
             */
            Language.prototype.language = "";
    
            /**
             * @see Proficiency
             * @member {AccountUserProfileExtra.Proficiency} proficiency
             * @memberof AccountUserProfileExtra.Language
             * @instance
             */
            Language.prototype.proficiency = 0;
    
            /**
             * Creates a new Language instance using the specified properties.
             * @function create
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {AccountUserProfileExtra.ILanguage=} [properties] Properties to set
             * @returns {AccountUserProfileExtra.Language} Language instance
             */
            Language.create = function create(properties) {
                return new Language(properties);
            };
    
            /**
             * Encodes the specified Language message. Does not implicitly {@link AccountUserProfileExtra.Language.verify|verify} messages.
             * @function encode
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {AccountUserProfileExtra.ILanguage} message Language message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Language.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.language != undefined && message.hasOwnProperty("language"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.language);
                if (message.proficiency != undefined && message.hasOwnProperty("proficiency"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.proficiency);
                return writer;
            };
    
            /**
             * Encodes the specified Language message, length delimited. Does not implicitly {@link AccountUserProfileExtra.Language.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {AccountUserProfileExtra.ILanguage} message Language message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Language.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Language message from the specified reader or buffer.
             * @function decode
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AccountUserProfileExtra.Language} Language
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Language.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserProfileExtra.Language();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.language = reader.string();
                        break;
                    case 2:
                        message.proficiency = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Language message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AccountUserProfileExtra.Language} Language
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Language.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Language message.
             * @function verify
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Language.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.language != undefined && message.hasOwnProperty("language"))
                    if (!$util.isString(message.language))
                        return "language: string expected";
                if (message.proficiency != undefined && message.hasOwnProperty("proficiency"))
                    switch (message.proficiency) {
                    default:
                        return "proficiency: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return undefined;
            };
    
            /**
             * Creates a Language message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AccountUserProfileExtra.Language} Language
             */
            Language.fromObject = function fromObject(object) {
                if (object instanceof $root.AccountUserProfileExtra.Language)
                    return object;
                var message = new $root.AccountUserProfileExtra.Language();
                if (object.language != undefined)
                    message.language = String(object.language);
                switch (object.proficiency) {
                case "Basic":
                case 0:
                    message.proficiency = 0;
                    break;
                case "Intermediate":
                case 1:
                    message.proficiency = 1;
                    break;
                case "Fluent":
                case 2:
                    message.proficiency = 2;
                    break;
                case "Native":
                case 3:
                    message.proficiency = 3;
                    break;
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Language message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AccountUserProfileExtra.Language
             * @static
             * @param {AccountUserProfileExtra.Language} message Language
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Language.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.language = "";
                    object.proficiency = options.enums === String ? "Basic" : 0;
                }
                if (message.language != undefined && message.hasOwnProperty("language"))
                    object.language = message.language;
                if (message.proficiency != undefined && message.hasOwnProperty("proficiency"))
                    object.proficiency = options.enums === String ? $root.AccountUserProfileExtra.Proficiency[message.proficiency] : message.proficiency;
                return object;
            };
    
            /**
             * Converts this Language to JSON.
             * @function toJSON
             * @memberof AccountUserProfileExtra.Language
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Language.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Language;
        })();
    
        AccountUserProfileExtra.Position = (function() {
    
            /**
             * Properties of a Position.
             * @memberof AccountUserProfileExtra
             * @interface IPosition
             * @property {string|undefined} [detail] Extra information (e.g. position title or degree subject).
             * @property {number|undefined} [endDate] End date timestamp.
             * @property {string|undefined} [locationName] Position locationName
             * @property {string|undefined} [locationURL] Position locationURL
             * @property {number|undefined} [startDate] Start date timestamp.
             */
    
            /**
             * Constructs a new Position.
             * @memberof AccountUserProfileExtra
             * @classdesc Any sort of vocational or educational position.
             * @implements IPosition
             * @constructor
             * @param {AccountUserProfileExtra.IPosition=} [properties] Properties to set
             */
            function Position(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Extra information (e.g. position title or degree subject).
             * @member {string} detail
             * @memberof AccountUserProfileExtra.Position
             * @instance
             */
            Position.prototype.detail = "";
    
            /**
             * End date timestamp.
             * @member {number} endDate
             * @memberof AccountUserProfileExtra.Position
             * @instance
             */
            Position.prototype.endDate = 0;
    
            /**
             * Position locationName.
             * @member {string} locationName
             * @memberof AccountUserProfileExtra.Position
             * @instance
             */
            Position.prototype.locationName = "";
    
            /**
             * Position locationURL.
             * @member {string} locationURL
             * @memberof AccountUserProfileExtra.Position
             * @instance
             */
            Position.prototype.locationURL = "";
    
            /**
             * Start date timestamp.
             * @member {number} startDate
             * @memberof AccountUserProfileExtra.Position
             * @instance
             */
            Position.prototype.startDate = 0;
    
            /**
             * Creates a new Position instance using the specified properties.
             * @function create
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {AccountUserProfileExtra.IPosition=} [properties] Properties to set
             * @returns {AccountUserProfileExtra.Position} Position instance
             */
            Position.create = function create(properties) {
                return new Position(properties);
            };
    
            /**
             * Encodes the specified Position message. Does not implicitly {@link AccountUserProfileExtra.Position.verify|verify} messages.
             * @function encode
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {AccountUserProfileExtra.IPosition} message Position message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Position.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.detail != undefined && message.hasOwnProperty("detail"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.detail);
                if (message.endDate != undefined && message.hasOwnProperty("endDate"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.endDate);
                if (message.locationName != undefined && message.hasOwnProperty("locationName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.locationName);
                if (message.locationURL != undefined && message.hasOwnProperty("locationURL"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.locationURL);
                if (message.startDate != undefined && message.hasOwnProperty("startDate"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.startDate);
                return writer;
            };
    
            /**
             * Encodes the specified Position message, length delimited. Does not implicitly {@link AccountUserProfileExtra.Position.verify|verify} messages.
             * @function encodeDelimited
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {AccountUserProfileExtra.IPosition} message Position message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Position.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Position message from the specified reader or buffer.
             * @function decode
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {AccountUserProfileExtra.Position} Position
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Position.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserProfileExtra.Position();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.detail = reader.string();
                        break;
                    case 2:
                        message.endDate = reader.double();
                        break;
                    case 3:
                        message.locationName = reader.string();
                        break;
                    case 4:
                        message.locationURL = reader.string();
                        break;
                    case 5:
                        message.startDate = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Position message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {AccountUserProfileExtra.Position} Position
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Position.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Position message.
             * @function verify
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Position.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.detail != undefined && message.hasOwnProperty("detail"))
                    if (!$util.isString(message.detail))
                        return "detail: string expected";
                if (message.endDate != undefined && message.hasOwnProperty("endDate"))
                    if (typeof message.endDate !== "number")
                        return "endDate: number expected";
                if (message.locationName != undefined && message.hasOwnProperty("locationName"))
                    if (!$util.isString(message.locationName))
                        return "locationName: string expected";
                if (message.locationURL != undefined && message.hasOwnProperty("locationURL"))
                    if (!$util.isString(message.locationURL))
                        return "locationURL: string expected";
                if (message.startDate != undefined && message.hasOwnProperty("startDate"))
                    if (typeof message.startDate !== "number")
                        return "startDate: number expected";
                return undefined;
            };
    
            /**
             * Creates a Position message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {AccountUserProfileExtra.Position} Position
             */
            Position.fromObject = function fromObject(object) {
                if (object instanceof $root.AccountUserProfileExtra.Position)
                    return object;
                var message = new $root.AccountUserProfileExtra.Position();
                if (object.detail != undefined)
                    message.detail = String(object.detail);
                if (object.endDate != undefined)
                    message.endDate = Number(object.endDate);
                if (object.locationName != undefined)
                    message.locationName = String(object.locationName);
                if (object.locationURL != undefined)
                    message.locationURL = String(object.locationURL);
                if (object.startDate != undefined)
                    message.startDate = Number(object.startDate);
                return message;
            };
    
            /**
             * Creates a plain object from a Position message. Also converts values to other types if specified.
             * @function toObject
             * @memberof AccountUserProfileExtra.Position
             * @static
             * @param {AccountUserProfileExtra.Position} message Position
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Position.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.detail = "";
                    object.endDate = 0;
                    object.locationName = "";
                    object.locationURL = "";
                    object.startDate = 0;
                }
                if (message.detail != undefined && message.hasOwnProperty("detail"))
                    object.detail = message.detail;
                if (message.endDate != undefined && message.hasOwnProperty("endDate"))
                    object.endDate = options.json && !isFinite(message.endDate) ? String(message.endDate) : message.endDate;
                if (message.locationName != undefined && message.hasOwnProperty("locationName"))
                    object.locationName = message.locationName;
                if (message.locationURL != undefined && message.hasOwnProperty("locationURL"))
                    object.locationURL = message.locationURL;
                if (message.startDate != undefined && message.hasOwnProperty("startDate"))
                    object.startDate = options.json && !isFinite(message.startDate) ? String(message.startDate) : message.startDate;
                return object;
            };
    
            /**
             * Converts this Position to JSON.
             * @function toJSON
             * @memberof AccountUserProfileExtra.Position
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Position.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Position;
        })();
    
        /**
         * Level of proficiency in a skill.
         * @name AccountUserProfileExtra.Proficiency
         * @enum {string}
         * @property {number} Basic=0 Basic value
         * @property {number} Intermediate=1 Intermediate value
         * @property {number} Fluent=2 Fluent value
         * @property {number} Native=3 Native value
         */
        AccountUserProfileExtra.Proficiency = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Basic"] = 0;
            values[valuesById[1] = "Intermediate"] = 1;
            values[valuesById[2] = "Fluent"] = 2;
            values[valuesById[3] = "Native"] = 3;
            return values;
        })();
    
        return AccountUserProfileExtra;
    })();
    
    $root.AccountUserPublicKeys = (function() {
    
        /**
         * Properties of an AccountUserPublicKeys.
         * @exports IAccountUserPublicKeys
         * @interface IAccountUserPublicKeys
         * @property {Uint8Array} encryption Potassium.Box public key.
         * @property {Uint8Array} signing Potassium.Sign public key.
         */
    
        /**
         * Constructs a new AccountUserPublicKeys.
         * @exports AccountUserPublicKeys
         * @classdesc AGSE-PKI certificate.
         * @implements IAccountUserPublicKeys
         * @constructor
         * @param {IAccountUserPublicKeys=} [properties] Properties to set
         */
        function AccountUserPublicKeys(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Potassium.Box public key.
         * @member {Uint8Array} encryption
         * @memberof AccountUserPublicKeys
         * @instance
         */
        AccountUserPublicKeys.prototype.encryption = $util.newBuffer([]);
    
        /**
         * Potassium.Sign public key.
         * @member {Uint8Array} signing
         * @memberof AccountUserPublicKeys
         * @instance
         */
        AccountUserPublicKeys.prototype.signing = $util.newBuffer([]);
    
        /**
         * Creates a new AccountUserPublicKeys instance using the specified properties.
         * @function create
         * @memberof AccountUserPublicKeys
         * @static
         * @param {IAccountUserPublicKeys=} [properties] Properties to set
         * @returns {AccountUserPublicKeys} AccountUserPublicKeys instance
         */
        AccountUserPublicKeys.create = function create(properties) {
            return new AccountUserPublicKeys(properties);
        };
    
        /**
         * Encodes the specified AccountUserPublicKeys message. Does not implicitly {@link AccountUserPublicKeys.verify|verify} messages.
         * @function encode
         * @memberof AccountUserPublicKeys
         * @static
         * @param {IAccountUserPublicKeys} message AccountUserPublicKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserPublicKeys.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.encryption);
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.signing);
            return writer;
        };
    
        /**
         * Encodes the specified AccountUserPublicKeys message, length delimited. Does not implicitly {@link AccountUserPublicKeys.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AccountUserPublicKeys
         * @static
         * @param {IAccountUserPublicKeys} message AccountUserPublicKeys message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserPublicKeys.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an AccountUserPublicKeys message from the specified reader or buffer.
         * @function decode
         * @memberof AccountUserPublicKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AccountUserPublicKeys} AccountUserPublicKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserPublicKeys.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountUserPublicKeys();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.encryption = reader.bytes();
                    break;
                case 2:
                    message.signing = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("encryption"))
                throw $util.ProtocolError("missing required 'encryption'", { instance: message });
            if (!message.hasOwnProperty("signing"))
                throw $util.ProtocolError("missing required 'signing'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an AccountUserPublicKeys message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AccountUserPublicKeys
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AccountUserPublicKeys} AccountUserPublicKeys
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserPublicKeys.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an AccountUserPublicKeys message.
         * @function verify
         * @memberof AccountUserPublicKeys
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AccountUserPublicKeys.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!(message.encryption && typeof message.encryption.length === "number" || $util.isString(message.encryption)))
                return "encryption: buffer expected";
            if (!(message.signing && typeof message.signing.length === "number" || $util.isString(message.signing)))
                return "signing: buffer expected";
            return undefined;
        };
    
        /**
         * Creates an AccountUserPublicKeys message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AccountUserPublicKeys
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AccountUserPublicKeys} AccountUserPublicKeys
         */
        AccountUserPublicKeys.fromObject = function fromObject(object) {
            if (object instanceof $root.AccountUserPublicKeys)
                return object;
            var message = new $root.AccountUserPublicKeys();
            if (object.encryption != undefined)
                if (typeof object.encryption === "string")
                    $util.base64.decode(object.encryption, message.encryption = $util.newBuffer($util.base64.length(object.encryption)), 0);
                else if (object.encryption.length)
                    message.encryption = object.encryption;
            if (object.signing != undefined)
                if (typeof object.signing === "string")
                    $util.base64.decode(object.signing, message.signing = $util.newBuffer($util.base64.length(object.signing)), 0);
                else if (object.signing.length)
                    message.signing = object.signing;
            return message;
        };
    
        /**
         * Creates a plain object from an AccountUserPublicKeys message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AccountUserPublicKeys
         * @static
         * @param {AccountUserPublicKeys} message AccountUserPublicKeys
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserPublicKeys.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encryption = options.bytes === String ? "" : [];
                object.signing = options.bytes === String ? "" : [];
            }
            if (message.encryption != undefined && message.hasOwnProperty("encryption"))
                object.encryption = options.bytes === String ? $util.base64.encode(message.encryption, 0, message.encryption.length) : options.bytes === Array ? Array.prototype.slice.call(message.encryption) : message.encryption;
            if (message.signing != undefined && message.hasOwnProperty("signing"))
                object.signing = options.bytes === String ? $util.base64.encode(message.signing, 0, message.signing.length) : options.bytes === Array ? Array.prototype.slice.call(message.signing) : message.signing;
            return object;
        };
    
        /**
         * Converts this AccountUserPublicKeys to JSON.
         * @function toJSON
         * @memberof AccountUserPublicKeys
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserPublicKeys.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AccountUserPublicKeys;
    })();
    
    /**
     * Account types for different Cyph-based applications.
     * @exports AccountUserTypes
     * @enum {string}
     * @property {number} Standard=0 Standard value
     * @property {number} Org=1 Org value
     * @property {number} TelehealthAdmin=2 TelehealthAdmin value
     * @property {number} TelehealthDoctor=3 TelehealthDoctor value
     */
    $root.AccountUserTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Standard"] = 0;
        values[valuesById[1] = "Org"] = 1;
        values[valuesById[2] = "TelehealthAdmin"] = 2;
        values[valuesById[3] = "TelehealthDoctor"] = 3;
        return values;
    })();
    
    $root.AGSEPKICert = (function() {
    
        /**
         * Properties of a AGSEPKICert.
         * @exports IAGSEPKICert
         * @interface IAGSEPKICert
         * @property {IAGSEPKICSR} agsePKICSR @see AccountUserPublicKeys.signing
         * @property {number} timestamp Timestamp of certificate issuance.
         */
    
        /**
         * Constructs a new AGSEPKICert.
         * @exports AGSEPKICert
         * @classdesc AGSE-PKI certificate.
         * @implements IAGSEPKICert
         * @constructor
         * @param {IAGSEPKICert=} [properties] Properties to set
         */
        function AGSEPKICert(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see AccountUserPublicKeys.signing
         * @member {IAGSEPKICSR} agsePKICSR
         * @memberof AGSEPKICert
         * @instance
         */
        AGSEPKICert.prototype.agsePKICSR = undefined;
    
        /**
         * Timestamp of certificate issuance.
         * @member {number} timestamp
         * @memberof AGSEPKICert
         * @instance
         */
        AGSEPKICert.prototype.timestamp = 0;
    
        /**
         * Creates a new AGSEPKICert instance using the specified properties.
         * @function create
         * @memberof AGSEPKICert
         * @static
         * @param {IAGSEPKICert=} [properties] Properties to set
         * @returns {AGSEPKICert} AGSEPKICert instance
         */
        AGSEPKICert.create = function create(properties) {
            return new AGSEPKICert(properties);
        };
    
        /**
         * Encodes the specified AGSEPKICert message. Does not implicitly {@link AGSEPKICert.verify|verify} messages.
         * @function encode
         * @memberof AGSEPKICert
         * @static
         * @param {IAGSEPKICert} message AGSEPKICert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKICert.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.AGSEPKICSR.encode(message.agsePKICSR, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified AGSEPKICert message, length delimited. Does not implicitly {@link AGSEPKICert.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AGSEPKICert
         * @static
         * @param {IAGSEPKICert} message AGSEPKICert message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKICert.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a AGSEPKICert message from the specified reader or buffer.
         * @function decode
         * @memberof AGSEPKICert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AGSEPKICert} AGSEPKICert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKICert.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AGSEPKICert();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.agsePKICSR = $root.AGSEPKICSR.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("agsePKICSR"))
                throw $util.ProtocolError("missing required 'agsePKICSR'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a AGSEPKICert message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AGSEPKICert
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AGSEPKICert} AGSEPKICert
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKICert.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a AGSEPKICert message.
         * @function verify
         * @memberof AGSEPKICert
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AGSEPKICert.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            {
                var error = $root.AGSEPKICSR.verify(message.agsePKICSR);
                if (error)
                    return "agsePKICSR." + error;
            }
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            return undefined;
        };
    
        /**
         * Creates a AGSEPKICert message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AGSEPKICert
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AGSEPKICert} AGSEPKICert
         */
        AGSEPKICert.fromObject = function fromObject(object) {
            if (object instanceof $root.AGSEPKICert)
                return object;
            var message = new $root.AGSEPKICert();
            if (object.agsePKICSR != undefined) {
                if (typeof object.agsePKICSR !== "object")
                    throw TypeError(".AGSEPKICert.agsePKICSR: object expected");
                message.agsePKICSR = $root.AGSEPKICSR.fromObject(object.agsePKICSR);
            }
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            return message;
        };
    
        /**
         * Creates a plain object from a AGSEPKICert message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AGSEPKICert
         * @static
         * @param {AGSEPKICert} message AGSEPKICert
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AGSEPKICert.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.agsePKICSR = undefined;
                object.timestamp = 0;
            }
            if (message.agsePKICSR != undefined && message.hasOwnProperty("agsePKICSR"))
                object.agsePKICSR = $root.AGSEPKICSR.toObject(message.agsePKICSR, options);
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };
    
        /**
         * Converts this AGSEPKICert to JSON.
         * @function toJSON
         * @memberof AGSEPKICert
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AGSEPKICert.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AGSEPKICert;
    })();
    
    $root.AGSEPKICSR = (function() {
    
        /**
         * Properties of a AGSEPKICSR.
         * @exports IAGSEPKICSR
         * @interface IAGSEPKICSR
         * @property {Uint8Array} publicSigningKey @see AccountUserPublicKeys.signing
         * @property {string} username Username.
         */
    
        /**
         * Constructs a new AGSEPKICSR.
         * @exports AGSEPKICSR
         * @classdesc AGSE-PKI certificate signing request.
         * @implements IAGSEPKICSR
         * @constructor
         * @param {IAGSEPKICSR=} [properties] Properties to set
         */
        function AGSEPKICSR(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see AccountUserPublicKeys.signing
         * @member {Uint8Array} publicSigningKey
         * @memberof AGSEPKICSR
         * @instance
         */
        AGSEPKICSR.prototype.publicSigningKey = $util.newBuffer([]);
    
        /**
         * Username.
         * @member {string} username
         * @memberof AGSEPKICSR
         * @instance
         */
        AGSEPKICSR.prototype.username = "";
    
        /**
         * Creates a new AGSEPKICSR instance using the specified properties.
         * @function create
         * @memberof AGSEPKICSR
         * @static
         * @param {IAGSEPKICSR=} [properties] Properties to set
         * @returns {AGSEPKICSR} AGSEPKICSR instance
         */
        AGSEPKICSR.create = function create(properties) {
            return new AGSEPKICSR(properties);
        };
    
        /**
         * Encodes the specified AGSEPKICSR message. Does not implicitly {@link AGSEPKICSR.verify|verify} messages.
         * @function encode
         * @memberof AGSEPKICSR
         * @static
         * @param {IAGSEPKICSR} message AGSEPKICSR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKICSR.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.publicSigningKey);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.username);
            return writer;
        };
    
        /**
         * Encodes the specified AGSEPKICSR message, length delimited. Does not implicitly {@link AGSEPKICSR.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AGSEPKICSR
         * @static
         * @param {IAGSEPKICSR} message AGSEPKICSR message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKICSR.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a AGSEPKICSR message from the specified reader or buffer.
         * @function decode
         * @memberof AGSEPKICSR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AGSEPKICSR} AGSEPKICSR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKICSR.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AGSEPKICSR();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.publicSigningKey = reader.bytes();
                    break;
                case 2:
                    message.username = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("publicSigningKey"))
                throw $util.ProtocolError("missing required 'publicSigningKey'", { instance: message });
            if (!message.hasOwnProperty("username"))
                throw $util.ProtocolError("missing required 'username'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a AGSEPKICSR message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AGSEPKICSR
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AGSEPKICSR} AGSEPKICSR
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKICSR.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a AGSEPKICSR message.
         * @function verify
         * @memberof AGSEPKICSR
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AGSEPKICSR.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!(message.publicSigningKey && typeof message.publicSigningKey.length === "number" || $util.isString(message.publicSigningKey)))
                return "publicSigningKey: buffer expected";
            if (!$util.isString(message.username))
                return "username: string expected";
            return undefined;
        };
    
        /**
         * Creates a AGSEPKICSR message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AGSEPKICSR
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AGSEPKICSR} AGSEPKICSR
         */
        AGSEPKICSR.fromObject = function fromObject(object) {
            if (object instanceof $root.AGSEPKICSR)
                return object;
            var message = new $root.AGSEPKICSR();
            if (object.publicSigningKey != undefined)
                if (typeof object.publicSigningKey === "string")
                    $util.base64.decode(object.publicSigningKey, message.publicSigningKey = $util.newBuffer($util.base64.length(object.publicSigningKey)), 0);
                else if (object.publicSigningKey.length)
                    message.publicSigningKey = object.publicSigningKey;
            if (object.username != undefined)
                message.username = String(object.username);
            return message;
        };
    
        /**
         * Creates a plain object from a AGSEPKICSR message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AGSEPKICSR
         * @static
         * @param {AGSEPKICSR} message AGSEPKICSR
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AGSEPKICSR.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.publicSigningKey = options.bytes === String ? "" : [];
                object.username = "";
            }
            if (message.publicSigningKey != undefined && message.hasOwnProperty("publicSigningKey"))
                object.publicSigningKey = options.bytes === String ? $util.base64.encode(message.publicSigningKey, 0, message.publicSigningKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicSigningKey) : message.publicSigningKey;
            if (message.username != undefined && message.hasOwnProperty("username"))
                object.username = message.username;
            return object;
        };
    
        /**
         * Converts this AGSEPKICSR to JSON.
         * @function toJSON
         * @memberof AGSEPKICSR
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AGSEPKICSR.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AGSEPKICSR;
    })();
    
    $root.AGSEPKIIssuanceHistory = (function() {
    
        /**
         * Properties of a AGSEPKIIssuanceHistory.
         * @exports IAGSEPKIIssuanceHistory
         * @interface IAGSEPKIIssuanceHistory
         * @property {Object.<string,boolean>|undefined} [publicSigningKeyHashes] Public key hashes.
         * @property {number} timestamp Timestamp.
         * @property {Object.<string,boolean>|undefined} [usernames] Usernames.
         */
    
        /**
         * Constructs a new AGSEPKIIssuanceHistory.
         * @exports AGSEPKIIssuanceHistory
         * @classdesc AGSE-PKI history of previous issuances.
         * @implements IAGSEPKIIssuanceHistory
         * @constructor
         * @param {IAGSEPKIIssuanceHistory=} [properties] Properties to set
         */
        function AGSEPKIIssuanceHistory(properties) {
            this.publicSigningKeyHashes = {};
            this.usernames = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Public key hashes.
         * @member {Object.<string,boolean>} publicSigningKeyHashes
         * @memberof AGSEPKIIssuanceHistory
         * @instance
         */
        AGSEPKIIssuanceHistory.prototype.publicSigningKeyHashes = $util.emptyObject;
    
        /**
         * Timestamp.
         * @member {number} timestamp
         * @memberof AGSEPKIIssuanceHistory
         * @instance
         */
        AGSEPKIIssuanceHistory.prototype.timestamp = 0;
    
        /**
         * Usernames.
         * @member {Object.<string,boolean>} usernames
         * @memberof AGSEPKIIssuanceHistory
         * @instance
         */
        AGSEPKIIssuanceHistory.prototype.usernames = $util.emptyObject;
    
        /**
         * Creates a new AGSEPKIIssuanceHistory instance using the specified properties.
         * @function create
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {IAGSEPKIIssuanceHistory=} [properties] Properties to set
         * @returns {AGSEPKIIssuanceHistory} AGSEPKIIssuanceHistory instance
         */
        AGSEPKIIssuanceHistory.create = function create(properties) {
            return new AGSEPKIIssuanceHistory(properties);
        };
    
        /**
         * Encodes the specified AGSEPKIIssuanceHistory message. Does not implicitly {@link AGSEPKIIssuanceHistory.verify|verify} messages.
         * @function encode
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {IAGSEPKIIssuanceHistory} message AGSEPKIIssuanceHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKIIssuanceHistory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.publicSigningKeyHashes != undefined && message.hasOwnProperty("publicSigningKeyHashes"))
                for (var keys = Object.keys(message.publicSigningKeyHashes), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.publicSigningKeyHashes[keys[i]]).ldelim();
            writer.uint32(/* id 2, wireType 1 =*/17).double(message.timestamp);
            if (message.usernames != undefined && message.hasOwnProperty("usernames"))
                for (var keys = Object.keys(message.usernames), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.usernames[keys[i]]).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified AGSEPKIIssuanceHistory message, length delimited. Does not implicitly {@link AGSEPKIIssuanceHistory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {IAGSEPKIIssuanceHistory} message AGSEPKIIssuanceHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AGSEPKIIssuanceHistory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a AGSEPKIIssuanceHistory message from the specified reader or buffer.
         * @function decode
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {AGSEPKIIssuanceHistory} AGSEPKIIssuanceHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKIIssuanceHistory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.AGSEPKIIssuanceHistory(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.publicSigningKeyHashes === $util.emptyObject)
                        message.publicSigningKeyHashes = {};
                    key = reader.string();
                    reader.pos++;
                    message.publicSigningKeyHashes[key] = reader.bool();
                    break;
                case 2:
                    message.timestamp = reader.double();
                    break;
                case 3:
                    reader.skip().pos++;
                    if (message.usernames === $util.emptyObject)
                        message.usernames = {};
                    key = reader.string();
                    reader.pos++;
                    message.usernames[key] = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a AGSEPKIIssuanceHistory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {AGSEPKIIssuanceHistory} AGSEPKIIssuanceHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AGSEPKIIssuanceHistory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a AGSEPKIIssuanceHistory message.
         * @function verify
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        AGSEPKIIssuanceHistory.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.publicSigningKeyHashes != undefined && message.hasOwnProperty("publicSigningKeyHashes")) {
                if (!$util.isObject(message.publicSigningKeyHashes))
                    return "publicSigningKeyHashes: object expected";
                var key = Object.keys(message.publicSigningKeyHashes);
                for (var i = 0; i < key.length; ++i)
                    if (typeof message.publicSigningKeyHashes[key[i]] !== "boolean")
                        return "publicSigningKeyHashes: boolean{k:string} expected";
            }
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (message.usernames != undefined && message.hasOwnProperty("usernames")) {
                if (!$util.isObject(message.usernames))
                    return "usernames: object expected";
                var key = Object.keys(message.usernames);
                for (var i = 0; i < key.length; ++i)
                    if (typeof message.usernames[key[i]] !== "boolean")
                        return "usernames: boolean{k:string} expected";
            }
            return undefined;
        };
    
        /**
         * Creates a AGSEPKIIssuanceHistory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {AGSEPKIIssuanceHistory} AGSEPKIIssuanceHistory
         */
        AGSEPKIIssuanceHistory.fromObject = function fromObject(object) {
            if (object instanceof $root.AGSEPKIIssuanceHistory)
                return object;
            var message = new $root.AGSEPKIIssuanceHistory();
            if (object.publicSigningKeyHashes) {
                if (typeof object.publicSigningKeyHashes !== "object")
                    throw TypeError(".AGSEPKIIssuanceHistory.publicSigningKeyHashes: object expected");
                message.publicSigningKeyHashes = {};
                for (var keys = Object.keys(object.publicSigningKeyHashes), i = 0; i < keys.length; ++i)
                    message.publicSigningKeyHashes[keys[i]] = Boolean(object.publicSigningKeyHashes[keys[i]]);
            }
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            if (object.usernames) {
                if (typeof object.usernames !== "object")
                    throw TypeError(".AGSEPKIIssuanceHistory.usernames: object expected");
                message.usernames = {};
                for (var keys = Object.keys(object.usernames), i = 0; i < keys.length; ++i)
                    message.usernames[keys[i]] = Boolean(object.usernames[keys[i]]);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a AGSEPKIIssuanceHistory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof AGSEPKIIssuanceHistory
         * @static
         * @param {AGSEPKIIssuanceHistory} message AGSEPKIIssuanceHistory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AGSEPKIIssuanceHistory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.publicSigningKeyHashes = {};
                object.usernames = {};
            }
            if (options.defaults)
                object.timestamp = 0;
            var keys2;
            if (message.publicSigningKeyHashes && (keys2 = Object.keys(message.publicSigningKeyHashes)).length) {
                object.publicSigningKeyHashes = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.publicSigningKeyHashes[keys2[j]] = message.publicSigningKeyHashes[keys2[j]];
            }
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.usernames && (keys2 = Object.keys(message.usernames)).length) {
                object.usernames = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.usernames[keys2[j]] = message.usernames[keys2[j]];
            }
            return object;
        };
    
        /**
         * Converts this AGSEPKIIssuanceHistory to JSON.
         * @function toJSON
         * @memberof AGSEPKIIssuanceHistory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AGSEPKIIssuanceHistory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return AGSEPKIIssuanceHistory;
    })();
    
    $root.Appointment = (function() {
    
        /**
         * Properties of an Appointment.
         * @exports IAppointment
         * @interface IAppointment
         * @property {ICalendarInvite} calendarInvite @see CalendarInvite
         * @property {Appointment.IEHR|undefined} [data] EHR-specific data related to the appointment.
         * @property {Array.<IForm>|undefined} [forms] Relevant forms.
         * @property {string|undefined} [notes] Notes taken during the appointment.
         * @property {boolean|undefined} [occurred] Confirmation that the appointment occurred.
         * @property {Array.<string>|undefined} [participants] Participant usernames.
         * @property {string} rsvpSessionSubID Sub-session ID where RSVP statuses are posted.
         */
    
        /**
         * Constructs a new Appointment.
         * @exports Appointment
         * @classdesc Appointment.
         * @implements IAppointment
         * @constructor
         * @param {IAppointment=} [properties] Properties to set
         */
        function Appointment(properties) {
            this.forms = [];
            this.participants = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see CalendarInvite
         * @member {ICalendarInvite} calendarInvite
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.calendarInvite = undefined;
    
        /**
         * EHR-specific data related to the appointment.
         * @member {Appointment.IEHR|undefined|undefined} data
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.data = undefined;
    
        /**
         * Relevant forms.
         * @member {Array.<IForm>} forms
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.forms = $util.emptyArray;
    
        /**
         * Notes taken during the appointment.
         * @member {string} notes
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.notes = "";
    
        /**
         * Confirmation that the appointment occurred.
         * @member {boolean} occurred
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.occurred = false;
    
        /**
         * Participant usernames.
         * @member {Array.<string>} participants
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.participants = $util.emptyArray;
    
        /**
         * Sub-session ID where RSVP statuses are posted.
         * @member {string} rsvpSessionSubID
         * @memberof Appointment
         * @instance
         */
        Appointment.prototype.rsvpSessionSubID = "";
    
        /**
         * Creates a new Appointment instance using the specified properties.
         * @function create
         * @memberof Appointment
         * @static
         * @param {IAppointment=} [properties] Properties to set
         * @returns {Appointment} Appointment instance
         */
        Appointment.create = function create(properties) {
            return new Appointment(properties);
        };
    
        /**
         * Encodes the specified Appointment message. Does not implicitly {@link Appointment.verify|verify} messages.
         * @function encode
         * @memberof Appointment
         * @static
         * @param {IAppointment} message Appointment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Appointment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            $root.CalendarInvite.encode(message.calendarInvite, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.data != undefined && message.hasOwnProperty("data"))
                $root.Appointment.EHR.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.forms != undefined && message.forms.length)
                for (var i = 0; i < message.forms.length; ++i)
                    $root.Form.encode(message.forms[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.notes != undefined && message.hasOwnProperty("notes"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.notes);
            if (message.occurred != undefined && message.hasOwnProperty("occurred"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.occurred);
            if (message.participants != undefined && message.participants.length)
                for (var i = 0; i < message.participants.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.participants[i]);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.rsvpSessionSubID);
            return writer;
        };
    
        /**
         * Encodes the specified Appointment message, length delimited. Does not implicitly {@link Appointment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Appointment
         * @static
         * @param {IAppointment} message Appointment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Appointment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an Appointment message from the specified reader or buffer.
         * @function decode
         * @memberof Appointment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Appointment} Appointment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Appointment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Appointment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.calendarInvite = $root.CalendarInvite.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.data = $root.Appointment.EHR.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.forms && message.forms.length))
                        message.forms = [];
                    message.forms.push($root.Form.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.notes = reader.string();
                    break;
                case 5:
                    message.occurred = reader.bool();
                    break;
                case 6:
                    if (!(message.participants && message.participants.length))
                        message.participants = [];
                    message.participants.push(reader.string());
                    break;
                case 7:
                    message.rsvpSessionSubID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("calendarInvite"))
                throw $util.ProtocolError("missing required 'calendarInvite'", { instance: message });
            if (!message.hasOwnProperty("rsvpSessionSubID"))
                throw $util.ProtocolError("missing required 'rsvpSessionSubID'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an Appointment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Appointment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Appointment} Appointment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Appointment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an Appointment message.
         * @function verify
         * @memberof Appointment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        Appointment.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            {
                var error = $root.CalendarInvite.verify(message.calendarInvite);
                if (error)
                    return "calendarInvite." + error;
            }
            if (message.data != undefined && message.hasOwnProperty("data")) {
                var error = $root.Appointment.EHR.verify(message.data);
                if (error)
                    return "data." + error;
            }
            if (message.forms != undefined && message.hasOwnProperty("forms")) {
                if (!Array.isArray(message.forms))
                    return "forms: array expected";
                for (var i = 0; i < message.forms.length; ++i) {
                    var error = $root.Form.verify(message.forms[i]);
                    if (error)
                        return "forms." + error;
                }
            }
            if (message.notes != undefined && message.hasOwnProperty("notes"))
                if (!$util.isString(message.notes))
                    return "notes: string expected";
            if (message.occurred != undefined && message.hasOwnProperty("occurred"))
                if (typeof message.occurred !== "boolean")
                    return "occurred: boolean expected";
            if (message.participants != undefined && message.hasOwnProperty("participants")) {
                if (!Array.isArray(message.participants))
                    return "participants: array expected";
                for (var i = 0; i < message.participants.length; ++i)
                    if (!$util.isString(message.participants[i]))
                        return "participants: string[] expected";
            }
            if (!$util.isString(message.rsvpSessionSubID))
                return "rsvpSessionSubID: string expected";
            return undefined;
        };
    
        /**
         * Creates an Appointment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Appointment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Appointment} Appointment
         */
        Appointment.fromObject = function fromObject(object) {
            if (object instanceof $root.Appointment)
                return object;
            var message = new $root.Appointment();
            if (object.calendarInvite != undefined) {
                if (typeof object.calendarInvite !== "object")
                    throw TypeError(".Appointment.calendarInvite: object expected");
                message.calendarInvite = $root.CalendarInvite.fromObject(object.calendarInvite);
            }
            if (object.data != undefined) {
                if (typeof object.data !== "object")
                    throw TypeError(".Appointment.data: object expected");
                message.data = $root.Appointment.EHR.fromObject(object.data);
            }
            if (object.forms) {
                if (!Array.isArray(object.forms))
                    throw TypeError(".Appointment.forms: array expected");
                message.forms = [];
                for (var i = 0; i < object.forms.length; ++i) {
                    if (typeof object.forms[i] !== "object")
                        throw TypeError(".Appointment.forms: object expected");
                    message.forms[i] = $root.Form.fromObject(object.forms[i]);
                }
            }
            if (object.notes != undefined)
                message.notes = String(object.notes);
            if (object.occurred != undefined)
                message.occurred = Boolean(object.occurred);
            if (object.participants) {
                if (!Array.isArray(object.participants))
                    throw TypeError(".Appointment.participants: array expected");
                message.participants = [];
                for (var i = 0; i < object.participants.length; ++i)
                    message.participants[i] = String(object.participants[i]);
            }
            if (object.rsvpSessionSubID != undefined)
                message.rsvpSessionSubID = String(object.rsvpSessionSubID);
            return message;
        };
    
        /**
         * Creates a plain object from an Appointment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Appointment
         * @static
         * @param {Appointment} message Appointment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Appointment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.forms = [];
                object.participants = [];
            }
            if (options.defaults) {
                object.calendarInvite = undefined;
                object.data = undefined;
                object.notes = "";
                object.occurred = false;
                object.rsvpSessionSubID = "";
            }
            if (message.calendarInvite != undefined && message.hasOwnProperty("calendarInvite"))
                object.calendarInvite = $root.CalendarInvite.toObject(message.calendarInvite, options);
            if (message.data != undefined && message.hasOwnProperty("data"))
                object.data = $root.Appointment.EHR.toObject(message.data, options);
            if (message.forms && message.forms.length) {
                object.forms = [];
                for (var j = 0; j < message.forms.length; ++j)
                    object.forms[j] = $root.Form.toObject(message.forms[j], options);
            }
            if (message.notes != undefined && message.hasOwnProperty("notes"))
                object.notes = message.notes;
            if (message.occurred != undefined && message.hasOwnProperty("occurred"))
                object.occurred = message.occurred;
            if (message.participants && message.participants.length) {
                object.participants = [];
                for (var j = 0; j < message.participants.length; ++j)
                    object.participants[j] = message.participants[j];
            }
            if (message.rsvpSessionSubID != undefined && message.hasOwnProperty("rsvpSessionSubID"))
                object.rsvpSessionSubID = message.rsvpSessionSubID;
            return object;
        };
    
        /**
         * Converts this Appointment to JSON.
         * @function toJSON
         * @memberof Appointment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Appointment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * RSVP statuses.
         * @name Appointment.RSVP
         * @enum {string}
         * @property {number} Maybe=0 Maybe value
         * @property {number} No=1 No value
         * @property {number} Yes=2 Yes value
         */
        Appointment.RSVP = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Maybe"] = 0;
            values[valuesById[1] = "No"] = 1;
            values[valuesById[2] = "Yes"] = 2;
            return values;
        })();
    
        Appointment.EHR = (function() {
    
            /**
             * Properties of a EHR.
             * @memberof Appointment
             * @interface IEHR
             * @property {string|undefined} [accountNumber] * An ID that can span several visits often related to the same issue -
             * * pregnancy, surgeries, research study, etc.
             * @property {string|undefined} [attendingProviderID] ID of the attending provider. This ID is required for Inpatient Visits.
             * @property {string|undefined} [attendingProviderIDType] ID type of the ID for the attending provider.
             * @property {string|undefined} [attendingProviderName] Full name of the attending provider.
             * @property {number|undefined} [balance] * Patient balance due for this visit. This field depends on whether or not the sending
             * * system has billing functionality, and whether they calculate this field.
             * @property {number|undefined} [duration] Duration of the visit in minutes.
             * @property {string|undefined} [location] Location of the visit.
             * @property {string|undefined} [locationType] * Type of location.
             * * Examples: Clinic, Department, Home, Nursing Unit, Provider's Office, Phone.
             * @property {string|undefined} [locationFacility] Facility. Example: Community Hospital.
             * @property {string|undefined} [patientClass] * Patient class is used in many EHRs to determine where to put the patient.
             * * Examples: Inpatient, Outpatient, Emergency. (Redox required for Visit).
             * @property {string|undefined} [reason] Reason for the visit.
             * @property {number|undefined} [visitDateTime] Datetime of visit or the arrival time of the admission. (ISO 8601)
             * @property {string|undefined} [visitNumber] Unique ID of a single visit.
             */
    
            /**
             * Constructs a new EHR.
             * @memberof Appointment
             * @classdesc * EHR data for the appointment.
             * * TODO: Reconcile with Redox types.
             * @implements IEHR
             * @constructor
             * @param {Appointment.IEHR=} [properties] Properties to set
             */
            function EHR(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * * An ID that can span several visits often related to the same issue -
             * * pregnancy, surgeries, research study, etc.
             * @member {string} accountNumber
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.accountNumber = "";
    
            /**
             * ID of the attending provider. This ID is required for Inpatient Visits.
             * @member {string} attendingProviderID
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.attendingProviderID = "";
    
            /**
             * ID type of the ID for the attending provider.
             * @member {string} attendingProviderIDType
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.attendingProviderIDType = "";
    
            /**
             * Full name of the attending provider.
             * @member {string} attendingProviderName
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.attendingProviderName = "";
    
            /**
             * * Patient balance due for this visit. This field depends on whether or not the sending
             * * system has billing functionality, and whether they calculate this field.
             * @member {number} balance
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.balance = 0;
    
            /**
             * Duration of the visit in minutes.
             * @member {number} duration
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.duration = 0;
    
            /**
             * Location of the visit.
             * @member {string} location
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.location = "";
    
            /**
             * * Type of location.
             * * Examples: Clinic, Department, Home, Nursing Unit, Provider's Office, Phone.
             * @member {string} locationType
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.locationType = "";
    
            /**
             * Facility. Example: Community Hospital.
             * @member {string} locationFacility
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.locationFacility = "";
    
            /**
             * * Patient class is used in many EHRs to determine where to put the patient.
             * * Examples: Inpatient, Outpatient, Emergency. (Redox required for Visit).
             * @member {string} patientClass
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.patientClass = "";
    
            /**
             * Reason for the visit.
             * @member {string} reason
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.reason = "";
    
            /**
             * Datetime of visit or the arrival time of the admission. (ISO 8601)
             * @member {number} visitDateTime
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.visitDateTime = 0;
    
            /**
             * Unique ID of a single visit.
             * @member {string} visitNumber
             * @memberof Appointment.EHR
             * @instance
             */
            EHR.prototype.visitNumber = "";
    
            /**
             * Creates a new EHR instance using the specified properties.
             * @function create
             * @memberof Appointment.EHR
             * @static
             * @param {Appointment.IEHR=} [properties] Properties to set
             * @returns {Appointment.EHR} EHR instance
             */
            EHR.create = function create(properties) {
                return new EHR(properties);
            };
    
            /**
             * Encodes the specified EHR message. Does not implicitly {@link Appointment.EHR.verify|verify} messages.
             * @function encode
             * @memberof Appointment.EHR
             * @static
             * @param {Appointment.IEHR} message EHR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EHR.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountNumber != undefined && message.hasOwnProperty("accountNumber"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountNumber);
                if (message.attendingProviderID != undefined && message.hasOwnProperty("attendingProviderID"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.attendingProviderID);
                if (message.attendingProviderIDType != undefined && message.hasOwnProperty("attendingProviderIDType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.attendingProviderIDType);
                if (message.attendingProviderName != undefined && message.hasOwnProperty("attendingProviderName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.attendingProviderName);
                if (message.balance != undefined && message.hasOwnProperty("balance"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.balance);
                if (message.duration != undefined && message.hasOwnProperty("duration"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.duration);
                if (message.location != undefined && message.hasOwnProperty("location"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.location);
                if (message.locationType != undefined && message.hasOwnProperty("locationType"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.locationType);
                if (message.locationFacility != undefined && message.hasOwnProperty("locationFacility"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.locationFacility);
                if (message.patientClass != undefined && message.hasOwnProperty("patientClass"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.patientClass);
                if (message.reason != undefined && message.hasOwnProperty("reason"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.reason);
                if (message.visitDateTime != undefined && message.hasOwnProperty("visitDateTime"))
                    writer.uint32(/* id 12, wireType 1 =*/97).double(message.visitDateTime);
                if (message.visitNumber != undefined && message.hasOwnProperty("visitNumber"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.visitNumber);
                return writer;
            };
    
            /**
             * Encodes the specified EHR message, length delimited. Does not implicitly {@link Appointment.EHR.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Appointment.EHR
             * @static
             * @param {Appointment.IEHR} message EHR message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EHR.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a EHR message from the specified reader or buffer.
             * @function decode
             * @memberof Appointment.EHR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Appointment.EHR} EHR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EHR.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Appointment.EHR();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountNumber = reader.string();
                        break;
                    case 2:
                        message.attendingProviderID = reader.string();
                        break;
                    case 3:
                        message.attendingProviderIDType = reader.string();
                        break;
                    case 4:
                        message.attendingProviderName = reader.string();
                        break;
                    case 5:
                        message.balance = reader.double();
                        break;
                    case 6:
                        message.duration = reader.double();
                        break;
                    case 7:
                        message.location = reader.string();
                        break;
                    case 8:
                        message.locationType = reader.string();
                        break;
                    case 9:
                        message.locationFacility = reader.string();
                        break;
                    case 10:
                        message.patientClass = reader.string();
                        break;
                    case 11:
                        message.reason = reader.string();
                        break;
                    case 12:
                        message.visitDateTime = reader.double();
                        break;
                    case 13:
                        message.visitNumber = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a EHR message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Appointment.EHR
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Appointment.EHR} EHR
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EHR.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a EHR message.
             * @function verify
             * @memberof Appointment.EHR
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            EHR.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.accountNumber != undefined && message.hasOwnProperty("accountNumber"))
                    if (!$util.isString(message.accountNumber))
                        return "accountNumber: string expected";
                if (message.attendingProviderID != undefined && message.hasOwnProperty("attendingProviderID"))
                    if (!$util.isString(message.attendingProviderID))
                        return "attendingProviderID: string expected";
                if (message.attendingProviderIDType != undefined && message.hasOwnProperty("attendingProviderIDType"))
                    if (!$util.isString(message.attendingProviderIDType))
                        return "attendingProviderIDType: string expected";
                if (message.attendingProviderName != undefined && message.hasOwnProperty("attendingProviderName"))
                    if (!$util.isString(message.attendingProviderName))
                        return "attendingProviderName: string expected";
                if (message.balance != undefined && message.hasOwnProperty("balance"))
                    if (typeof message.balance !== "number")
                        return "balance: number expected";
                if (message.duration != undefined && message.hasOwnProperty("duration"))
                    if (typeof message.duration !== "number")
                        return "duration: number expected";
                if (message.location != undefined && message.hasOwnProperty("location"))
                    if (!$util.isString(message.location))
                        return "location: string expected";
                if (message.locationType != undefined && message.hasOwnProperty("locationType"))
                    if (!$util.isString(message.locationType))
                        return "locationType: string expected";
                if (message.locationFacility != undefined && message.hasOwnProperty("locationFacility"))
                    if (!$util.isString(message.locationFacility))
                        return "locationFacility: string expected";
                if (message.patientClass != undefined && message.hasOwnProperty("patientClass"))
                    if (!$util.isString(message.patientClass))
                        return "patientClass: string expected";
                if (message.reason != undefined && message.hasOwnProperty("reason"))
                    if (!$util.isString(message.reason))
                        return "reason: string expected";
                if (message.visitDateTime != undefined && message.hasOwnProperty("visitDateTime"))
                    if (typeof message.visitDateTime !== "number")
                        return "visitDateTime: number expected";
                if (message.visitNumber != undefined && message.hasOwnProperty("visitNumber"))
                    if (!$util.isString(message.visitNumber))
                        return "visitNumber: string expected";
                return undefined;
            };
    
            /**
             * Creates a EHR message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Appointment.EHR
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Appointment.EHR} EHR
             */
            EHR.fromObject = function fromObject(object) {
                if (object instanceof $root.Appointment.EHR)
                    return object;
                var message = new $root.Appointment.EHR();
                if (object.accountNumber != undefined)
                    message.accountNumber = String(object.accountNumber);
                if (object.attendingProviderID != undefined)
                    message.attendingProviderID = String(object.attendingProviderID);
                if (object.attendingProviderIDType != undefined)
                    message.attendingProviderIDType = String(object.attendingProviderIDType);
                if (object.attendingProviderName != undefined)
                    message.attendingProviderName = String(object.attendingProviderName);
                if (object.balance != undefined)
                    message.balance = Number(object.balance);
                if (object.duration != undefined)
                    message.duration = Number(object.duration);
                if (object.location != undefined)
                    message.location = String(object.location);
                if (object.locationType != undefined)
                    message.locationType = String(object.locationType);
                if (object.locationFacility != undefined)
                    message.locationFacility = String(object.locationFacility);
                if (object.patientClass != undefined)
                    message.patientClass = String(object.patientClass);
                if (object.reason != undefined)
                    message.reason = String(object.reason);
                if (object.visitDateTime != undefined)
                    message.visitDateTime = Number(object.visitDateTime);
                if (object.visitNumber != undefined)
                    message.visitNumber = String(object.visitNumber);
                return message;
            };
    
            /**
             * Creates a plain object from a EHR message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Appointment.EHR
             * @static
             * @param {Appointment.EHR} message EHR
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EHR.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.accountNumber = "";
                    object.attendingProviderID = "";
                    object.attendingProviderIDType = "";
                    object.attendingProviderName = "";
                    object.balance = 0;
                    object.duration = 0;
                    object.location = "";
                    object.locationType = "";
                    object.locationFacility = "";
                    object.patientClass = "";
                    object.reason = "";
                    object.visitDateTime = 0;
                    object.visitNumber = "";
                }
                if (message.accountNumber != undefined && message.hasOwnProperty("accountNumber"))
                    object.accountNumber = message.accountNumber;
                if (message.attendingProviderID != undefined && message.hasOwnProperty("attendingProviderID"))
                    object.attendingProviderID = message.attendingProviderID;
                if (message.attendingProviderIDType != undefined && message.hasOwnProperty("attendingProviderIDType"))
                    object.attendingProviderIDType = message.attendingProviderIDType;
                if (message.attendingProviderName != undefined && message.hasOwnProperty("attendingProviderName"))
                    object.attendingProviderName = message.attendingProviderName;
                if (message.balance != undefined && message.hasOwnProperty("balance"))
                    object.balance = options.json && !isFinite(message.balance) ? String(message.balance) : message.balance;
                if (message.duration != undefined && message.hasOwnProperty("duration"))
                    object.duration = options.json && !isFinite(message.duration) ? String(message.duration) : message.duration;
                if (message.location != undefined && message.hasOwnProperty("location"))
                    object.location = message.location;
                if (message.locationType != undefined && message.hasOwnProperty("locationType"))
                    object.locationType = message.locationType;
                if (message.locationFacility != undefined && message.hasOwnProperty("locationFacility"))
                    object.locationFacility = message.locationFacility;
                if (message.patientClass != undefined && message.hasOwnProperty("patientClass"))
                    object.patientClass = message.patientClass;
                if (message.reason != undefined && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                if (message.visitDateTime != undefined && message.hasOwnProperty("visitDateTime"))
                    object.visitDateTime = options.json && !isFinite(message.visitDateTime) ? String(message.visitDateTime) : message.visitDateTime;
                if (message.visitNumber != undefined && message.hasOwnProperty("visitNumber"))
                    object.visitNumber = message.visitNumber;
                return object;
            };
    
            /**
             * Converts this EHR to JSON.
             * @function toJSON
             * @memberof Appointment.EHR
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EHR.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return EHR;
        })();
    
        return Appointment;
    })();
    
    $root.CalendarInvite = (function() {
    
        /**
         * Properties of a CalendarInvite.
         * @exports ICalendarInvite
         * @interface ICalendarInvite
         * @property {Object.<string,boolean>|undefined} [alternateDays] Preferred days for counteroffers.
         * @property {Object.<string,boolean>|undefined} [alternateTimeFrames] Preferred time frames days for counteroffers.
         * @property {CallTypes} callType @see CallTypes
         * @property {string} description Event description.
         * @property {number} endTime End timestamp.
         * @property {number} startTime Start timestamp.
         * @property {string} title Event title/subject.
         */
    
        /**
         * Constructs a new CalendarInvite.
         * @exports CalendarInvite
         * @classdesc Calendar invite.
         * @implements ICalendarInvite
         * @constructor
         * @param {ICalendarInvite=} [properties] Properties to set
         */
        function CalendarInvite(properties) {
            this.alternateDays = {};
            this.alternateTimeFrames = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Preferred days for counteroffers.
         * @member {Object.<string,boolean>} alternateDays
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.alternateDays = $util.emptyObject;
    
        /**
         * Preferred time frames days for counteroffers.
         * @member {Object.<string,boolean>} alternateTimeFrames
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.alternateTimeFrames = $util.emptyObject;
    
        /**
         * @see CallTypes
         * @member {CallTypes} callType
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.callType = 0;
    
        /**
         * Event description.
         * @member {string} description
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.description = "";
    
        /**
         * End timestamp.
         * @member {number} endTime
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.endTime = 0;
    
        /**
         * Start timestamp.
         * @member {number} startTime
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.startTime = 0;
    
        /**
         * Event title/subject.
         * @member {string} title
         * @memberof CalendarInvite
         * @instance
         */
        CalendarInvite.prototype.title = "";
    
        /**
         * Creates a new CalendarInvite instance using the specified properties.
         * @function create
         * @memberof CalendarInvite
         * @static
         * @param {ICalendarInvite=} [properties] Properties to set
         * @returns {CalendarInvite} CalendarInvite instance
         */
        CalendarInvite.create = function create(properties) {
            return new CalendarInvite(properties);
        };
    
        /**
         * Encodes the specified CalendarInvite message. Does not implicitly {@link CalendarInvite.verify|verify} messages.
         * @function encode
         * @memberof CalendarInvite
         * @static
         * @param {ICalendarInvite} message CalendarInvite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CalendarInvite.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.alternateDays != undefined && message.hasOwnProperty("alternateDays"))
                for (var keys = Object.keys(message.alternateDays), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.alternateDays[keys[i]]).ldelim();
            if (message.alternateTimeFrames != undefined && message.hasOwnProperty("alternateTimeFrames"))
                for (var keys = Object.keys(message.alternateTimeFrames), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.alternateTimeFrames[keys[i]]).ldelim();
            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.callType);
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
            writer.uint32(/* id 5, wireType 1 =*/41).double(message.endTime);
            writer.uint32(/* id 6, wireType 1 =*/49).double(message.startTime);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.title);
            return writer;
        };
    
        /**
         * Encodes the specified CalendarInvite message, length delimited. Does not implicitly {@link CalendarInvite.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CalendarInvite
         * @static
         * @param {ICalendarInvite} message CalendarInvite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CalendarInvite.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CalendarInvite message from the specified reader or buffer.
         * @function decode
         * @memberof CalendarInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CalendarInvite} CalendarInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CalendarInvite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CalendarInvite(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.alternateDays === $util.emptyObject)
                        message.alternateDays = {};
                    key = reader.uint32();
                    reader.pos++;
                    message.alternateDays[key] = reader.bool();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.alternateTimeFrames === $util.emptyObject)
                        message.alternateTimeFrames = {};
                    key = reader.uint32();
                    reader.pos++;
                    message.alternateTimeFrames[key] = reader.bool();
                    break;
                case 3:
                    message.callType = reader.int32();
                    break;
                case 4:
                    message.description = reader.string();
                    break;
                case 5:
                    message.endTime = reader.double();
                    break;
                case 6:
                    message.startTime = reader.double();
                    break;
                case 7:
                    message.title = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("callType"))
                throw $util.ProtocolError("missing required 'callType'", { instance: message });
            if (!message.hasOwnProperty("description"))
                throw $util.ProtocolError("missing required 'description'", { instance: message });
            if (!message.hasOwnProperty("endTime"))
                throw $util.ProtocolError("missing required 'endTime'", { instance: message });
            if (!message.hasOwnProperty("startTime"))
                throw $util.ProtocolError("missing required 'startTime'", { instance: message });
            if (!message.hasOwnProperty("title"))
                throw $util.ProtocolError("missing required 'title'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a CalendarInvite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CalendarInvite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CalendarInvite} CalendarInvite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CalendarInvite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CalendarInvite message.
         * @function verify
         * @memberof CalendarInvite
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        CalendarInvite.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.alternateDays != undefined && message.hasOwnProperty("alternateDays")) {
                if (!$util.isObject(message.alternateDays))
                    return "alternateDays: object expected";
                var key = Object.keys(message.alternateDays);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "alternateDays: integer key{k:uint32} expected";
                    if (typeof message.alternateDays[key[i]] !== "boolean")
                        return "alternateDays: boolean{k:uint32} expected";
                }
            }
            if (message.alternateTimeFrames != undefined && message.hasOwnProperty("alternateTimeFrames")) {
                if (!$util.isObject(message.alternateTimeFrames))
                    return "alternateTimeFrames: object expected";
                var key = Object.keys(message.alternateTimeFrames);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "alternateTimeFrames: integer key{k:uint32} expected";
                    if (typeof message.alternateTimeFrames[key[i]] !== "boolean")
                        return "alternateTimeFrames: boolean{k:uint32} expected";
                }
            }
            switch (message.callType) {
            default:
                return "callType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            if (!$util.isString(message.description))
                return "description: string expected";
            if (typeof message.endTime !== "number")
                return "endTime: number expected";
            if (typeof message.startTime !== "number")
                return "startTime: number expected";
            if (!$util.isString(message.title))
                return "title: string expected";
            return undefined;
        };
    
        /**
         * Creates a CalendarInvite message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CalendarInvite
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CalendarInvite} CalendarInvite
         */
        CalendarInvite.fromObject = function fromObject(object) {
            if (object instanceof $root.CalendarInvite)
                return object;
            var message = new $root.CalendarInvite();
            if (object.alternateDays) {
                if (typeof object.alternateDays !== "object")
                    throw TypeError(".CalendarInvite.alternateDays: object expected");
                message.alternateDays = {};
                for (var keys = Object.keys(object.alternateDays), i = 0; i < keys.length; ++i)
                    message.alternateDays[keys[i]] = Boolean(object.alternateDays[keys[i]]);
            }
            if (object.alternateTimeFrames) {
                if (typeof object.alternateTimeFrames !== "object")
                    throw TypeError(".CalendarInvite.alternateTimeFrames: object expected");
                message.alternateTimeFrames = {};
                for (var keys = Object.keys(object.alternateTimeFrames), i = 0; i < keys.length; ++i)
                    message.alternateTimeFrames[keys[i]] = Boolean(object.alternateTimeFrames[keys[i]]);
            }
            switch (object.callType) {
            case "None":
            case 0:
                message.callType = 0;
                break;
            case "Audio":
            case 1:
                message.callType = 1;
                break;
            case "Video":
            case 2:
                message.callType = 2;
                break;
            }
            if (object.description != undefined)
                message.description = String(object.description);
            if (object.endTime != undefined)
                message.endTime = Number(object.endTime);
            if (object.startTime != undefined)
                message.startTime = Number(object.startTime);
            if (object.title != undefined)
                message.title = String(object.title);
            return message;
        };
    
        /**
         * Creates a plain object from a CalendarInvite message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CalendarInvite
         * @static
         * @param {CalendarInvite} message CalendarInvite
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CalendarInvite.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults) {
                object.alternateDays = {};
                object.alternateTimeFrames = {};
            }
            if (options.defaults) {
                object.callType = options.enums === String ? "None" : 0;
                object.description = "";
                object.endTime = 0;
                object.startTime = 0;
                object.title = "";
            }
            var keys2;
            if (message.alternateDays && (keys2 = Object.keys(message.alternateDays)).length) {
                object.alternateDays = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.alternateDays[keys2[j]] = message.alternateDays[keys2[j]];
            }
            if (message.alternateTimeFrames && (keys2 = Object.keys(message.alternateTimeFrames)).length) {
                object.alternateTimeFrames = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.alternateTimeFrames[keys2[j]] = message.alternateTimeFrames[keys2[j]];
            }
            if (message.callType != undefined && message.hasOwnProperty("callType"))
                object.callType = options.enums === String ? $root.CallTypes[message.callType] : message.callType;
            if (message.description != undefined && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.endTime != undefined && message.hasOwnProperty("endTime"))
                object.endTime = options.json && !isFinite(message.endTime) ? String(message.endTime) : message.endTime;
            if (message.startTime != undefined && message.hasOwnProperty("startTime"))
                object.startTime = options.json && !isFinite(message.startTime) ? String(message.startTime) : message.startTime;
            if (message.title != undefined && message.hasOwnProperty("title"))
                object.title = message.title;
            return object;
        };
    
        /**
         * Converts this CalendarInvite to JSON.
         * @function toJSON
         * @memberof CalendarInvite
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CalendarInvite.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Days of the week for appointments.
         * @name CalendarInvite.DaysOfWeek
         * @enum {string}
         * @property {number} Sunday=0 Sunday value
         * @property {number} Monday=1 Monday value
         * @property {number} Tuesday=2 Tuesday value
         * @property {number} Wednesday=3 Wednesday value
         * @property {number} Thursday=4 Thursday value
         * @property {number} Friday=5 Friday value
         * @property {number} Saturday=6 Saturday value
         */
        CalendarInvite.DaysOfWeek = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Sunday"] = 0;
            values[valuesById[1] = "Monday"] = 1;
            values[valuesById[2] = "Tuesday"] = 2;
            values[valuesById[3] = "Wednesday"] = 3;
            values[valuesById[4] = "Thursday"] = 4;
            values[valuesById[5] = "Friday"] = 5;
            values[valuesById[6] = "Saturday"] = 6;
            return values;
        })();
    
        /**
         * Time periods of the day for appointments.
         * @name CalendarInvite.TimeFrames
         * @enum {string}
         * @property {number} Morning=0 Morning value
         * @property {number} Afternoon=1 Afternoon value
         * @property {number} Evening=2 Evening value
         */
        CalendarInvite.TimeFrames = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Morning"] = 0;
            values[valuesById[1] = "Afternoon"] = 1;
            values[valuesById[2] = "Evening"] = 2;
            return values;
        })();
    
        return CalendarInvite;
    })();
    
    /**
     * Call types.
     * @exports CallTypes
     * @enum {string}
     * @property {number} None=0 None value
     * @property {number} Audio=1 Audio value
     * @property {number} Video=2 Video value
     */
    $root.CallTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "None"] = 0;
        values[valuesById[1] = "Audio"] = 1;
        values[valuesById[2] = "Video"] = 2;
        return values;
    })();
    
    $root.CastleIncomingMessages = (function() {
    
        /**
         * Properties of a CastleIncomingMessages.
         * @exports ICastleIncomingMessages
         * @interface ICastleIncomingMessages
         * @property {Object.<string,CastleIncomingMessages.ICastleIncomingMessageItem>|undefined} [incomingMessages] Mapping of message IDs to CastleIncomingMessageItems.
         */
    
        /**
         * Constructs a new CastleIncomingMessages.
         * @exports CastleIncomingMessages
         * @classdesc Castle incoming messages.
         * @implements ICastleIncomingMessages
         * @constructor
         * @param {ICastleIncomingMessages=} [properties] Properties to set
         */
        function CastleIncomingMessages(properties) {
            this.incomingMessages = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Mapping of message IDs to CastleIncomingMessageItems.
         * @member {Object.<string,CastleIncomingMessages.ICastleIncomingMessageItem>} incomingMessages
         * @memberof CastleIncomingMessages
         * @instance
         */
        CastleIncomingMessages.prototype.incomingMessages = $util.emptyObject;
    
        /**
         * Creates a new CastleIncomingMessages instance using the specified properties.
         * @function create
         * @memberof CastleIncomingMessages
         * @static
         * @param {ICastleIncomingMessages=} [properties] Properties to set
         * @returns {CastleIncomingMessages} CastleIncomingMessages instance
         */
        CastleIncomingMessages.create = function create(properties) {
            return new CastleIncomingMessages(properties);
        };
    
        /**
         * Encodes the specified CastleIncomingMessages message. Does not implicitly {@link CastleIncomingMessages.verify|verify} messages.
         * @function encode
         * @memberof CastleIncomingMessages
         * @static
         * @param {ICastleIncomingMessages} message CastleIncomingMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CastleIncomingMessages.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incomingMessages != undefined && message.hasOwnProperty("incomingMessages"))
                for (var keys = Object.keys(message.incomingMessages), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint32(keys[i]);
                    $root.CastleIncomingMessages.CastleIncomingMessageItem.encode(message.incomingMessages[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            return writer;
        };
    
        /**
         * Encodes the specified CastleIncomingMessages message, length delimited. Does not implicitly {@link CastleIncomingMessages.verify|verify} messages.
         * @function encodeDelimited
         * @memberof CastleIncomingMessages
         * @static
         * @param {ICastleIncomingMessages} message CastleIncomingMessages message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CastleIncomingMessages.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a CastleIncomingMessages message from the specified reader or buffer.
         * @function decode
         * @memberof CastleIncomingMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CastleIncomingMessages} CastleIncomingMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CastleIncomingMessages.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CastleIncomingMessages(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.incomingMessages === $util.emptyObject)
                        message.incomingMessages = {};
                    key = reader.uint32();
                    reader.pos++;
                    message.incomingMessages[key] = $root.CastleIncomingMessages.CastleIncomingMessageItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a CastleIncomingMessages message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof CastleIncomingMessages
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {CastleIncomingMessages} CastleIncomingMessages
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CastleIncomingMessages.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a CastleIncomingMessages message.
         * @function verify
         * @memberof CastleIncomingMessages
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        CastleIncomingMessages.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.incomingMessages != undefined && message.hasOwnProperty("incomingMessages")) {
                if (!$util.isObject(message.incomingMessages))
                    return "incomingMessages: object expected";
                var key = Object.keys(message.incomingMessages);
                for (var i = 0; i < key.length; ++i) {
                    if (!$util.key32Re.test(key[i]))
                        return "incomingMessages: integer key{k:uint32} expected";
                    {
                        var error = $root.CastleIncomingMessages.CastleIncomingMessageItem.verify(message.incomingMessages[key[i]]);
                        if (error)
                            return "incomingMessages." + error;
                    }
                }
            }
            return undefined;
        };
    
        /**
         * Creates a CastleIncomingMessages message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof CastleIncomingMessages
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {CastleIncomingMessages} CastleIncomingMessages
         */
        CastleIncomingMessages.fromObject = function fromObject(object) {
            if (object instanceof $root.CastleIncomingMessages)
                return object;
            var message = new $root.CastleIncomingMessages();
            if (object.incomingMessages) {
                if (typeof object.incomingMessages !== "object")
                    throw TypeError(".CastleIncomingMessages.incomingMessages: object expected");
                message.incomingMessages = {};
                for (var keys = Object.keys(object.incomingMessages), i = 0; i < keys.length; ++i) {
                    if (typeof object.incomingMessages[keys[i]] !== "object")
                        throw TypeError(".CastleIncomingMessages.incomingMessages: object expected");
                    message.incomingMessages[keys[i]] = $root.CastleIncomingMessages.CastleIncomingMessageItem.fromObject(object.incomingMessages[keys[i]]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a CastleIncomingMessages message. Also converts values to other types if specified.
         * @function toObject
         * @memberof CastleIncomingMessages
         * @static
         * @param {CastleIncomingMessages} message CastleIncomingMessages
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CastleIncomingMessages.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.incomingMessages = {};
            var keys2;
            if (message.incomingMessages && (keys2 = Object.keys(message.incomingMessages)).length) {
                object.incomingMessages = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.incomingMessages[keys2[j]] = $root.CastleIncomingMessages.CastleIncomingMessageItem.toObject(message.incomingMessages[keys2[j]], options);
            }
            return object;
        };
    
        /**
         * Converts this CastleIncomingMessages to JSON.
         * @function toJSON
         * @memberof CastleIncomingMessages
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CastleIncomingMessages.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        CastleIncomingMessages.CastleIncomingMessageItem = (function() {
    
            /**
             * Properties of a CastleIncomingMessageItem.
             * @memberof CastleIncomingMessages
             * @interface ICastleIncomingMessageItem
             * @property {Array.<Uint8Array>|undefined} [cyphertexts] @see CastleIncomingMessageItem
             */
    
            /**
             * Constructs a new CastleIncomingMessageItem.
             * @memberof CastleIncomingMessages
             * @classdesc List of received cyphertexts with a particular message ID.
             * @implements ICastleIncomingMessageItem
             * @constructor
             * @param {CastleIncomingMessages.ICastleIncomingMessageItem=} [properties] Properties to set
             */
            function CastleIncomingMessageItem(properties) {
                this.cyphertexts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see CastleIncomingMessageItem
             * @member {Array.<Uint8Array>} cyphertexts
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @instance
             */
            CastleIncomingMessageItem.prototype.cyphertexts = $util.emptyArray;
    
            /**
             * Creates a new CastleIncomingMessageItem instance using the specified properties.
             * @function create
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {CastleIncomingMessages.ICastleIncomingMessageItem=} [properties] Properties to set
             * @returns {CastleIncomingMessages.CastleIncomingMessageItem} CastleIncomingMessageItem instance
             */
            CastleIncomingMessageItem.create = function create(properties) {
                return new CastleIncomingMessageItem(properties);
            };
    
            /**
             * Encodes the specified CastleIncomingMessageItem message. Does not implicitly {@link CastleIncomingMessages.CastleIncomingMessageItem.verify|verify} messages.
             * @function encode
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {CastleIncomingMessages.ICastleIncomingMessageItem} message CastleIncomingMessageItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CastleIncomingMessageItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cyphertexts != undefined && message.cyphertexts.length)
                    for (var i = 0; i < message.cyphertexts.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cyphertexts[i]);
                return writer;
            };
    
            /**
             * Encodes the specified CastleIncomingMessageItem message, length delimited. Does not implicitly {@link CastleIncomingMessages.CastleIncomingMessageItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {CastleIncomingMessages.ICastleIncomingMessageItem} message CastleIncomingMessageItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CastleIncomingMessageItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CastleIncomingMessageItem message from the specified reader or buffer.
             * @function decode
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {CastleIncomingMessages.CastleIncomingMessageItem} CastleIncomingMessageItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CastleIncomingMessageItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CastleIncomingMessages.CastleIncomingMessageItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.cyphertexts && message.cyphertexts.length))
                            message.cyphertexts = [];
                        message.cyphertexts.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CastleIncomingMessageItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {CastleIncomingMessages.CastleIncomingMessageItem} CastleIncomingMessageItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CastleIncomingMessageItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CastleIncomingMessageItem message.
             * @function verify
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            CastleIncomingMessageItem.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.cyphertexts != undefined && message.hasOwnProperty("cyphertexts")) {
                    if (!Array.isArray(message.cyphertexts))
                        return "cyphertexts: array expected";
                    for (var i = 0; i < message.cyphertexts.length; ++i)
                        if (!(message.cyphertexts[i] && typeof message.cyphertexts[i].length === "number" || $util.isString(message.cyphertexts[i])))
                            return "cyphertexts: buffer[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a CastleIncomingMessageItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {CastleIncomingMessages.CastleIncomingMessageItem} CastleIncomingMessageItem
             */
            CastleIncomingMessageItem.fromObject = function fromObject(object) {
                if (object instanceof $root.CastleIncomingMessages.CastleIncomingMessageItem)
                    return object;
                var message = new $root.CastleIncomingMessages.CastleIncomingMessageItem();
                if (object.cyphertexts) {
                    if (!Array.isArray(object.cyphertexts))
                        throw TypeError(".CastleIncomingMessages.CastleIncomingMessageItem.cyphertexts: array expected");
                    message.cyphertexts = [];
                    for (var i = 0; i < object.cyphertexts.length; ++i)
                        if (typeof object.cyphertexts[i] === "string")
                            $util.base64.decode(object.cyphertexts[i], message.cyphertexts[i] = $util.newBuffer($util.base64.length(object.cyphertexts[i])), 0);
                        else if (object.cyphertexts[i].length)
                            message.cyphertexts[i] = object.cyphertexts[i];
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CastleIncomingMessageItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @static
             * @param {CastleIncomingMessages.CastleIncomingMessageItem} message CastleIncomingMessageItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CastleIncomingMessageItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.cyphertexts = [];
                if (message.cyphertexts && message.cyphertexts.length) {
                    object.cyphertexts = [];
                    for (var j = 0; j < message.cyphertexts.length; ++j)
                        object.cyphertexts[j] = options.bytes === String ? $util.base64.encode(message.cyphertexts[j], 0, message.cyphertexts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.cyphertexts[j]) : message.cyphertexts[j];
                }
                return object;
            };
    
            /**
             * Converts this CastleIncomingMessageItem to JSON.
             * @function toJSON
             * @memberof CastleIncomingMessages.CastleIncomingMessageItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CastleIncomingMessageItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CastleIncomingMessageItem;
        })();
    
        return CastleIncomingMessages;
    })();
    
    $root.ChannelMessage = (function() {
    
        /**
         * Properties of a ChannelMessage.
         * @exports IChannelMessage
         * @interface IChannelMessage
         * @property {Uint8Array} cyphertext Cyphertext.
         * @property {string} author User who sent the message.
         */
    
        /**
         * Constructs a new ChannelMessage.
         * @exports ChannelMessage
         * @classdesc ChannelService message.
         * @implements IChannelMessage
         * @constructor
         * @param {IChannelMessage=} [properties] Properties to set
         */
        function ChannelMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Cyphertext.
         * @member {Uint8Array} cyphertext
         * @memberof ChannelMessage
         * @instance
         */
        ChannelMessage.prototype.cyphertext = $util.newBuffer([]);
    
        /**
         * User who sent the message.
         * @member {string} author
         * @memberof ChannelMessage
         * @instance
         */
        ChannelMessage.prototype.author = "";
    
        /**
         * Creates a new ChannelMessage instance using the specified properties.
         * @function create
         * @memberof ChannelMessage
         * @static
         * @param {IChannelMessage=} [properties] Properties to set
         * @returns {ChannelMessage} ChannelMessage instance
         */
        ChannelMessage.create = function create(properties) {
            return new ChannelMessage(properties);
        };
    
        /**
         * Encodes the specified ChannelMessage message. Does not implicitly {@link ChannelMessage.verify|verify} messages.
         * @function encode
         * @memberof ChannelMessage
         * @static
         * @param {IChannelMessage} message ChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.cyphertext);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.author);
            return writer;
        };
    
        /**
         * Encodes the specified ChannelMessage message, length delimited. Does not implicitly {@link ChannelMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChannelMessage
         * @static
         * @param {IChannelMessage} message ChannelMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ChannelMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChannelMessage} ChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChannelMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cyphertext = reader.bytes();
                    break;
                case 2:
                    message.author = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("cyphertext"))
                throw $util.ProtocolError("missing required 'cyphertext'", { instance: message });
            if (!message.hasOwnProperty("author"))
                throw $util.ProtocolError("missing required 'author'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ChannelMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChannelMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChannelMessage} ChannelMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ChannelMessage message.
         * @function verify
         * @memberof ChannelMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        ChannelMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!(message.cyphertext && typeof message.cyphertext.length === "number" || $util.isString(message.cyphertext)))
                return "cyphertext: buffer expected";
            if (!$util.isString(message.author))
                return "author: string expected";
            return undefined;
        };
    
        /**
         * Creates a ChannelMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChannelMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChannelMessage} ChannelMessage
         */
        ChannelMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ChannelMessage)
                return object;
            var message = new $root.ChannelMessage();
            if (object.cyphertext != undefined)
                if (typeof object.cyphertext === "string")
                    $util.base64.decode(object.cyphertext, message.cyphertext = $util.newBuffer($util.base64.length(object.cyphertext)), 0);
                else if (object.cyphertext.length)
                    message.cyphertext = object.cyphertext;
            if (object.author != undefined)
                message.author = String(object.author);
            return message;
        };
    
        /**
         * Creates a plain object from a ChannelMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChannelMessage
         * @static
         * @param {ChannelMessage} message ChannelMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cyphertext = options.bytes === String ? "" : [];
                object.author = "";
            }
            if (message.cyphertext != undefined && message.hasOwnProperty("cyphertext"))
                object.cyphertext = options.bytes === String ? $util.base64.encode(message.cyphertext, 0, message.cyphertext.length) : options.bytes === Array ? Array.prototype.slice.call(message.cyphertext) : message.cyphertext;
            if (message.author != undefined && message.hasOwnProperty("author"))
                object.author = message.author;
            return object;
        };
    
        /**
         * Converts this ChannelMessage to JSON.
         * @function toJSON
         * @memberof ChannelMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ChannelMessage;
    })();
    
    $root.ChatLastConfirmedMessage = (function() {
    
        /**
         * Properties of a ChatLastConfirmedMessage.
         * @exports IChatLastConfirmedMessage
         * @interface IChatLastConfirmedMessage
         * @property {string} id Message ID.
         * @property {number} index Message index.
         */
    
        /**
         * Constructs a new ChatLastConfirmedMessage.
         * @exports ChatLastConfirmedMessage
         * @classdesc Chat last confirmed message.
         * @implements IChatLastConfirmedMessage
         * @constructor
         * @param {IChatLastConfirmedMessage=} [properties] Properties to set
         */
        function ChatLastConfirmedMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Message ID.
         * @member {string} id
         * @memberof ChatLastConfirmedMessage
         * @instance
         */
        ChatLastConfirmedMessage.prototype.id = "";
    
        /**
         * Message index.
         * @member {number} index
         * @memberof ChatLastConfirmedMessage
         * @instance
         */
        ChatLastConfirmedMessage.prototype.index = 0;
    
        /**
         * Creates a new ChatLastConfirmedMessage instance using the specified properties.
         * @function create
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {IChatLastConfirmedMessage=} [properties] Properties to set
         * @returns {ChatLastConfirmedMessage} ChatLastConfirmedMessage instance
         */
        ChatLastConfirmedMessage.create = function create(properties) {
            return new ChatLastConfirmedMessage(properties);
        };
    
        /**
         * Encodes the specified ChatLastConfirmedMessage message. Does not implicitly {@link ChatLastConfirmedMessage.verify|verify} messages.
         * @function encode
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {IChatLastConfirmedMessage} message ChatLastConfirmedMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatLastConfirmedMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);
            return writer;
        };
    
        /**
         * Encodes the specified ChatLastConfirmedMessage message, length delimited. Does not implicitly {@link ChatLastConfirmedMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {IChatLastConfirmedMessage} message ChatLastConfirmedMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatLastConfirmedMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ChatLastConfirmedMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatLastConfirmedMessage} ChatLastConfirmedMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatLastConfirmedMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatLastConfirmedMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.index = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("index"))
                throw $util.ProtocolError("missing required 'index'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ChatLastConfirmedMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatLastConfirmedMessage} ChatLastConfirmedMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatLastConfirmedMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ChatLastConfirmedMessage message.
         * @function verify
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        ChatLastConfirmedMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (!$util.isInteger(message.index))
                return "index: integer expected";
            return undefined;
        };
    
        /**
         * Creates a ChatLastConfirmedMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatLastConfirmedMessage} ChatLastConfirmedMessage
         */
        ChatLastConfirmedMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatLastConfirmedMessage)
                return object;
            var message = new $root.ChatLastConfirmedMessage();
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.index != undefined)
                message.index = object.index >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ChatLastConfirmedMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatLastConfirmedMessage
         * @static
         * @param {ChatLastConfirmedMessage} message ChatLastConfirmedMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatLastConfirmedMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.index = 0;
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.index != undefined && message.hasOwnProperty("index"))
                object.index = message.index;
            return object;
        };
    
        /**
         * Converts this ChatLastConfirmedMessage to JSON.
         * @function toJSON
         * @memberof ChatLastConfirmedMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatLastConfirmedMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ChatLastConfirmedMessage;
    })();
    
    $root.ChatMessage = (function() {
    
        /**
         * Properties of a ChatMessage.
         * @exports IChatMessage
         * @interface IChatMessage
         * @property {string|undefined} [authorID] Author user ID.
         * @property {ChatMessage.AuthorTypes} authorType @see AuthorTypes
         * @property {Array.<IChatMessageLine>|undefined} [dimensions] Metadata used to estimate message's size for virtual scrolling.
         * @property {string} id @see SessionMessageData.id
         * @property {number|undefined} [selfDestructTimeout] @see SessionText.selfDestructTimeout
         * @property {string|undefined} [sessionSubID] @see SessionMessageData.sessionSubID
         * @property {number} timestamp @see SessionMessageData.timestamp
         * @property {IChatMessageValue|undefined} [value] @see ChatMessageValue
         */
    
        /**
         * Constructs a new ChatMessage.
         * @exports ChatMessage
         * @classdesc Represents one message in a chat.
         * @implements IChatMessage
         * @constructor
         * @param {IChatMessage=} [properties] Properties to set
         */
        function ChatMessage(properties) {
            this.dimensions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Author user ID.
         * @member {string} authorID
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.authorID = "";
    
        /**
         * @see AuthorTypes
         * @member {ChatMessage.AuthorTypes} authorType
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.authorType = 0;
    
        /**
         * Metadata used to estimate message's size for virtual scrolling.
         * @member {Array.<IChatMessageLine>} dimensions
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.dimensions = $util.emptyArray;
    
        /**
         * @see SessionMessageData.id
         * @member {string} id
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.id = "";
    
        /**
         * @see SessionText.selfDestructTimeout
         * @member {number} selfDestructTimeout
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.selfDestructTimeout = 0;
    
        /**
         * @see SessionMessageData.sessionSubID
         * @member {string} sessionSubID
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.sessionSubID = "";
    
        /**
         * @see SessionMessageData.timestamp
         * @member {number} timestamp
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.timestamp = 0;
    
        /**
         * @see ChatMessageValue
         * @member {IChatMessageValue|undefined|undefined} value
         * @memberof ChatMessage
         * @instance
         */
        ChatMessage.prototype.value = undefined;
    
        /**
         * Creates a new ChatMessage instance using the specified properties.
         * @function create
         * @memberof ChatMessage
         * @static
         * @param {IChatMessage=} [properties] Properties to set
         * @returns {ChatMessage} ChatMessage instance
         */
        ChatMessage.create = function create(properties) {
            return new ChatMessage(properties);
        };
    
        /**
         * Encodes the specified ChatMessage message. Does not implicitly {@link ChatMessage.verify|verify} messages.
         * @function encode
         * @memberof ChatMessage
         * @static
         * @param {IChatMessage} message ChatMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorID);
            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.authorType);
            if (message.dimensions != undefined && message.dimensions.length)
                for (var i = 0; i < message.dimensions.length; ++i)
                    $root.ChatMessageLine.encode(message.dimensions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.selfDestructTimeout);
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.sessionSubID);
            writer.uint32(/* id 7, wireType 1 =*/57).double(message.timestamp);
            if (message.value != undefined && message.hasOwnProperty("value"))
                $root.ChatMessageValue.encode(message.value, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified ChatMessage message, length delimited. Does not implicitly {@link ChatMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatMessage
         * @static
         * @param {IChatMessage} message ChatMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ChatMessage message from the specified reader or buffer.
         * @function decode
         * @memberof ChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatMessage} ChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authorID = reader.string();
                    break;
                case 2:
                    message.authorType = reader.int32();
                    break;
                case 3:
                    if (!(message.dimensions && message.dimensions.length))
                        message.dimensions = [];
                    message.dimensions.push($root.ChatMessageLine.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.id = reader.string();
                    break;
                case 5:
                    message.selfDestructTimeout = reader.uint32();
                    break;
                case 6:
                    message.sessionSubID = reader.string();
                    break;
                case 7:
                    message.timestamp = reader.double();
                    break;
                case 8:
                    message.value = $root.ChatMessageValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("authorType"))
                throw $util.ProtocolError("missing required 'authorType'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ChatMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatMessage} ChatMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ChatMessage message.
         * @function verify
         * @memberof ChatMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        ChatMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                if (!$util.isString(message.authorID))
                    return "authorID: string expected";
            switch (message.authorType) {
            default:
                return "authorType: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            if (message.dimensions != undefined && message.hasOwnProperty("dimensions")) {
                if (!Array.isArray(message.dimensions))
                    return "dimensions: array expected";
                for (var i = 0; i < message.dimensions.length; ++i) {
                    var error = $root.ChatMessageLine.verify(message.dimensions[i]);
                    if (error)
                        return "dimensions." + error;
                }
            }
            if (!$util.isString(message.id))
                return "id: string expected";
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                if (!$util.isInteger(message.selfDestructTimeout))
                    return "selfDestructTimeout: integer expected";
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                if (!$util.isString(message.sessionSubID))
                    return "sessionSubID: string expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (message.value != undefined && message.hasOwnProperty("value")) {
                var error = $root.ChatMessageValue.verify(message.value);
                if (error)
                    return "value." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a ChatMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatMessage} ChatMessage
         */
        ChatMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatMessage)
                return object;
            var message = new $root.ChatMessage();
            if (object.authorID != undefined)
                message.authorID = String(object.authorID);
            switch (object.authorType) {
            case "App":
            case 0:
                message.authorType = 0;
                break;
            case "Local":
            case 1:
                message.authorType = 1;
                break;
            case "Remote":
            case 2:
                message.authorType = 2;
                break;
            }
            if (object.dimensions) {
                if (!Array.isArray(object.dimensions))
                    throw TypeError(".ChatMessage.dimensions: array expected");
                message.dimensions = [];
                for (var i = 0; i < object.dimensions.length; ++i) {
                    if (typeof object.dimensions[i] !== "object")
                        throw TypeError(".ChatMessage.dimensions: object expected");
                    message.dimensions[i] = $root.ChatMessageLine.fromObject(object.dimensions[i]);
                }
            }
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.selfDestructTimeout != undefined)
                message.selfDestructTimeout = object.selfDestructTimeout >>> 0;
            if (object.sessionSubID != undefined)
                message.sessionSubID = String(object.sessionSubID);
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            if (object.value != undefined) {
                if (typeof object.value !== "object")
                    throw TypeError(".ChatMessage.value: object expected");
                message.value = $root.ChatMessageValue.fromObject(object.value);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a ChatMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatMessage
         * @static
         * @param {ChatMessage} message ChatMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dimensions = [];
            if (options.defaults) {
                object.authorID = "";
                object.authorType = options.enums === String ? "App" : 0;
                object.id = "";
                object.selfDestructTimeout = 0;
                object.sessionSubID = "";
                object.timestamp = 0;
                object.value = undefined;
            }
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                object.authorID = message.authorID;
            if (message.authorType != undefined && message.hasOwnProperty("authorType"))
                object.authorType = options.enums === String ? $root.ChatMessage.AuthorTypes[message.authorType] : message.authorType;
            if (message.dimensions && message.dimensions.length) {
                object.dimensions = [];
                for (var j = 0; j < message.dimensions.length; ++j)
                    object.dimensions[j] = $root.ChatMessageLine.toObject(message.dimensions[j], options);
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                object.selfDestructTimeout = message.selfDestructTimeout;
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                object.sessionSubID = message.sessionSubID;
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.value != undefined && message.hasOwnProperty("value"))
                object.value = $root.ChatMessageValue.toObject(message.value, options);
            return object;
        };
    
        /**
         * Converts this ChatMessage to JSON.
         * @function toJSON
         * @memberof ChatMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Author types.
         * @name ChatMessage.AuthorTypes
         * @enum {string}
         * @property {number} App=0 App value
         * @property {number} Local=1 Local value
         * @property {number} Remote=2 Remote value
         */
        ChatMessage.AuthorTypes = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "App"] = 0;
            values[valuesById[1] = "Local"] = 1;
            values[valuesById[2] = "Remote"] = 2;
            return values;
        })();
    
        return ChatMessage;
    })();
    
    $root.ChatMessageLine = (function() {
    
        /**
         * Properties of a ChatMessageLine.
         * @exports IChatMessageLine
         * @interface IChatMessageLine
         * @property {number} bigScreenHeight Line height on a big screen.
         * @property {number} bigScreenWidth Line width on a big screen.
         * @property {number} smallScreenHeight Line height on a small screen.
         * @property {number} smallScreenWidth Line width on a small screen.
         */
    
        /**
         * Constructs a new ChatMessageLine.
         * @exports ChatMessageLine
         * @classdesc Dimensions for one message line.
         * @implements IChatMessageLine
         * @constructor
         * @param {IChatMessageLine=} [properties] Properties to set
         */
        function ChatMessageLine(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Line height on a big screen.
         * @member {number} bigScreenHeight
         * @memberof ChatMessageLine
         * @instance
         */
        ChatMessageLine.prototype.bigScreenHeight = 0;
    
        /**
         * Line width on a big screen.
         * @member {number} bigScreenWidth
         * @memberof ChatMessageLine
         * @instance
         */
        ChatMessageLine.prototype.bigScreenWidth = 0;
    
        /**
         * Line height on a small screen.
         * @member {number} smallScreenHeight
         * @memberof ChatMessageLine
         * @instance
         */
        ChatMessageLine.prototype.smallScreenHeight = 0;
    
        /**
         * Line width on a small screen.
         * @member {number} smallScreenWidth
         * @memberof ChatMessageLine
         * @instance
         */
        ChatMessageLine.prototype.smallScreenWidth = 0;
    
        /**
         * Creates a new ChatMessageLine instance using the specified properties.
         * @function create
         * @memberof ChatMessageLine
         * @static
         * @param {IChatMessageLine=} [properties] Properties to set
         * @returns {ChatMessageLine} ChatMessageLine instance
         */
        ChatMessageLine.create = function create(properties) {
            return new ChatMessageLine(properties);
        };
    
        /**
         * Encodes the specified ChatMessageLine message. Does not implicitly {@link ChatMessageLine.verify|verify} messages.
         * @function encode
         * @memberof ChatMessageLine
         * @static
         * @param {IChatMessageLine} message ChatMessageLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessageLine.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.bigScreenHeight);
            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.bigScreenWidth);
            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.smallScreenHeight);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.smallScreenWidth);
            return writer;
        };
    
        /**
         * Encodes the specified ChatMessageLine message, length delimited. Does not implicitly {@link ChatMessageLine.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatMessageLine
         * @static
         * @param {IChatMessageLine} message ChatMessageLine message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessageLine.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ChatMessageLine message from the specified reader or buffer.
         * @function decode
         * @memberof ChatMessageLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatMessageLine} ChatMessageLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessageLine.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessageLine();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.bigScreenHeight = reader.uint32();
                    break;
                case 2:
                    message.bigScreenWidth = reader.uint32();
                    break;
                case 3:
                    message.smallScreenHeight = reader.uint32();
                    break;
                case 4:
                    message.smallScreenWidth = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("bigScreenHeight"))
                throw $util.ProtocolError("missing required 'bigScreenHeight'", { instance: message });
            if (!message.hasOwnProperty("bigScreenWidth"))
                throw $util.ProtocolError("missing required 'bigScreenWidth'", { instance: message });
            if (!message.hasOwnProperty("smallScreenHeight"))
                throw $util.ProtocolError("missing required 'smallScreenHeight'", { instance: message });
            if (!message.hasOwnProperty("smallScreenWidth"))
                throw $util.ProtocolError("missing required 'smallScreenWidth'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a ChatMessageLine message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatMessageLine
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatMessageLine} ChatMessageLine
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessageLine.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ChatMessageLine message.
         * @function verify
         * @memberof ChatMessageLine
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        ChatMessageLine.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isInteger(message.bigScreenHeight))
                return "bigScreenHeight: integer expected";
            if (!$util.isInteger(message.bigScreenWidth))
                return "bigScreenWidth: integer expected";
            if (!$util.isInteger(message.smallScreenHeight))
                return "smallScreenHeight: integer expected";
            if (!$util.isInteger(message.smallScreenWidth))
                return "smallScreenWidth: integer expected";
            return undefined;
        };
    
        /**
         * Creates a ChatMessageLine message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatMessageLine
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatMessageLine} ChatMessageLine
         */
        ChatMessageLine.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatMessageLine)
                return object;
            var message = new $root.ChatMessageLine();
            if (object.bigScreenHeight != undefined)
                message.bigScreenHeight = object.bigScreenHeight >>> 0;
            if (object.bigScreenWidth != undefined)
                message.bigScreenWidth = object.bigScreenWidth >>> 0;
            if (object.smallScreenHeight != undefined)
                message.smallScreenHeight = object.smallScreenHeight >>> 0;
            if (object.smallScreenWidth != undefined)
                message.smallScreenWidth = object.smallScreenWidth >>> 0;
            return message;
        };
    
        /**
         * Creates a plain object from a ChatMessageLine message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatMessageLine
         * @static
         * @param {ChatMessageLine} message ChatMessageLine
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatMessageLine.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.bigScreenHeight = 0;
                object.bigScreenWidth = 0;
                object.smallScreenHeight = 0;
                object.smallScreenWidth = 0;
            }
            if (message.bigScreenHeight != undefined && message.hasOwnProperty("bigScreenHeight"))
                object.bigScreenHeight = message.bigScreenHeight;
            if (message.bigScreenWidth != undefined && message.hasOwnProperty("bigScreenWidth"))
                object.bigScreenWidth = message.bigScreenWidth;
            if (message.smallScreenHeight != undefined && message.hasOwnProperty("smallScreenHeight"))
                object.smallScreenHeight = message.smallScreenHeight;
            if (message.smallScreenWidth != undefined && message.hasOwnProperty("smallScreenWidth"))
                object.smallScreenWidth = message.smallScreenWidth;
            return object;
        };
    
        /**
         * Converts this ChatMessageLine to JSON.
         * @function toJSON
         * @memberof ChatMessageLine
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatMessageLine.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return ChatMessageLine;
    })();
    
    $root.ChatMessageValue = (function() {
    
        /**
         * Properties of a ChatMessageValue.
         * @exports IChatMessageValue
         * @interface IChatMessageValue
         * @property {ICalendarInvite|undefined} [calendarInvite] ChatMessageValue calendarInvite
         * @property {IForm|undefined} [form] ChatMessageValue form
         * @property {Uint8Array|undefined} [quill] ChatMessageValue quill
         * @property {Appointment.RSVP|undefined} [rsvp] ChatMessageValue rsvp
         * @property {string|undefined} [text] ChatMessageValue text
         */
    
        /**
         * Constructs a new ChatMessageValue.
         * @exports ChatMessageValue
         * @classdesc Possible values of a chat text message.
         * @implements IChatMessageValue
         * @constructor
         * @param {IChatMessageValue=} [properties] Properties to set
         */
        function ChatMessageValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * ChatMessageValue calendarInvite.
         * @member {ICalendarInvite|undefined|undefined} calendarInvite
         * @memberof ChatMessageValue
         * @instance
         */
        ChatMessageValue.prototype.calendarInvite = undefined;
    
        /**
         * ChatMessageValue form.
         * @member {IForm|undefined|undefined} form
         * @memberof ChatMessageValue
         * @instance
         */
        ChatMessageValue.prototype.form = undefined;
    
        /**
         * ChatMessageValue quill.
         * @member {Uint8Array} quill
         * @memberof ChatMessageValue
         * @instance
         */
        ChatMessageValue.prototype.quill = $util.newBuffer([]);
    
        /**
         * ChatMessageValue rsvp.
         * @member {Appointment.RSVP} rsvp
         * @memberof ChatMessageValue
         * @instance
         */
        ChatMessageValue.prototype.rsvp = 0;
    
        /**
         * ChatMessageValue text.
         * @member {string} text
         * @memberof ChatMessageValue
         * @instance
         */
        ChatMessageValue.prototype.text = "";
    
        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;
    
        /**
         * Value.
         * @member {"calendarInvite"|"form"|"quill"|"rsvp"|"text"|undefined} value
         * @memberof ChatMessageValue
         * @instance
         */
        Object.defineProperty(ChatMessageValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["calendarInvite", "form", "quill", "rsvp", "text"]),
            set: $util.oneOfSetter($oneOfFields)
        });
    
        /**
         * Creates a new ChatMessageValue instance using the specified properties.
         * @function create
         * @memberof ChatMessageValue
         * @static
         * @param {IChatMessageValue=} [properties] Properties to set
         * @returns {ChatMessageValue} ChatMessageValue instance
         */
        ChatMessageValue.create = function create(properties) {
            return new ChatMessageValue(properties);
        };
    
        /**
         * Encodes the specified ChatMessageValue message. Does not implicitly {@link ChatMessageValue.verify|verify} messages.
         * @function encode
         * @memberof ChatMessageValue
         * @static
         * @param {IChatMessageValue} message ChatMessageValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessageValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.calendarInvite != undefined && message.hasOwnProperty("calendarInvite"))
                $root.CalendarInvite.encode(message.calendarInvite, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.form != undefined && message.hasOwnProperty("form"))
                $root.Form.encode(message.form, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.quill != undefined && message.hasOwnProperty("quill"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.quill);
            if (message.rsvp != undefined && message.hasOwnProperty("rsvp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rsvp);
            if (message.text != undefined && message.hasOwnProperty("text"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.text);
            return writer;
        };
    
        /**
         * Encodes the specified ChatMessageValue message, length delimited. Does not implicitly {@link ChatMessageValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof ChatMessageValue
         * @static
         * @param {IChatMessageValue} message ChatMessageValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatMessageValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a ChatMessageValue message from the specified reader or buffer.
         * @function decode
         * @memberof ChatMessageValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {ChatMessageValue} ChatMessageValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessageValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ChatMessageValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.calendarInvite = $root.CalendarInvite.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.form = $root.Form.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.quill = reader.bytes();
                    break;
                case 4:
                    message.rsvp = reader.int32();
                    break;
                case 5:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a ChatMessageValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof ChatMessageValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {ChatMessageValue} ChatMessageValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatMessageValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a ChatMessageValue message.
         * @function verify
         * @memberof ChatMessageValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        ChatMessageValue.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            var properties = {};
            if (message.calendarInvite != undefined && message.hasOwnProperty("calendarInvite")) {
                properties.value = 1;
                {
                    var error = $root.CalendarInvite.verify(message.calendarInvite);
                    if (error)
                        return "calendarInvite." + error;
                }
            }
            if (message.form != undefined && message.hasOwnProperty("form")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                {
                    var error = $root.Form.verify(message.form);
                    if (error)
                        return "form." + error;
                }
            }
            if (message.quill != undefined && message.hasOwnProperty("quill")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!(message.quill && typeof message.quill.length === "number" || $util.isString(message.quill)))
                    return "quill: buffer expected";
            }
            if (message.rsvp != undefined && message.hasOwnProperty("rsvp")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                switch (message.rsvp) {
                default:
                    return "rsvp: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            if (message.text != undefined && message.hasOwnProperty("text")) {
                if (properties.value === 1)
                    return "value: multiple values";
                properties.value = 1;
                if (!$util.isString(message.text))
                    return "text: string expected";
            }
            return undefined;
        };
    
        /**
         * Creates a ChatMessageValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof ChatMessageValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {ChatMessageValue} ChatMessageValue
         */
        ChatMessageValue.fromObject = function fromObject(object) {
            if (object instanceof $root.ChatMessageValue)
                return object;
            var message = new $root.ChatMessageValue();
            if (object.calendarInvite != undefined) {
                if (typeof object.calendarInvite !== "object")
                    throw TypeError(".ChatMessageValue.calendarInvite: object expected");
                message.calendarInvite = $root.CalendarInvite.fromObject(object.calendarInvite);
            }
            if (object.form != undefined) {
                if (typeof object.form !== "object")
                    throw TypeError(".ChatMessageValue.form: object expected");
                message.form = $root.Form.fromObject(object.form);
            }
            if (object.quill != undefined)
                if (typeof object.quill === "string")
                    $util.base64.decode(object.quill, message.quill = $util.newBuffer($util.base64.length(object.quill)), 0);
                else if (object.quill.length)
                    message.quill = object.quill;
            switch (object.rsvp) {
            case "Maybe":
            case 0:
                message.rsvp = 0;
                break;
            case "No":
            case 1:
                message.rsvp = 1;
                break;
            case "Yes":
            case 2:
                message.rsvp = 2;
                break;
            }
            if (object.text != undefined)
                message.text = String(object.text);
            return message;
        };
    
        /**
         * Creates a plain object from a ChatMessageValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof ChatMessageValue
         * @static
         * @param {ChatMessageValue} message ChatMessageValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChatMessageValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.calendarInvite != undefined && message.hasOwnProperty("calendarInvite")) {
                object.calendarInvite = $root.CalendarInvite.toObject(message.calendarInvite, options);
                if (options.oneofs)
                    object.value = "calendarInvite";
            }
            if (message.form != undefined && message.hasOwnProperty("form")) {
                object.form = $root.Form.toObject(message.form, options);
                if (options.oneofs)
                    object.value = "form";
            }
            if (message.quill != undefined && message.hasOwnProperty("quill")) {
                object.quill = options.bytes === String ? $util.base64.encode(message.quill, 0, message.quill.length) : options.bytes === Array ? Array.prototype.slice.call(message.quill) : message.quill;
                if (options.oneofs)
                    object.value = "quill";
            }
            if (message.rsvp != undefined && message.hasOwnProperty("rsvp")) {
                object.rsvp = options.enums === String ? $root.Appointment.RSVP[message.rsvp] : message.rsvp;
                if (options.oneofs)
                    object.value = "rsvp";
            }
            if (message.text != undefined && message.hasOwnProperty("text")) {
                object.text = message.text;
                if (options.oneofs)
                    object.value = "text";
            }
            return object;
        };
    
        /**
         * Converts this ChatMessageValue to JSON.
         * @function toJSON
         * @memberof ChatMessageValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChatMessageValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Possible types of a chat text message value.
         * @name ChatMessageValue.Types
         * @enum {string}
         * @property {number} CalendarInvite=0 CalendarInvite value
         * @property {number} Form=1 Form value
         * @property {number} Quill=2 Quill value
         * @property {number} RSVP=3 RSVP value
         * @property {number} Text=4 Text value
         */
        ChatMessageValue.Types = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CalendarInvite"] = 0;
            values[valuesById[1] = "Form"] = 1;
            values[valuesById[2] = "Quill"] = 2;
            values[valuesById[3] = "RSVP"] = 3;
            values[valuesById[4] = "Text"] = 4;
            return values;
        })();
    
        return ChatMessageValue;
    })();
    
    $root.EhrApiKey = (function() {
    
        /**
         * Properties of an EhrApiKey.
         * @exports IEhrApiKey
         * @interface IEhrApiKey
         * @property {string} apiKey API key.
         * @property {boolean} isMaster Indicates whether this is a master API key.
         */
    
        /**
         * Constructs a new EhrApiKey.
         * @exports EhrApiKey
         * @classdesc An EHR integration API key.
         * @implements IEhrApiKey
         * @constructor
         * @param {IEhrApiKey=} [properties] Properties to set
         */
        function EhrApiKey(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * API key.
         * @member {string} apiKey
         * @memberof EhrApiKey
         * @instance
         */
        EhrApiKey.prototype.apiKey = "";
    
        /**
         * Indicates whether this is a master API key.
         * @member {boolean} isMaster
         * @memberof EhrApiKey
         * @instance
         */
        EhrApiKey.prototype.isMaster = false;
    
        /**
         * Creates a new EhrApiKey instance using the specified properties.
         * @function create
         * @memberof EhrApiKey
         * @static
         * @param {IEhrApiKey=} [properties] Properties to set
         * @returns {EhrApiKey} EhrApiKey instance
         */
        EhrApiKey.create = function create(properties) {
            return new EhrApiKey(properties);
        };
    
        /**
         * Encodes the specified EhrApiKey message. Does not implicitly {@link EhrApiKey.verify|verify} messages.
         * @function encode
         * @memberof EhrApiKey
         * @static
         * @param {IEhrApiKey} message EhrApiKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EhrApiKey.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiKey);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isMaster);
            return writer;
        };
    
        /**
         * Encodes the specified EhrApiKey message, length delimited. Does not implicitly {@link EhrApiKey.verify|verify} messages.
         * @function encodeDelimited
         * @memberof EhrApiKey
         * @static
         * @param {IEhrApiKey} message EhrApiKey message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EhrApiKey.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an EhrApiKey message from the specified reader or buffer.
         * @function decode
         * @memberof EhrApiKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {EhrApiKey} EhrApiKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EhrApiKey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.EhrApiKey();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.apiKey = reader.string();
                    break;
                case 2:
                    message.isMaster = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("apiKey"))
                throw $util.ProtocolError("missing required 'apiKey'", { instance: message });
            if (!message.hasOwnProperty("isMaster"))
                throw $util.ProtocolError("missing required 'isMaster'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an EhrApiKey message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof EhrApiKey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {EhrApiKey} EhrApiKey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EhrApiKey.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an EhrApiKey message.
         * @function verify
         * @memberof EhrApiKey
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        EhrApiKey.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.apiKey))
                return "apiKey: string expected";
            if (typeof message.isMaster !== "boolean")
                return "isMaster: boolean expected";
            return undefined;
        };
    
        /**
         * Creates an EhrApiKey message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof EhrApiKey
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {EhrApiKey} EhrApiKey
         */
        EhrApiKey.fromObject = function fromObject(object) {
            if (object instanceof $root.EhrApiKey)
                return object;
            var message = new $root.EhrApiKey();
            if (object.apiKey != undefined)
                message.apiKey = String(object.apiKey);
            if (object.isMaster != undefined)
                message.isMaster = Boolean(object.isMaster);
            return message;
        };
    
        /**
         * Creates a plain object from an EhrApiKey message. Also converts values to other types if specified.
         * @function toObject
         * @memberof EhrApiKey
         * @static
         * @param {EhrApiKey} message EhrApiKey
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EhrApiKey.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.apiKey = "";
                object.isMaster = false;
            }
            if (message.apiKey != undefined && message.hasOwnProperty("apiKey"))
                object.apiKey = message.apiKey;
            if (message.isMaster != undefined && message.hasOwnProperty("isMaster"))
                object.isMaster = message.isMaster;
            return object;
        };
    
        /**
         * Converts this EhrApiKey to JSON.
         * @function toJSON
         * @memberof EhrApiKey
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EhrApiKey.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return EhrApiKey;
    })();
    
    $root.Environment = (function() {
    
        /**
         * Properties of an Environment.
         * @exports IEnvironment
         * @interface IEnvironment
         * @property {Environment.ICustomBuild|undefined} [customBuild] * Exists if in a custom build environment.
         * * @see CustomBuild
         * @property {string} envName Name of this environment.
         * @property {Environment.IFirebase} firebase @see Firebase
         * @property {boolean} local Indicates whether this is local development environment.
         * @property {boolean} production Indicates whether this is prod.
         * @property {boolean|undefined} [useProdSigningKeys] Indicates whether production AGSE-PKI signing keys should be used.
         */
    
        /**
         * Constructs a new Environment.
         * @exports Environment
         * @classdesc Angular CLI environment configuration.
         * @implements IEnvironment
         * @constructor
         * @param {IEnvironment=} [properties] Properties to set
         */
        function Environment(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * * Exists if in a custom build environment.
         * * @see CustomBuild
         * @member {Environment.ICustomBuild|undefined|undefined} customBuild
         * @memberof Environment
         * @instance
         */
        Environment.prototype.customBuild = undefined;
    
        /**
         * Name of this environment.
         * @member {string} envName
         * @memberof Environment
         * @instance
         */
        Environment.prototype.envName = "";
    
        /**
         * @see Firebase
         * @member {Environment.IFirebase} firebase
         * @memberof Environment
         * @instance
         */
        Environment.prototype.firebase = undefined;
    
        /**
         * Indicates whether this is local development environment.
         * @member {boolean} local
         * @memberof Environment
         * @instance
         */
        Environment.prototype.local = false;
    
        /**
         * Indicates whether this is prod.
         * @member {boolean} production
         * @memberof Environment
         * @instance
         */
        Environment.prototype.production = false;
    
        /**
         * Indicates whether production AGSE-PKI signing keys should be used.
         * @member {boolean} useProdSigningKeys
         * @memberof Environment
         * @instance
         */
        Environment.prototype.useProdSigningKeys = false;
    
        /**
         * Creates a new Environment instance using the specified properties.
         * @function create
         * @memberof Environment
         * @static
         * @param {IEnvironment=} [properties] Properties to set
         * @returns {Environment} Environment instance
         */
        Environment.create = function create(properties) {
            return new Environment(properties);
        };
    
        /**
         * Encodes the specified Environment message. Does not implicitly {@link Environment.verify|verify} messages.
         * @function encode
         * @memberof Environment
         * @static
         * @param {IEnvironment} message Environment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.customBuild != undefined && message.hasOwnProperty("customBuild"))
                $root.Environment.CustomBuild.encode(message.customBuild, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.envName);
            $root.Environment.Firebase.encode(message.firebase, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.local);
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.production);
            if (message.useProdSigningKeys != undefined && message.hasOwnProperty("useProdSigningKeys"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.useProdSigningKeys);
            return writer;
        };
    
        /**
         * Encodes the specified Environment message, length delimited. Does not implicitly {@link Environment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Environment
         * @static
         * @param {IEnvironment} message Environment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Environment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an Environment message from the specified reader or buffer.
         * @function decode
         * @memberof Environment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Environment} Environment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Environment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.customBuild = $root.Environment.CustomBuild.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.envName = reader.string();
                    break;
                case 3:
                    message.firebase = $root.Environment.Firebase.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.local = reader.bool();
                    break;
                case 5:
                    message.production = reader.bool();
                    break;
                case 6:
                    message.useProdSigningKeys = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("envName"))
                throw $util.ProtocolError("missing required 'envName'", { instance: message });
            if (!message.hasOwnProperty("firebase"))
                throw $util.ProtocolError("missing required 'firebase'", { instance: message });
            if (!message.hasOwnProperty("local"))
                throw $util.ProtocolError("missing required 'local'", { instance: message });
            if (!message.hasOwnProperty("production"))
                throw $util.ProtocolError("missing required 'production'", { instance: message });
            return message;
        };
    
        /**
         * Decodes an Environment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Environment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Environment} Environment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Environment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an Environment message.
         * @function verify
         * @memberof Environment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        Environment.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.customBuild != undefined && message.hasOwnProperty("customBuild")) {
                var error = $root.Environment.CustomBuild.verify(message.customBuild);
                if (error)
                    return "customBuild." + error;
            }
            if (!$util.isString(message.envName))
                return "envName: string expected";
            {
                var error = $root.Environment.Firebase.verify(message.firebase);
                if (error)
                    return "firebase." + error;
            }
            if (typeof message.local !== "boolean")
                return "local: boolean expected";
            if (typeof message.production !== "boolean")
                return "production: boolean expected";
            if (message.useProdSigningKeys != undefined && message.hasOwnProperty("useProdSigningKeys"))
                if (typeof message.useProdSigningKeys !== "boolean")
                    return "useProdSigningKeys: boolean expected";
            return undefined;
        };
    
        /**
         * Creates an Environment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Environment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Environment} Environment
         */
        Environment.fromObject = function fromObject(object) {
            if (object instanceof $root.Environment)
                return object;
            var message = new $root.Environment();
            if (object.customBuild != undefined) {
                if (typeof object.customBuild !== "object")
                    throw TypeError(".Environment.customBuild: object expected");
                message.customBuild = $root.Environment.CustomBuild.fromObject(object.customBuild);
            }
            if (object.envName != undefined)
                message.envName = String(object.envName);
            if (object.firebase != undefined) {
                if (typeof object.firebase !== "object")
                    throw TypeError(".Environment.firebase: object expected");
                message.firebase = $root.Environment.Firebase.fromObject(object.firebase);
            }
            if (object.local != undefined)
                message.local = Boolean(object.local);
            if (object.production != undefined)
                message.production = Boolean(object.production);
            if (object.useProdSigningKeys != undefined)
                message.useProdSigningKeys = Boolean(object.useProdSigningKeys);
            return message;
        };
    
        /**
         * Creates a plain object from an Environment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Environment
         * @static
         * @param {Environment} message Environment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Environment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.customBuild = undefined;
                object.envName = "";
                object.firebase = undefined;
                object.local = false;
                object.production = false;
                object.useProdSigningKeys = false;
            }
            if (message.customBuild != undefined && message.hasOwnProperty("customBuild"))
                object.customBuild = $root.Environment.CustomBuild.toObject(message.customBuild, options);
            if (message.envName != undefined && message.hasOwnProperty("envName"))
                object.envName = message.envName;
            if (message.firebase != undefined && message.hasOwnProperty("firebase"))
                object.firebase = $root.Environment.Firebase.toObject(message.firebase, options);
            if (message.local != undefined && message.hasOwnProperty("local"))
                object.local = message.local;
            if (message.production != undefined && message.hasOwnProperty("production"))
                object.production = message.production;
            if (message.useProdSigningKeys != undefined && message.hasOwnProperty("useProdSigningKeys"))
                object.useProdSigningKeys = message.useProdSigningKeys;
            return object;
        };
    
        /**
         * Converts this Environment to JSON.
         * @function toJSON
         * @memberof Environment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Environment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        Environment.CustomBuild = (function() {
    
            /**
             * Properties of a CustomBuild.
             * @memberof Environment
             * @interface ICustomBuild
             * @property {Uint8Array|undefined} [audioImage] Voice call background image for this custom build.
             * @property {Environment.ICustomBuildConfig} config @see CustomBuildConfig
             * @property {string|undefined} [css] Custom styling.
             * @property {Uint8Array|undefined} [errorImage] Walken image replacement for this custom build.
             * @property {Uint8Array|undefined} [favicon] Favicon for this custom build.
             * @property {string} id Identifier of this custom build.
             * @property {Uint8Array|undefined} [logoHorizontal] Horizontal logo for this custom build.
             * @property {Uint8Array|undefined} [logoVertical] Vertical logo for this custom build.
             * @property {string} namespace Environment namespace, the base ID without branch/version information.
             * @property {Object.<string,string>|undefined} [strings] Replacement strings for this custom build.
             */
    
            /**
             * Constructs a new CustomBuild.
             * @memberof Environment
             * @classdesc Custom build environment data.
             * @implements ICustomBuild
             * @constructor
             * @param {Environment.ICustomBuild=} [properties] Properties to set
             */
            function CustomBuild(properties) {
                this.strings = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Voice call background image for this custom build.
             * @member {Uint8Array} audioImage
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.audioImage = $util.newBuffer([]);
    
            /**
             * @see CustomBuildConfig
             * @member {Environment.ICustomBuildConfig} config
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.config = undefined;
    
            /**
             * Custom styling.
             * @member {string} css
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.css = "";
    
            /**
             * Walken image replacement for this custom build.
             * @member {Uint8Array} errorImage
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.errorImage = $util.newBuffer([]);
    
            /**
             * Favicon for this custom build.
             * @member {Uint8Array} favicon
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.favicon = $util.newBuffer([]);
    
            /**
             * Identifier of this custom build.
             * @member {string} id
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.id = "";
    
            /**
             * Horizontal logo for this custom build.
             * @member {Uint8Array} logoHorizontal
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.logoHorizontal = $util.newBuffer([]);
    
            /**
             * Vertical logo for this custom build.
             * @member {Uint8Array} logoVertical
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.logoVertical = $util.newBuffer([]);
    
            /**
             * Environment namespace, the base ID without branch/version information.
             * @member {string} namespace
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.namespace = "";
    
            /**
             * Replacement strings for this custom build.
             * @member {Object.<string,string>} strings
             * @memberof Environment.CustomBuild
             * @instance
             */
            CustomBuild.prototype.strings = $util.emptyObject;
    
            /**
             * Creates a new CustomBuild instance using the specified properties.
             * @function create
             * @memberof Environment.CustomBuild
             * @static
             * @param {Environment.ICustomBuild=} [properties] Properties to set
             * @returns {Environment.CustomBuild} CustomBuild instance
             */
            CustomBuild.create = function create(properties) {
                return new CustomBuild(properties);
            };
    
            /**
             * Encodes the specified CustomBuild message. Does not implicitly {@link Environment.CustomBuild.verify|verify} messages.
             * @function encode
             * @memberof Environment.CustomBuild
             * @static
             * @param {Environment.ICustomBuild} message CustomBuild message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomBuild.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.audioImage != undefined && message.hasOwnProperty("audioImage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.audioImage);
                $root.Environment.CustomBuildConfig.encode(message.config, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.css != undefined && message.hasOwnProperty("css"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.css);
                if (message.errorImage != undefined && message.hasOwnProperty("errorImage"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.errorImage);
                if (message.favicon != undefined && message.hasOwnProperty("favicon"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.favicon);
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.id);
                if (message.logoHorizontal != undefined && message.hasOwnProperty("logoHorizontal"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.logoHorizontal);
                if (message.logoVertical != undefined && message.hasOwnProperty("logoVertical"))
                    writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.logoVertical);
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.namespace);
                if (message.strings != undefined && message.hasOwnProperty("strings"))
                    for (var keys = Object.keys(message.strings), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.strings[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified CustomBuild message, length delimited. Does not implicitly {@link Environment.CustomBuild.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Environment.CustomBuild
             * @static
             * @param {Environment.ICustomBuild} message CustomBuild message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomBuild.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CustomBuild message from the specified reader or buffer.
             * @function decode
             * @memberof Environment.CustomBuild
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Environment.CustomBuild} CustomBuild
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomBuild.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Environment.CustomBuild(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.audioImage = reader.bytes();
                        break;
                    case 2:
                        message.config = $root.Environment.CustomBuildConfig.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.css = reader.string();
                        break;
                    case 4:
                        message.errorImage = reader.bytes();
                        break;
                    case 5:
                        message.favicon = reader.bytes();
                        break;
                    case 6:
                        message.id = reader.string();
                        break;
                    case 7:
                        message.logoHorizontal = reader.bytes();
                        break;
                    case 8:
                        message.logoVertical = reader.bytes();
                        break;
                    case 9:
                        message.namespace = reader.string();
                        break;
                    case 10:
                        reader.skip().pos++;
                        if (message.strings === $util.emptyObject)
                            message.strings = {};
                        key = reader.string();
                        reader.pos++;
                        message.strings[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("config"))
                    throw $util.ProtocolError("missing required 'config'", { instance: message });
                if (!message.hasOwnProperty("id"))
                    throw $util.ProtocolError("missing required 'id'", { instance: message });
                if (!message.hasOwnProperty("namespace"))
                    throw $util.ProtocolError("missing required 'namespace'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a CustomBuild message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Environment.CustomBuild
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Environment.CustomBuild} CustomBuild
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomBuild.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CustomBuild message.
             * @function verify
             * @memberof Environment.CustomBuild
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            CustomBuild.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.audioImage != undefined && message.hasOwnProperty("audioImage"))
                    if (!(message.audioImage && typeof message.audioImage.length === "number" || $util.isString(message.audioImage)))
                        return "audioImage: buffer expected";
                {
                    var error = $root.Environment.CustomBuildConfig.verify(message.config);
                    if (error)
                        return "config." + error;
                }
                if (message.css != undefined && message.hasOwnProperty("css"))
                    if (!$util.isString(message.css))
                        return "css: string expected";
                if (message.errorImage != undefined && message.hasOwnProperty("errorImage"))
                    if (!(message.errorImage && typeof message.errorImage.length === "number" || $util.isString(message.errorImage)))
                        return "errorImage: buffer expected";
                if (message.favicon != undefined && message.hasOwnProperty("favicon"))
                    if (!(message.favicon && typeof message.favicon.length === "number" || $util.isString(message.favicon)))
                        return "favicon: buffer expected";
                if (!$util.isString(message.id))
                    return "id: string expected";
                if (message.logoHorizontal != undefined && message.hasOwnProperty("logoHorizontal"))
                    if (!(message.logoHorizontal && typeof message.logoHorizontal.length === "number" || $util.isString(message.logoHorizontal)))
                        return "logoHorizontal: buffer expected";
                if (message.logoVertical != undefined && message.hasOwnProperty("logoVertical"))
                    if (!(message.logoVertical && typeof message.logoVertical.length === "number" || $util.isString(message.logoVertical)))
                        return "logoVertical: buffer expected";
                if (!$util.isString(message.namespace))
                    return "namespace: string expected";
                if (message.strings != undefined && message.hasOwnProperty("strings")) {
                    if (!$util.isObject(message.strings))
                        return "strings: object expected";
                    var key = Object.keys(message.strings);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.strings[key[i]]))
                            return "strings: string{k:string} expected";
                }
                return undefined;
            };
    
            /**
             * Creates a CustomBuild message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Environment.CustomBuild
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Environment.CustomBuild} CustomBuild
             */
            CustomBuild.fromObject = function fromObject(object) {
                if (object instanceof $root.Environment.CustomBuild)
                    return object;
                var message = new $root.Environment.CustomBuild();
                if (object.audioImage != undefined)
                    if (typeof object.audioImage === "string")
                        $util.base64.decode(object.audioImage, message.audioImage = $util.newBuffer($util.base64.length(object.audioImage)), 0);
                    else if (object.audioImage.length)
                        message.audioImage = object.audioImage;
                if (object.config != undefined) {
                    if (typeof object.config !== "object")
                        throw TypeError(".Environment.CustomBuild.config: object expected");
                    message.config = $root.Environment.CustomBuildConfig.fromObject(object.config);
                }
                if (object.css != undefined)
                    message.css = String(object.css);
                if (object.errorImage != undefined)
                    if (typeof object.errorImage === "string")
                        $util.base64.decode(object.errorImage, message.errorImage = $util.newBuffer($util.base64.length(object.errorImage)), 0);
                    else if (object.errorImage.length)
                        message.errorImage = object.errorImage;
                if (object.favicon != undefined)
                    if (typeof object.favicon === "string")
                        $util.base64.decode(object.favicon, message.favicon = $util.newBuffer($util.base64.length(object.favicon)), 0);
                    else if (object.favicon.length)
                        message.favicon = object.favicon;
                if (object.id != undefined)
                    message.id = String(object.id);
                if (object.logoHorizontal != undefined)
                    if (typeof object.logoHorizontal === "string")
                        $util.base64.decode(object.logoHorizontal, message.logoHorizontal = $util.newBuffer($util.base64.length(object.logoHorizontal)), 0);
                    else if (object.logoHorizontal.length)
                        message.logoHorizontal = object.logoHorizontal;
                if (object.logoVertical != undefined)
                    if (typeof object.logoVertical === "string")
                        $util.base64.decode(object.logoVertical, message.logoVertical = $util.newBuffer($util.base64.length(object.logoVertical)), 0);
                    else if (object.logoVertical.length)
                        message.logoVertical = object.logoVertical;
                if (object.namespace != undefined)
                    message.namespace = String(object.namespace);
                if (object.strings) {
                    if (typeof object.strings !== "object")
                        throw TypeError(".Environment.CustomBuild.strings: object expected");
                    message.strings = {};
                    for (var keys = Object.keys(object.strings), i = 0; i < keys.length; ++i)
                        message.strings[keys[i]] = String(object.strings[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a CustomBuild message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Environment.CustomBuild
             * @static
             * @param {Environment.CustomBuild} message CustomBuild
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomBuild.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.strings = {};
                if (options.defaults) {
                    object.audioImage = options.bytes === String ? "" : [];
                    object.config = undefined;
                    object.css = "";
                    object.errorImage = options.bytes === String ? "" : [];
                    object.favicon = options.bytes === String ? "" : [];
                    object.id = "";
                    object.logoHorizontal = options.bytes === String ? "" : [];
                    object.logoVertical = options.bytes === String ? "" : [];
                    object.namespace = "";
                }
                if (message.audioImage != undefined && message.hasOwnProperty("audioImage"))
                    object.audioImage = options.bytes === String ? $util.base64.encode(message.audioImage, 0, message.audioImage.length) : options.bytes === Array ? Array.prototype.slice.call(message.audioImage) : message.audioImage;
                if (message.config != undefined && message.hasOwnProperty("config"))
                    object.config = $root.Environment.CustomBuildConfig.toObject(message.config, options);
                if (message.css != undefined && message.hasOwnProperty("css"))
                    object.css = message.css;
                if (message.errorImage != undefined && message.hasOwnProperty("errorImage"))
                    object.errorImage = options.bytes === String ? $util.base64.encode(message.errorImage, 0, message.errorImage.length) : options.bytes === Array ? Array.prototype.slice.call(message.errorImage) : message.errorImage;
                if (message.favicon != undefined && message.hasOwnProperty("favicon"))
                    object.favicon = options.bytes === String ? $util.base64.encode(message.favicon, 0, message.favicon.length) : options.bytes === Array ? Array.prototype.slice.call(message.favicon) : message.favicon;
                if (message.id != undefined && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.logoHorizontal != undefined && message.hasOwnProperty("logoHorizontal"))
                    object.logoHorizontal = options.bytes === String ? $util.base64.encode(message.logoHorizontal, 0, message.logoHorizontal.length) : options.bytes === Array ? Array.prototype.slice.call(message.logoHorizontal) : message.logoHorizontal;
                if (message.logoVertical != undefined && message.hasOwnProperty("logoVertical"))
                    object.logoVertical = options.bytes === String ? $util.base64.encode(message.logoVertical, 0, message.logoVertical.length) : options.bytes === Array ? Array.prototype.slice.call(message.logoVertical) : message.logoVertical;
                if (message.namespace != undefined && message.hasOwnProperty("namespace"))
                    object.namespace = message.namespace;
                var keys2;
                if (message.strings && (keys2 = Object.keys(message.strings)).length) {
                    object.strings = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.strings[keys2[j]] = message.strings[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this CustomBuild to JSON.
             * @function toJSON
             * @memberof Environment.CustomBuild
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomBuild.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CustomBuild;
        })();
    
        Environment.CustomBuildConfig = (function() {
    
            /**
             * Properties of a CustomBuildConfig.
             * @memberof Environment
             * @interface ICustomBuildConfig
             * @property {boolean|undefined} [accountsOnly] Indicates whether environment should be accounts-only (no ephemeral).
             * @property {boolean|undefined} [browserExtension] Indicates whether this is for a browser extension.
             * @property {string|undefined} [backgroundColor] Optional custom background color.
             * @property {boolean|undefined} [callTypeAudio] If true, performs audio call by default.
             * @property {boolean|undefined} [callTypeVideo] If true, performs video call by default (takes priority over callTypeAudio).
             * @property {boolean|undefined} [disableP2P] If true, forces the use of Twilio TURN infrastructure for lower-latency calls.
             * @property {boolean|undefined} [enableDocs] Indicates whether docs will be enabled.
             * @property {string|undefined} [foregroundColor] Optional custom foreground color.
             * @property {boolean|undefined} [lockedDown] If true, locked down with server-stored password.
             * @property {boolean|undefined} [nativeCrypto] Indicates whether native crypto will be used.
             * @property {string|undefined} [organization] Organization username to associate with this custom build.
             * @property {string|undefined} [password] Optional password to lock down environment (not a security feature).
             * @property {boolean|undefined} [pro] Indicates whether this is a Cyph Pro environment.
             * @property {boolean|undefined} [telehealth] Indicates whether this is the telehealth version.
             * @property {string|undefined} [title] Page title of this Cyph instance.
             * @property {boolean|undefined} [usePrimaryNamespace] Indicates whether this environment should share the main Cyph database namespace.
             * @property {boolean|undefined} [whiteLabel] If true, environment will be full white label, with no "Powered by Cyph" notices.
             */
    
            /**
             * Constructs a new CustomBuildConfig.
             * @memberof Environment
             * @classdesc Custom build configuration.
             * @implements ICustomBuildConfig
             * @constructor
             * @param {Environment.ICustomBuildConfig=} [properties] Properties to set
             */
            function CustomBuildConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Indicates whether environment should be accounts-only (no ephemeral).
             * @member {boolean} accountsOnly
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.accountsOnly = false;
    
            /**
             * Indicates whether this is for a browser extension.
             * @member {boolean} browserExtension
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.browserExtension = false;
    
            /**
             * Optional custom background color.
             * @member {string} backgroundColor
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.backgroundColor = "";
    
            /**
             * If true, performs audio call by default.
             * @member {boolean} callTypeAudio
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.callTypeAudio = false;
    
            /**
             * If true, performs video call by default (takes priority over callTypeAudio).
             * @member {boolean} callTypeVideo
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.callTypeVideo = false;
    
            /**
             * If true, forces the use of Twilio TURN infrastructure for lower-latency calls.
             * @member {boolean} disableP2P
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.disableP2P = false;
    
            /**
             * Indicates whether docs will be enabled.
             * @member {boolean} enableDocs
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.enableDocs = false;
    
            /**
             * Optional custom foreground color.
             * @member {string} foregroundColor
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.foregroundColor = "";
    
            /**
             * If true, locked down with server-stored password.
             * @member {boolean} lockedDown
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.lockedDown = false;
    
            /**
             * Indicates whether native crypto will be used.
             * @member {boolean} nativeCrypto
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.nativeCrypto = false;
    
            /**
             * Organization username to associate with this custom build.
             * @member {string} organization
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.organization = "";
    
            /**
             * Optional password to lock down environment (not a security feature).
             * @member {string} password
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.password = "";
    
            /**
             * Indicates whether this is a Cyph Pro environment.
             * @member {boolean} pro
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.pro = false;
    
            /**
             * Indicates whether this is the telehealth version.
             * @member {boolean} telehealth
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.telehealth = false;
    
            /**
             * Page title of this Cyph instance.
             * @member {string} title
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.title = "";
    
            /**
             * Indicates whether this environment should share the main Cyph database namespace.
             * @member {boolean} usePrimaryNamespace
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.usePrimaryNamespace = false;
    
            /**
             * If true, environment will be full white label, with no "Powered by Cyph" notices.
             * @member {boolean} whiteLabel
             * @memberof Environment.CustomBuildConfig
             * @instance
             */
            CustomBuildConfig.prototype.whiteLabel = false;
    
            /**
             * Creates a new CustomBuildConfig instance using the specified properties.
             * @function create
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Environment.ICustomBuildConfig=} [properties] Properties to set
             * @returns {Environment.CustomBuildConfig} CustomBuildConfig instance
             */
            CustomBuildConfig.create = function create(properties) {
                return new CustomBuildConfig(properties);
            };
    
            /**
             * Encodes the specified CustomBuildConfig message. Does not implicitly {@link Environment.CustomBuildConfig.verify|verify} messages.
             * @function encode
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Environment.ICustomBuildConfig} message CustomBuildConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomBuildConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountsOnly != undefined && message.hasOwnProperty("accountsOnly"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.accountsOnly);
                if (message.browserExtension != undefined && message.hasOwnProperty("browserExtension"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.browserExtension);
                if (message.backgroundColor != undefined && message.hasOwnProperty("backgroundColor"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.backgroundColor);
                if (message.callTypeAudio != undefined && message.hasOwnProperty("callTypeAudio"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.callTypeAudio);
                if (message.callTypeVideo != undefined && message.hasOwnProperty("callTypeVideo"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.callTypeVideo);
                if (message.disableP2P != undefined && message.hasOwnProperty("disableP2P"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.disableP2P);
                if (message.enableDocs != undefined && message.hasOwnProperty("enableDocs"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.enableDocs);
                if (message.foregroundColor != undefined && message.hasOwnProperty("foregroundColor"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.foregroundColor);
                if (message.lockedDown != undefined && message.hasOwnProperty("lockedDown"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.lockedDown);
                if (message.nativeCrypto != undefined && message.hasOwnProperty("nativeCrypto"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.nativeCrypto);
                if (message.organization != undefined && message.hasOwnProperty("organization"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.organization);
                if (message.password != undefined && message.hasOwnProperty("password"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.password);
                if (message.pro != undefined && message.hasOwnProperty("pro"))
                    writer.uint32(/* id 13, wireType 0 =*/104).bool(message.pro);
                if (message.telehealth != undefined && message.hasOwnProperty("telehealth"))
                    writer.uint32(/* id 14, wireType 0 =*/112).bool(message.telehealth);
                if (message.title != undefined && message.hasOwnProperty("title"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.title);
                if (message.usePrimaryNamespace != undefined && message.hasOwnProperty("usePrimaryNamespace"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.usePrimaryNamespace);
                if (message.whiteLabel != undefined && message.hasOwnProperty("whiteLabel"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.whiteLabel);
                return writer;
            };
    
            /**
             * Encodes the specified CustomBuildConfig message, length delimited. Does not implicitly {@link Environment.CustomBuildConfig.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Environment.ICustomBuildConfig} message CustomBuildConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomBuildConfig.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CustomBuildConfig message from the specified reader or buffer.
             * @function decode
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Environment.CustomBuildConfig} CustomBuildConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomBuildConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Environment.CustomBuildConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountsOnly = reader.bool();
                        break;
                    case 2:
                        message.browserExtension = reader.bool();
                        break;
                    case 3:
                        message.backgroundColor = reader.string();
                        break;
                    case 4:
                        message.callTypeAudio = reader.bool();
                        break;
                    case 5:
                        message.callTypeVideo = reader.bool();
                        break;
                    case 6:
                        message.disableP2P = reader.bool();
                        break;
                    case 7:
                        message.enableDocs = reader.bool();
                        break;
                    case 8:
                        message.foregroundColor = reader.string();
                        break;
                    case 9:
                        message.lockedDown = reader.bool();
                        break;
                    case 10:
                        message.nativeCrypto = reader.bool();
                        break;
                    case 11:
                        message.organization = reader.string();
                        break;
                    case 12:
                        message.password = reader.string();
                        break;
                    case 13:
                        message.pro = reader.bool();
                        break;
                    case 14:
                        message.telehealth = reader.bool();
                        break;
                    case 15:
                        message.title = reader.string();
                        break;
                    case 16:
                        message.usePrimaryNamespace = reader.bool();
                        break;
                    case 17:
                        message.whiteLabel = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CustomBuildConfig message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Environment.CustomBuildConfig} CustomBuildConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomBuildConfig.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CustomBuildConfig message.
             * @function verify
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            CustomBuildConfig.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.accountsOnly != undefined && message.hasOwnProperty("accountsOnly"))
                    if (typeof message.accountsOnly !== "boolean")
                        return "accountsOnly: boolean expected";
                if (message.browserExtension != undefined && message.hasOwnProperty("browserExtension"))
                    if (typeof message.browserExtension !== "boolean")
                        return "browserExtension: boolean expected";
                if (message.backgroundColor != undefined && message.hasOwnProperty("backgroundColor"))
                    if (!$util.isString(message.backgroundColor))
                        return "backgroundColor: string expected";
                if (message.callTypeAudio != undefined && message.hasOwnProperty("callTypeAudio"))
                    if (typeof message.callTypeAudio !== "boolean")
                        return "callTypeAudio: boolean expected";
                if (message.callTypeVideo != undefined && message.hasOwnProperty("callTypeVideo"))
                    if (typeof message.callTypeVideo !== "boolean")
                        return "callTypeVideo: boolean expected";
                if (message.disableP2P != undefined && message.hasOwnProperty("disableP2P"))
                    if (typeof message.disableP2P !== "boolean")
                        return "disableP2P: boolean expected";
                if (message.enableDocs != undefined && message.hasOwnProperty("enableDocs"))
                    if (typeof message.enableDocs !== "boolean")
                        return "enableDocs: boolean expected";
                if (message.foregroundColor != undefined && message.hasOwnProperty("foregroundColor"))
                    if (!$util.isString(message.foregroundColor))
                        return "foregroundColor: string expected";
                if (message.lockedDown != undefined && message.hasOwnProperty("lockedDown"))
                    if (typeof message.lockedDown !== "boolean")
                        return "lockedDown: boolean expected";
                if (message.nativeCrypto != undefined && message.hasOwnProperty("nativeCrypto"))
                    if (typeof message.nativeCrypto !== "boolean")
                        return "nativeCrypto: boolean expected";
                if (message.organization != undefined && message.hasOwnProperty("organization"))
                    if (!$util.isString(message.organization))
                        return "organization: string expected";
                if (message.password != undefined && message.hasOwnProperty("password"))
                    if (!$util.isString(message.password))
                        return "password: string expected";
                if (message.pro != undefined && message.hasOwnProperty("pro"))
                    if (typeof message.pro !== "boolean")
                        return "pro: boolean expected";
                if (message.telehealth != undefined && message.hasOwnProperty("telehealth"))
                    if (typeof message.telehealth !== "boolean")
                        return "telehealth: boolean expected";
                if (message.title != undefined && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.usePrimaryNamespace != undefined && message.hasOwnProperty("usePrimaryNamespace"))
                    if (typeof message.usePrimaryNamespace !== "boolean")
                        return "usePrimaryNamespace: boolean expected";
                if (message.whiteLabel != undefined && message.hasOwnProperty("whiteLabel"))
                    if (typeof message.whiteLabel !== "boolean")
                        return "whiteLabel: boolean expected";
                return undefined;
            };
    
            /**
             * Creates a CustomBuildConfig message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Environment.CustomBuildConfig} CustomBuildConfig
             */
            CustomBuildConfig.fromObject = function fromObject(object) {
                if (object instanceof $root.Environment.CustomBuildConfig)
                    return object;
                var message = new $root.Environment.CustomBuildConfig();
                if (object.accountsOnly != undefined)
                    message.accountsOnly = Boolean(object.accountsOnly);
                if (object.browserExtension != undefined)
                    message.browserExtension = Boolean(object.browserExtension);
                if (object.backgroundColor != undefined)
                    message.backgroundColor = String(object.backgroundColor);
                if (object.callTypeAudio != undefined)
                    message.callTypeAudio = Boolean(object.callTypeAudio);
                if (object.callTypeVideo != undefined)
                    message.callTypeVideo = Boolean(object.callTypeVideo);
                if (object.disableP2P != undefined)
                    message.disableP2P = Boolean(object.disableP2P);
                if (object.enableDocs != undefined)
                    message.enableDocs = Boolean(object.enableDocs);
                if (object.foregroundColor != undefined)
                    message.foregroundColor = String(object.foregroundColor);
                if (object.lockedDown != undefined)
                    message.lockedDown = Boolean(object.lockedDown);
                if (object.nativeCrypto != undefined)
                    message.nativeCrypto = Boolean(object.nativeCrypto);
                if (object.organization != undefined)
                    message.organization = String(object.organization);
                if (object.password != undefined)
                    message.password = String(object.password);
                if (object.pro != undefined)
                    message.pro = Boolean(object.pro);
                if (object.telehealth != undefined)
                    message.telehealth = Boolean(object.telehealth);
                if (object.title != undefined)
                    message.title = String(object.title);
                if (object.usePrimaryNamespace != undefined)
                    message.usePrimaryNamespace = Boolean(object.usePrimaryNamespace);
                if (object.whiteLabel != undefined)
                    message.whiteLabel = Boolean(object.whiteLabel);
                return message;
            };
    
            /**
             * Creates a plain object from a CustomBuildConfig message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Environment.CustomBuildConfig
             * @static
             * @param {Environment.CustomBuildConfig} message CustomBuildConfig
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomBuildConfig.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.accountsOnly = false;
                    object.browserExtension = false;
                    object.backgroundColor = "";
                    object.callTypeAudio = false;
                    object.callTypeVideo = false;
                    object.disableP2P = false;
                    object.enableDocs = false;
                    object.foregroundColor = "";
                    object.lockedDown = false;
                    object.nativeCrypto = false;
                    object.organization = "";
                    object.password = "";
                    object.pro = false;
                    object.telehealth = false;
                    object.title = "";
                    object.usePrimaryNamespace = false;
                    object.whiteLabel = false;
                }
                if (message.accountsOnly != undefined && message.hasOwnProperty("accountsOnly"))
                    object.accountsOnly = message.accountsOnly;
                if (message.browserExtension != undefined && message.hasOwnProperty("browserExtension"))
                    object.browserExtension = message.browserExtension;
                if (message.backgroundColor != undefined && message.hasOwnProperty("backgroundColor"))
                    object.backgroundColor = message.backgroundColor;
                if (message.callTypeAudio != undefined && message.hasOwnProperty("callTypeAudio"))
                    object.callTypeAudio = message.callTypeAudio;
                if (message.callTypeVideo != undefined && message.hasOwnProperty("callTypeVideo"))
                    object.callTypeVideo = message.callTypeVideo;
                if (message.disableP2P != undefined && message.hasOwnProperty("disableP2P"))
                    object.disableP2P = message.disableP2P;
                if (message.enableDocs != undefined && message.hasOwnProperty("enableDocs"))
                    object.enableDocs = message.enableDocs;
                if (message.foregroundColor != undefined && message.hasOwnProperty("foregroundColor"))
                    object.foregroundColor = message.foregroundColor;
                if (message.lockedDown != undefined && message.hasOwnProperty("lockedDown"))
                    object.lockedDown = message.lockedDown;
                if (message.nativeCrypto != undefined && message.hasOwnProperty("nativeCrypto"))
                    object.nativeCrypto = message.nativeCrypto;
                if (message.organization != undefined && message.hasOwnProperty("organization"))
                    object.organization = message.organization;
                if (message.password != undefined && message.hasOwnProperty("password"))
                    object.password = message.password;
                if (message.pro != undefined && message.hasOwnProperty("pro"))
                    object.pro = message.pro;
                if (message.telehealth != undefined && message.hasOwnProperty("telehealth"))
                    object.telehealth = message.telehealth;
                if (message.title != undefined && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.usePrimaryNamespace != undefined && message.hasOwnProperty("usePrimaryNamespace"))
                    object.usePrimaryNamespace = message.usePrimaryNamespace;
                if (message.whiteLabel != undefined && message.hasOwnProperty("whiteLabel"))
                    object.whiteLabel = message.whiteLabel;
                return object;
            };
    
            /**
             * Converts this CustomBuildConfig to JSON.
             * @function toJSON
             * @memberof Environment.CustomBuildConfig
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomBuildConfig.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CustomBuildConfig;
        })();
    
        Environment.Firebase = (function() {
    
            /**
             * Properties of a Firebase.
             * @memberof Environment
             * @interface IFirebase
             * @property {string} apiKey API key.
             * @property {string} messagingSenderId Firebase Cloud Messaging ID.
             * @property {string} project Project ID.
             */
    
            /**
             * Constructs a new Firebase.
             * @memberof Environment
             * @classdesc Firebase configuration.
             * @implements IFirebase
             * @constructor
             * @param {Environment.IFirebase=} [properties] Properties to set
             */
            function Firebase(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * API key.
             * @member {string} apiKey
             * @memberof Environment.Firebase
             * @instance
             */
            Firebase.prototype.apiKey = "";
    
            /**
             * Firebase Cloud Messaging ID.
             * @member {string} messagingSenderId
             * @memberof Environment.Firebase
             * @instance
             */
            Firebase.prototype.messagingSenderId = "";
    
            /**
             * Project ID.
             * @member {string} project
             * @memberof Environment.Firebase
             * @instance
             */
            Firebase.prototype.project = "";
    
            /**
             * Creates a new Firebase instance using the specified properties.
             * @function create
             * @memberof Environment.Firebase
             * @static
             * @param {Environment.IFirebase=} [properties] Properties to set
             * @returns {Environment.Firebase} Firebase instance
             */
            Firebase.create = function create(properties) {
                return new Firebase(properties);
            };
    
            /**
             * Encodes the specified Firebase message. Does not implicitly {@link Environment.Firebase.verify|verify} messages.
             * @function encode
             * @memberof Environment.Firebase
             * @static
             * @param {Environment.IFirebase} message Firebase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Firebase.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.apiKey);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.messagingSenderId);
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.project);
                return writer;
            };
    
            /**
             * Encodes the specified Firebase message, length delimited. Does not implicitly {@link Environment.Firebase.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Environment.Firebase
             * @static
             * @param {Environment.IFirebase} message Firebase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Firebase.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Firebase message from the specified reader or buffer.
             * @function decode
             * @memberof Environment.Firebase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Environment.Firebase} Firebase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Firebase.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Environment.Firebase();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.apiKey = reader.string();
                        break;
                    case 2:
                        message.messagingSenderId = reader.string();
                        break;
                    case 3:
                        message.project = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("apiKey"))
                    throw $util.ProtocolError("missing required 'apiKey'", { instance: message });
                if (!message.hasOwnProperty("messagingSenderId"))
                    throw $util.ProtocolError("missing required 'messagingSenderId'", { instance: message });
                if (!message.hasOwnProperty("project"))
                    throw $util.ProtocolError("missing required 'project'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a Firebase message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Environment.Firebase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Environment.Firebase} Firebase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Firebase.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Firebase message.
             * @function verify
             * @memberof Environment.Firebase
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Firebase.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (!$util.isString(message.apiKey))
                    return "apiKey: string expected";
                if (!$util.isString(message.messagingSenderId))
                    return "messagingSenderId: string expected";
                if (!$util.isString(message.project))
                    return "project: string expected";
                return undefined;
            };
    
            /**
             * Creates a Firebase message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Environment.Firebase
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Environment.Firebase} Firebase
             */
            Firebase.fromObject = function fromObject(object) {
                if (object instanceof $root.Environment.Firebase)
                    return object;
                var message = new $root.Environment.Firebase();
                if (object.apiKey != undefined)
                    message.apiKey = String(object.apiKey);
                if (object.messagingSenderId != undefined)
                    message.messagingSenderId = String(object.messagingSenderId);
                if (object.project != undefined)
                    message.project = String(object.project);
                return message;
            };
    
            /**
             * Creates a plain object from a Firebase message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Environment.Firebase
             * @static
             * @param {Environment.Firebase} message Firebase
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Firebase.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.apiKey = "";
                    object.messagingSenderId = "";
                    object.project = "";
                }
                if (message.apiKey != undefined && message.hasOwnProperty("apiKey"))
                    object.apiKey = message.apiKey;
                if (message.messagingSenderId != undefined && message.hasOwnProperty("messagingSenderId"))
                    object.messagingSenderId = message.messagingSenderId;
                if (message.project != undefined && message.hasOwnProperty("project"))
                    object.project = message.project;
                return object;
            };
    
            /**
             * Converts this Firebase to JSON.
             * @function toJSON
             * @memberof Environment.Firebase
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Firebase.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Firebase;
        })();
    
        return Environment;
    })();
    
    $root.Form = (function() {
    
        /**
         * Properties of a Form.
         * @exports IForm
         * @interface IForm
         * @property {Array.<Form.IComponent>|undefined} [components] @see Component
         * @property {string|undefined} [id] Optional ID. Can be used for associating with fields in other systems.
         */
    
        /**
         * Constructs a new Form.
         * @exports Form
         * @classdesc Represents a form that a user can submit responses to.
         * @implements IForm
         * @constructor
         * @param {IForm=} [properties] Properties to set
         */
        function Form(properties) {
            this.components = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see Component
         * @member {Array.<Form.IComponent>} components
         * @memberof Form
         * @instance
         */
        Form.prototype.components = $util.emptyArray;
    
        /**
         * Optional ID. Can be used for associating with fields in other systems.
         * @member {string} id
         * @memberof Form
         * @instance
         */
        Form.prototype.id = "";
    
        /**
         * Creates a new Form instance using the specified properties.
         * @function create
         * @memberof Form
         * @static
         * @param {IForm=} [properties] Properties to set
         * @returns {Form} Form instance
         */
        Form.create = function create(properties) {
            return new Form(properties);
        };
    
        /**
         * Encodes the specified Form message. Does not implicitly {@link Form.verify|verify} messages.
         * @function encode
         * @memberof Form
         * @static
         * @param {IForm} message Form message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Form.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.components != undefined && message.components.length)
                for (var i = 0; i < message.components.length; ++i)
                    $root.Form.Component.encode(message.components[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.id != undefined && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            return writer;
        };
    
        /**
         * Encodes the specified Form message, length delimited. Does not implicitly {@link Form.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Form
         * @static
         * @param {IForm} message Form message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Form.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Form message from the specified reader or buffer.
         * @function decode
         * @memberof Form
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Form} Form
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Form.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Form();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.components && message.components.length))
                        message.components = [];
                    message.components.push($root.Form.Component.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a Form message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Form
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Form} Form
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Form.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Form message.
         * @function verify
         * @memberof Form
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        Form.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.components != undefined && message.hasOwnProperty("components")) {
                if (!Array.isArray(message.components))
                    return "components: array expected";
                for (var i = 0; i < message.components.length; ++i) {
                    var error = $root.Form.Component.verify(message.components[i]);
                    if (error)
                        return "components." + error;
                }
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return undefined;
        };
    
        /**
         * Creates a Form message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Form
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Form} Form
         */
        Form.fromObject = function fromObject(object) {
            if (object instanceof $root.Form)
                return object;
            var message = new $root.Form();
            if (object.components) {
                if (!Array.isArray(object.components))
                    throw TypeError(".Form.components: array expected");
                message.components = [];
                for (var i = 0; i < object.components.length; ++i) {
                    if (typeof object.components[i] !== "object")
                        throw TypeError(".Form.components: object expected");
                    message.components[i] = $root.Form.Component.fromObject(object.components[i]);
                }
            }
            if (object.id != undefined)
                message.id = String(object.id);
            return message;
        };
    
        /**
         * Creates a plain object from a Form message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Form
         * @static
         * @param {Form} message Form
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Form.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.components = [];
            if (options.defaults)
                object.id = "";
            if (message.components && message.components.length) {
                object.components = [];
                for (var j = 0; j < message.components.length; ++j)
                    object.components[j] = $root.Form.Component.toObject(message.components[j], options);
            }
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
    
        /**
         * Converts this Form to JSON.
         * @function toJSON
         * @memberof Form
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Form.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        Form.Component = (function() {
    
            /**
             * Properties of a Component.
             * @memberof Form
             * @interface IComponent
             * @property {Array.<Form.IElementRow>|undefined} [rows] @see ElementRow
             * @property {string|undefined} [id] @see Form.id
             * @property {string|undefined} [idSeparator] Separator for concatenating element values when sending to another system.
             */
    
            /**
             * Constructs a new Component.
             * @memberof Form
             * @classdesc Reusable building block consisting of multiple forms.
             * @implements IComponent
             * @constructor
             * @param {Form.IComponent=} [properties] Properties to set
             */
            function Component(properties) {
                this.rows = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see ElementRow
             * @member {Array.<Form.IElementRow>} rows
             * @memberof Form.Component
             * @instance
             */
            Component.prototype.rows = $util.emptyArray;
    
            /**
             * @see Form.id
             * @member {string} id
             * @memberof Form.Component
             * @instance
             */
            Component.prototype.id = "";
    
            /**
             * Separator for concatenating element values when sending to another system.
             * @member {string} idSeparator
             * @memberof Form.Component
             * @instance
             */
            Component.prototype.idSeparator = "";
    
            /**
             * Creates a new Component instance using the specified properties.
             * @function create
             * @memberof Form.Component
             * @static
             * @param {Form.IComponent=} [properties] Properties to set
             * @returns {Form.Component} Component instance
             */
            Component.create = function create(properties) {
                return new Component(properties);
            };
    
            /**
             * Encodes the specified Component message. Does not implicitly {@link Form.Component.verify|verify} messages.
             * @function encode
             * @memberof Form.Component
             * @static
             * @param {Form.IComponent} message Component message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Component.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != undefined && message.rows.length)
                    for (var i = 0; i < message.rows.length; ++i)
                        $root.Form.ElementRow.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != undefined && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.idSeparator);
                return writer;
            };
    
            /**
             * Encodes the specified Component message, length delimited. Does not implicitly {@link Form.Component.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Form.Component
             * @static
             * @param {Form.IComponent} message Component message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Component.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Component message from the specified reader or buffer.
             * @function decode
             * @memberof Form.Component
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Form.Component} Component
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Component.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Form.Component();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rows && message.rows.length))
                            message.rows = [];
                        message.rows.push($root.Form.ElementRow.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    case 3:
                        message.idSeparator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Component message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Form.Component
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Form.Component} Component
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Component.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Component message.
             * @function verify
             * @memberof Form.Component
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Component.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.rows != undefined && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (var i = 0; i < message.rows.length; ++i) {
                        var error = $root.Form.ElementRow.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                if (message.id != undefined && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    if (!$util.isString(message.idSeparator))
                        return "idSeparator: string expected";
                return undefined;
            };
    
            /**
             * Creates a Component message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Form.Component
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Form.Component} Component
             */
            Component.fromObject = function fromObject(object) {
                if (object instanceof $root.Form.Component)
                    return object;
                var message = new $root.Form.Component();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".Form.Component.rows: array expected");
                    message.rows = [];
                    for (var i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".Form.Component.rows: object expected");
                        message.rows[i] = $root.Form.ElementRow.fromObject(object.rows[i]);
                    }
                }
                if (object.id != undefined)
                    message.id = String(object.id);
                if (object.idSeparator != undefined)
                    message.idSeparator = String(object.idSeparator);
                return message;
            };
    
            /**
             * Creates a plain object from a Component message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Form.Component
             * @static
             * @param {Form.Component} message Component
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Component.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults) {
                    object.id = "";
                    object.idSeparator = "";
                }
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (var j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.Form.ElementRow.toObject(message.rows[j], options);
                }
                if (message.id != undefined && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    object.idSeparator = message.idSeparator;
                return object;
            };
    
            /**
             * Converts this Component to JSON.
             * @function toJSON
             * @memberof Form.Component
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Component.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Component;
        })();
    
        Form.Element = (function() {
    
            /**
             * Properties of an Element.
             * @memberof Form
             * @interface IElement
             * @property {string|undefined} [id] @see Form.id
             * @property {string|undefined} [label] Title/label.
             * @property {Uint8Array|undefined} [mask] Input mask (serialized with MessagePack).
             * @property {number|undefined} [max] Maximum numerical value.
             * @property {number|undefined} [min] Minimum numerical value.
             * @property {boolean|undefined} [noGrow] Flex nogrow.
             * @property {Array.<string>|undefined} [options] Options to use if type Radio or Select.
             * @property {boolean|undefined} [required] Indicates whether required.
             * @property {Form.Element.Types} type @see Type
             * @property {boolean|undefined} [valueBoolean] Element valueBoolean
             * @property {number|undefined} [valueNumber] Element valueNumber
             * @property {string|undefined} [valueString] Element valueString
             * @property {number|undefined} [width] Flexbox column width (as a percentage of the total row width).
             */
    
            /**
             * Constructs a new Element.
             * @memberof Form
             * @classdesc One element of a Form, and one column of an ElementRow.
             * @implements IElement
             * @constructor
             * @param {Form.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                this.options = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see Form.id
             * @member {string} id
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.id = "";
    
            /**
             * Title/label.
             * @member {string} label
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.label = "";
    
            /**
             * Input mask (serialized with MessagePack).
             * @member {Uint8Array} mask
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.mask = $util.newBuffer([]);
    
            /**
             * Maximum numerical value.
             * @member {number} max
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.max = 0;
    
            /**
             * Minimum numerical value.
             * @member {number} min
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.min = 0;
    
            /**
             * Flex nogrow.
             * @member {boolean} noGrow
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.noGrow = false;
    
            /**
             * Options to use if type Radio or Select.
             * @member {Array.<string>} options
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.options = $util.emptyArray;
    
            /**
             * Indicates whether required.
             * @member {boolean} required
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.required = false;
    
            /**
             * @see Type
             * @member {Form.Element.Types} type
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.type = 0;
    
            /**
             * Element valueBoolean.
             * @member {boolean} valueBoolean
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.valueBoolean = false;
    
            /**
             * Element valueNumber.
             * @member {number} valueNumber
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.valueNumber = 0;
    
            /**
             * Element valueString.
             * @member {string} valueString
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.valueString = "";
    
            /**
             * Flexbox column width (as a percentage of the total row width).
             * @member {number} width
             * @memberof Form.Element
             * @instance
             */
            Element.prototype.width = 0;
    
            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;
    
            /**
             * Value.
             * @member {"valueBoolean"|"valueNumber"|"valueString"|undefined} value
             * @memberof Form.Element
             * @instance
             */
            Object.defineProperty(Element.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["valueBoolean", "valueNumber", "valueString"]),
                set: $util.oneOfSetter($oneOfFields)
            });
    
            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof Form.Element
             * @static
             * @param {Form.IElement=} [properties] Properties to set
             * @returns {Form.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };
    
            /**
             * Encodes the specified Element message. Does not implicitly {@link Form.Element.verify|verify} messages.
             * @function encode
             * @memberof Form.Element
             * @static
             * @param {Form.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != undefined && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.label != undefined && message.hasOwnProperty("label"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.label);
                if (message.mask != undefined && message.hasOwnProperty("mask"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.mask);
                if (message.max != undefined && message.hasOwnProperty("max"))
                    writer.uint32(/* id 4, wireType 1 =*/33).double(message.max);
                if (message.min != undefined && message.hasOwnProperty("min"))
                    writer.uint32(/* id 5, wireType 1 =*/41).double(message.min);
                if (message.noGrow != undefined && message.hasOwnProperty("noGrow"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.noGrow);
                if (message.options != undefined && message.options.length)
                    for (var i = 0; i < message.options.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.options[i]);
                if (message.required != undefined && message.hasOwnProperty("required"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.required);
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.type);
                if (message.valueBoolean != undefined && message.hasOwnProperty("valueBoolean"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.valueBoolean);
                if (message.valueNumber != undefined && message.hasOwnProperty("valueNumber"))
                    writer.uint32(/* id 11, wireType 1 =*/89).double(message.valueNumber);
                if (message.valueString != undefined && message.hasOwnProperty("valueString"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.valueString);
                if (message.width != undefined && message.hasOwnProperty("width"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint32(message.width);
                return writer;
            };
    
            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link Form.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Form.Element
             * @static
             * @param {Form.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof Form.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Form.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Form.Element();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.label = reader.string();
                        break;
                    case 3:
                        message.mask = reader.bytes();
                        break;
                    case 4:
                        message.max = reader.double();
                        break;
                    case 5:
                        message.min = reader.double();
                        break;
                    case 6:
                        message.noGrow = reader.bool();
                        break;
                    case 7:
                        if (!(message.options && message.options.length))
                            message.options = [];
                        message.options.push(reader.string());
                        break;
                    case 8:
                        message.required = reader.bool();
                        break;
                    case 9:
                        message.type = reader.int32();
                        break;
                    case 10:
                        message.valueBoolean = reader.bool();
                        break;
                    case 11:
                        message.valueNumber = reader.double();
                        break;
                    case 12:
                        message.valueString = reader.string();
                        break;
                    case 13:
                        message.width = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("type"))
                    throw $util.ProtocolError("missing required 'type'", { instance: message });
                return message;
            };
    
            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Form.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Form.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Element message.
             * @function verify
             * @memberof Form.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                var properties = {};
                if (message.id != undefined && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.label != undefined && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.mask != undefined && message.hasOwnProperty("mask"))
                    if (!(message.mask && typeof message.mask.length === "number" || $util.isString(message.mask)))
                        return "mask: buffer expected";
                if (message.max != undefined && message.hasOwnProperty("max"))
                    if (typeof message.max !== "number")
                        return "max: number expected";
                if (message.min != undefined && message.hasOwnProperty("min"))
                    if (typeof message.min !== "number")
                        return "min: number expected";
                if (message.noGrow != undefined && message.hasOwnProperty("noGrow"))
                    if (typeof message.noGrow !== "boolean")
                        return "noGrow: boolean expected";
                if (message.options != undefined && message.hasOwnProperty("options")) {
                    if (!Array.isArray(message.options))
                        return "options: array expected";
                    for (var i = 0; i < message.options.length; ++i)
                        if (!$util.isString(message.options[i]))
                            return "options: string[] expected";
                }
                if (message.required != undefined && message.hasOwnProperty("required"))
                    if (typeof message.required !== "boolean")
                        return "required: boolean expected";
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                    break;
                }
                if (message.valueBoolean != undefined && message.hasOwnProperty("valueBoolean")) {
                    properties.value = 1;
                    if (typeof message.valueBoolean !== "boolean")
                        return "valueBoolean: boolean expected";
                }
                if (message.valueNumber != undefined && message.hasOwnProperty("valueNumber")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.valueNumber !== "number")
                        return "valueNumber: number expected";
                }
                if (message.valueString != undefined && message.hasOwnProperty("valueString")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isString(message.valueString))
                        return "valueString: string expected";
                }
                if (message.width != undefined && message.hasOwnProperty("width"))
                    if (!$util.isInteger(message.width))
                        return "width: integer expected";
                return undefined;
            };
    
            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Form.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Form.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.Form.Element)
                    return object;
                var message = new $root.Form.Element();
                if (object.id != undefined)
                    message.id = String(object.id);
                if (object.label != undefined)
                    message.label = String(object.label);
                if (object.mask != undefined)
                    if (typeof object.mask === "string")
                        $util.base64.decode(object.mask, message.mask = $util.newBuffer($util.base64.length(object.mask)), 0);
                    else if (object.mask.length)
                        message.mask = object.mask;
                if (object.max != undefined)
                    message.max = Number(object.max);
                if (object.min != undefined)
                    message.min = Number(object.min);
                if (object.noGrow != undefined)
                    message.noGrow = Boolean(object.noGrow);
                if (object.options) {
                    if (!Array.isArray(object.options))
                        throw TypeError(".Form.Element.options: array expected");
                    message.options = [];
                    for (var i = 0; i < object.options.length; ++i)
                        message.options[i] = String(object.options[i]);
                }
                if (object.required != undefined)
                    message.required = Boolean(object.required);
                switch (object.type) {
                case "Text":
                case 0:
                    message.type = 0;
                    break;
                case "Checkbox":
                case 1:
                    message.type = 1;
                    break;
                case "Datepicker":
                case 2:
                    message.type = 2;
                    break;
                case "Email":
                case 3:
                    message.type = 3;
                    break;
                case "Input":
                case 4:
                    message.type = 4;
                    break;
                case "Number":
                case 5:
                    message.type = 5;
                    break;
                case "Password":
                case 6:
                    message.type = 6;
                    break;
                case "Radio":
                case 7:
                    message.type = 7;
                    break;
                case "Select":
                case 8:
                    message.type = 8;
                    break;
                case "Slider":
                case 9:
                    message.type = 9;
                    break;
                case "SlideToggle":
                case 10:
                    message.type = 10;
                    break;
                case "Textarea":
                case 11:
                    message.type = 11;
                    break;
                case "Time":
                case 12:
                    message.type = 12;
                    break;
                case "URL":
                case 13:
                    message.type = 13;
                    break;
                }
                if (object.valueBoolean != undefined)
                    message.valueBoolean = Boolean(object.valueBoolean);
                if (object.valueNumber != undefined)
                    message.valueNumber = Number(object.valueNumber);
                if (object.valueString != undefined)
                    message.valueString = String(object.valueString);
                if (object.width != undefined)
                    message.width = object.width >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Form.Element
             * @static
             * @param {Form.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.options = [];
                if (options.defaults) {
                    object.id = "";
                    object.label = "";
                    object.mask = options.bytes === String ? "" : [];
                    object.max = 0;
                    object.min = 0;
                    object.noGrow = false;
                    object.required = false;
                    object.type = options.enums === String ? "Text" : 0;
                    object.width = 0;
                }
                if (message.id != undefined && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.label != undefined && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.mask != undefined && message.hasOwnProperty("mask"))
                    object.mask = options.bytes === String ? $util.base64.encode(message.mask, 0, message.mask.length) : options.bytes === Array ? Array.prototype.slice.call(message.mask) : message.mask;
                if (message.max != undefined && message.hasOwnProperty("max"))
                    object.max = options.json && !isFinite(message.max) ? String(message.max) : message.max;
                if (message.min != undefined && message.hasOwnProperty("min"))
                    object.min = options.json && !isFinite(message.min) ? String(message.min) : message.min;
                if (message.noGrow != undefined && message.hasOwnProperty("noGrow"))
                    object.noGrow = message.noGrow;
                if (message.options && message.options.length) {
                    object.options = [];
                    for (var j = 0; j < message.options.length; ++j)
                        object.options[j] = message.options[j];
                }
                if (message.required != undefined && message.hasOwnProperty("required"))
                    object.required = message.required;
                if (message.type != undefined && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.Form.Element.Types[message.type] : message.type;
                if (message.valueBoolean != undefined && message.hasOwnProperty("valueBoolean")) {
                    object.valueBoolean = message.valueBoolean;
                    if (options.oneofs)
                        object.value = "valueBoolean";
                }
                if (message.valueNumber != undefined && message.hasOwnProperty("valueNumber")) {
                    object.valueNumber = options.json && !isFinite(message.valueNumber) ? String(message.valueNumber) : message.valueNumber;
                    if (options.oneofs)
                        object.value = "valueNumber";
                }
                if (message.valueString != undefined && message.hasOwnProperty("valueString")) {
                    object.valueString = message.valueString;
                    if (options.oneofs)
                        object.value = "valueString";
                }
                if (message.width != undefined && message.hasOwnProperty("width"))
                    object.width = message.width;
                return object;
            };
    
            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof Form.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            /**
             * Element input types.
             * @name Form.Element.Types
             * @enum {string}
             * @property {number} Text=0 Text value
             * @property {number} Checkbox=1 Checkbox value
             * @property {number} Datepicker=2 Datepicker value
             * @property {number} Email=3 Email value
             * @property {number} Input=4 Input value
             * @property {number} Number=5 Number value
             * @property {number} Password=6 Password value
             * @property {number} Radio=7 Radio value
             * @property {number} Select=8 Select value
             * @property {number} Slider=9 Slider value
             * @property {number} SlideToggle=10 SlideToggle value
             * @property {number} Textarea=11 Textarea value
             * @property {number} Time=12 Time value
             * @property {number} URL=13 URL value
             */
            Element.Types = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Text"] = 0;
                values[valuesById[1] = "Checkbox"] = 1;
                values[valuesById[2] = "Datepicker"] = 2;
                values[valuesById[3] = "Email"] = 3;
                values[valuesById[4] = "Input"] = 4;
                values[valuesById[5] = "Number"] = 5;
                values[valuesById[6] = "Password"] = 6;
                values[valuesById[7] = "Radio"] = 7;
                values[valuesById[8] = "Select"] = 8;
                values[valuesById[9] = "Slider"] = 9;
                values[valuesById[10] = "SlideToggle"] = 10;
                values[valuesById[11] = "Textarea"] = 11;
                values[valuesById[12] = "Time"] = 12;
                values[valuesById[13] = "URL"] = 13;
                return values;
            })();
    
            return Element;
        })();
    
        Form.ElementRow = (function() {
    
            /**
             * Properties of an ElementRow.
             * @memberof Form
             * @interface IElementRow
             * @property {Array.<Form.IElement>|undefined} [elements] @see Element
             * @property {string|undefined} [id] @see Form.id
             * @property {string|undefined} [idSeparator] @see Component.idSeparator
             */
    
            /**
             * Constructs a new ElementRow.
             * @memberof Form
             * @classdesc Row of elements.
             * @implements IElementRow
             * @constructor
             * @param {Form.IElementRow=} [properties] Properties to set
             */
            function ElementRow(properties) {
                this.elements = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see Element
             * @member {Array.<Form.IElement>} elements
             * @memberof Form.ElementRow
             * @instance
             */
            ElementRow.prototype.elements = $util.emptyArray;
    
            /**
             * @see Form.id
             * @member {string} id
             * @memberof Form.ElementRow
             * @instance
             */
            ElementRow.prototype.id = "";
    
            /**
             * @see Component.idSeparator
             * @member {string} idSeparator
             * @memberof Form.ElementRow
             * @instance
             */
            ElementRow.prototype.idSeparator = "";
    
            /**
             * Creates a new ElementRow instance using the specified properties.
             * @function create
             * @memberof Form.ElementRow
             * @static
             * @param {Form.IElementRow=} [properties] Properties to set
             * @returns {Form.ElementRow} ElementRow instance
             */
            ElementRow.create = function create(properties) {
                return new ElementRow(properties);
            };
    
            /**
             * Encodes the specified ElementRow message. Does not implicitly {@link Form.ElementRow.verify|verify} messages.
             * @function encode
             * @memberof Form.ElementRow
             * @static
             * @param {Form.IElementRow} message ElementRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElementRow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.elements != undefined && message.elements.length)
                    for (var i = 0; i < message.elements.length; ++i)
                        $root.Form.Element.encode(message.elements[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.id != undefined && message.hasOwnProperty("id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.idSeparator);
                return writer;
            };
    
            /**
             * Encodes the specified ElementRow message, length delimited. Does not implicitly {@link Form.ElementRow.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Form.ElementRow
             * @static
             * @param {Form.IElementRow} message ElementRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ElementRow.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an ElementRow message from the specified reader or buffer.
             * @function decode
             * @memberof Form.ElementRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Form.ElementRow} ElementRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElementRow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Form.ElementRow();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.elements && message.elements.length))
                            message.elements = [];
                        message.elements.push($root.Form.Element.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.id = reader.string();
                        break;
                    case 3:
                        message.idSeparator = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an ElementRow message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Form.ElementRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Form.ElementRow} ElementRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ElementRow.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an ElementRow message.
             * @function verify
             * @memberof Form.ElementRow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            ElementRow.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.elements != undefined && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (var i = 0; i < message.elements.length; ++i) {
                        var error = $root.Form.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.id != undefined && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    if (!$util.isString(message.idSeparator))
                        return "idSeparator: string expected";
                return undefined;
            };
    
            /**
             * Creates an ElementRow message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Form.ElementRow
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Form.ElementRow} ElementRow
             */
            ElementRow.fromObject = function fromObject(object) {
                if (object instanceof $root.Form.ElementRow)
                    return object;
                var message = new $root.Form.ElementRow();
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".Form.ElementRow.elements: array expected");
                    message.elements = [];
                    for (var i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".Form.ElementRow.elements: object expected");
                        message.elements[i] = $root.Form.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.id != undefined)
                    message.id = String(object.id);
                if (object.idSeparator != undefined)
                    message.idSeparator = String(object.idSeparator);
                return message;
            };
    
            /**
             * Creates a plain object from an ElementRow message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Form.ElementRow
             * @static
             * @param {Form.ElementRow} message ElementRow
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ElementRow.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.id = "";
                    object.idSeparator = "";
                }
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (var j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.Form.Element.toObject(message.elements[j], options);
                }
                if (message.id != undefined && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.idSeparator != undefined && message.hasOwnProperty("idSeparator"))
                    object.idSeparator = message.idSeparator;
                return object;
            };
    
            /**
             * Converts this ElementRow to JSON.
             * @function toJSON
             * @memberof Form.ElementRow
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ElementRow.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ElementRow;
        })();
    
        return Form;
    })();
    
    $root.KeyPair = (function() {
    
        /**
         * Properties of a KeyPair.
         * @exports IKeyPair
         * @interface IKeyPair
         * @property {Uint8Array} privateKey Private key.
         * @property {Uint8Array} publicKey Public key.
         */
    
        /**
         * Constructs a new KeyPair.
         * @exports KeyPair
         * @classdesc An asymmetric key pair.
         * @implements IKeyPair
         * @constructor
         * @param {IKeyPair=} [properties] Properties to set
         */
        function KeyPair(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Private key.
         * @member {Uint8Array} privateKey
         * @memberof KeyPair
         * @instance
         */
        KeyPair.prototype.privateKey = $util.newBuffer([]);
    
        /**
         * Public key.
         * @member {Uint8Array} publicKey
         * @memberof KeyPair
         * @instance
         */
        KeyPair.prototype.publicKey = $util.newBuffer([]);
    
        /**
         * Creates a new KeyPair instance using the specified properties.
         * @function create
         * @memberof KeyPair
         * @static
         * @param {IKeyPair=} [properties] Properties to set
         * @returns {KeyPair} KeyPair instance
         */
        KeyPair.create = function create(properties) {
            return new KeyPair(properties);
        };
    
        /**
         * Encodes the specified KeyPair message. Does not implicitly {@link KeyPair.verify|verify} messages.
         * @function encode
         * @memberof KeyPair
         * @static
         * @param {IKeyPair} message KeyPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyPair.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.privateKey);
            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
            return writer;
        };
    
        /**
         * Encodes the specified KeyPair message, length delimited. Does not implicitly {@link KeyPair.verify|verify} messages.
         * @function encodeDelimited
         * @memberof KeyPair
         * @static
         * @param {IKeyPair} message KeyPair message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KeyPair.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a KeyPair message from the specified reader or buffer.
         * @function decode
         * @memberof KeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {KeyPair} KeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.KeyPair();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.privateKey = reader.bytes();
                    break;
                case 2:
                    message.publicKey = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("privateKey"))
                throw $util.ProtocolError("missing required 'privateKey'", { instance: message });
            if (!message.hasOwnProperty("publicKey"))
                throw $util.ProtocolError("missing required 'publicKey'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a KeyPair message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof KeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {KeyPair} KeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyPair.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a KeyPair message.
         * @function verify
         * @memberof KeyPair
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        KeyPair.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!(message.privateKey && typeof message.privateKey.length === "number" || $util.isString(message.privateKey)))
                return "privateKey: buffer expected";
            if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                return "publicKey: buffer expected";
            return undefined;
        };
    
        /**
         * Creates a KeyPair message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof KeyPair
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {KeyPair} KeyPair
         */
        KeyPair.fromObject = function fromObject(object) {
            if (object instanceof $root.KeyPair)
                return object;
            var message = new $root.KeyPair();
            if (object.privateKey != undefined)
                if (typeof object.privateKey === "string")
                    $util.base64.decode(object.privateKey, message.privateKey = $util.newBuffer($util.base64.length(object.privateKey)), 0);
                else if (object.privateKey.length)
                    message.privateKey = object.privateKey;
            if (object.publicKey != undefined)
                if (typeof object.publicKey === "string")
                    $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                else if (object.publicKey.length)
                    message.publicKey = object.publicKey;
            return message;
        };
    
        /**
         * Creates a plain object from a KeyPair message. Also converts values to other types if specified.
         * @function toObject
         * @memberof KeyPair
         * @static
         * @param {KeyPair} message KeyPair
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        KeyPair.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.privateKey = options.bytes === String ? "" : [];
                object.publicKey = options.bytes === String ? "" : [];
            }
            if (message.privateKey != undefined && message.hasOwnProperty("privateKey"))
                object.privateKey = options.bytes === String ? $util.base64.encode(message.privateKey, 0, message.privateKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.privateKey) : message.privateKey;
            if (message.publicKey != undefined && message.hasOwnProperty("publicKey"))
                object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
            return object;
        };
    
        /**
         * Converts this KeyPair to JSON.
         * @function toJSON
         * @memberof KeyPair
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        KeyPair.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return KeyPair;
    })();
    
    /**
     * Push notification types.
     * @exports NotificationTypes
     * @enum {string}
     * @property {number} Yo=0 Yo value
     * @property {number} File=1 File value
     * @property {number} Message=2 Message value
     */
    $root.NotificationTypes = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Yo"] = 0;
        values[valuesById[1] = "File"] = 1;
        values[valuesById[2] = "Message"] = 2;
        return values;
    })();
    
    $root.PatientInfo = (function() {
    
        /**
         * Properties of a PatientInfo.
         * @exports IPatientInfo
         * @interface IPatientInfo
         * @property {Object.<string,PatientInfo.IContactAdditionalData>|undefined} [contactAdditionalData] Mapping of contact email addresses to ContactAdditionalData objects.
         * @property {IRedoxPatient|undefined} [redoxPatient] Patient record as synced to/from EHR systems.
         */
    
        /**
         * Constructs a new PatientInfo.
         * @exports PatientInfo
         * @classdesc Patient information for Telehealth.
         * @implements IPatientInfo
         * @constructor
         * @param {IPatientInfo=} [properties] Properties to set
         */
        function PatientInfo(properties) {
            this.contactAdditionalData = {};
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Mapping of contact email addresses to ContactAdditionalData objects.
         * @member {Object.<string,PatientInfo.IContactAdditionalData>} contactAdditionalData
         * @memberof PatientInfo
         * @instance
         */
        PatientInfo.prototype.contactAdditionalData = $util.emptyObject;
    
        /**
         * Patient record as synced to/from EHR systems.
         * @member {IRedoxPatient|undefined|undefined} redoxPatient
         * @memberof PatientInfo
         * @instance
         */
        PatientInfo.prototype.redoxPatient = undefined;
    
        /**
         * Creates a new PatientInfo instance using the specified properties.
         * @function create
         * @memberof PatientInfo
         * @static
         * @param {IPatientInfo=} [properties] Properties to set
         * @returns {PatientInfo} PatientInfo instance
         */
        PatientInfo.create = function create(properties) {
            return new PatientInfo(properties);
        };
    
        /**
         * Encodes the specified PatientInfo message. Does not implicitly {@link PatientInfo.verify|verify} messages.
         * @function encode
         * @memberof PatientInfo
         * @static
         * @param {IPatientInfo} message PatientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatientInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contactAdditionalData != undefined && message.hasOwnProperty("contactAdditionalData"))
                for (var keys = Object.keys(message.contactAdditionalData), i = 0; i < keys.length; ++i) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                    $root.PatientInfo.ContactAdditionalData.encode(message.contactAdditionalData[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                }
            if (message.redoxPatient != undefined && message.hasOwnProperty("redoxPatient"))
                $root.RedoxPatient.encode(message.redoxPatient, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified PatientInfo message, length delimited. Does not implicitly {@link PatientInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PatientInfo
         * @static
         * @param {IPatientInfo} message PatientInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatientInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a PatientInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PatientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PatientInfo} PatientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatientInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PatientInfo(), key;
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.contactAdditionalData === $util.emptyObject)
                        message.contactAdditionalData = {};
                    key = reader.string();
                    reader.pos++;
                    message.contactAdditionalData[key] = $root.PatientInfo.ContactAdditionalData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.redoxPatient = $root.RedoxPatient.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a PatientInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PatientInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PatientInfo} PatientInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatientInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a PatientInfo message.
         * @function verify
         * @memberof PatientInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        PatientInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.contactAdditionalData != undefined && message.hasOwnProperty("contactAdditionalData")) {
                if (!$util.isObject(message.contactAdditionalData))
                    return "contactAdditionalData: object expected";
                var key = Object.keys(message.contactAdditionalData);
                for (var i = 0; i < key.length; ++i) {
                    var error = $root.PatientInfo.ContactAdditionalData.verify(message.contactAdditionalData[key[i]]);
                    if (error)
                        return "contactAdditionalData." + error;
                }
            }
            if (message.redoxPatient != undefined && message.hasOwnProperty("redoxPatient")) {
                var error = $root.RedoxPatient.verify(message.redoxPatient);
                if (error)
                    return "redoxPatient." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a PatientInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PatientInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PatientInfo} PatientInfo
         */
        PatientInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PatientInfo)
                return object;
            var message = new $root.PatientInfo();
            if (object.contactAdditionalData) {
                if (typeof object.contactAdditionalData !== "object")
                    throw TypeError(".PatientInfo.contactAdditionalData: object expected");
                message.contactAdditionalData = {};
                for (var keys = Object.keys(object.contactAdditionalData), i = 0; i < keys.length; ++i) {
                    if (typeof object.contactAdditionalData[keys[i]] !== "object")
                        throw TypeError(".PatientInfo.contactAdditionalData: object expected");
                    message.contactAdditionalData[keys[i]] = $root.PatientInfo.ContactAdditionalData.fromObject(object.contactAdditionalData[keys[i]]);
                }
            }
            if (object.redoxPatient != undefined) {
                if (typeof object.redoxPatient !== "object")
                    throw TypeError(".PatientInfo.redoxPatient: object expected");
                message.redoxPatient = $root.RedoxPatient.fromObject(object.redoxPatient);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a PatientInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PatientInfo
         * @static
         * @param {PatientInfo} message PatientInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PatientInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.objects || options.defaults)
                object.contactAdditionalData = {};
            if (options.defaults)
                object.redoxPatient = undefined;
            var keys2;
            if (message.contactAdditionalData && (keys2 = Object.keys(message.contactAdditionalData)).length) {
                object.contactAdditionalData = {};
                for (var j = 0; j < keys2.length; ++j)
                    object.contactAdditionalData[keys2[j]] = $root.PatientInfo.ContactAdditionalData.toObject(message.contactAdditionalData[keys2[j]], options);
            }
            if (message.redoxPatient != undefined && message.hasOwnProperty("redoxPatient"))
                object.redoxPatient = $root.RedoxPatient.toObject(message.redoxPatient, options);
            return object;
        };
    
        /**
         * Converts this PatientInfo to JSON.
         * @function toJSON
         * @memberof PatientInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PatientInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        PatientInfo.ContactAdditionalData = (function() {
    
            /**
             * Properties of a ContactAdditionalData.
             * @memberof PatientInfo
             * @interface IContactAdditionalData
             * @property {boolean|undefined} [consentToShare] Whether there is consent to share medical information with the contact.
             * @property {string|undefined} [cyphAccount] Cyph username for the contact if they have one.
             */
    
            /**
             * Constructs a new ContactAdditionalData.
             * @memberof PatientInfo
             * @classdesc Additional data for a contact.
             * @implements IContactAdditionalData
             * @constructor
             * @param {PatientInfo.IContactAdditionalData=} [properties] Properties to set
             */
            function ContactAdditionalData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Whether there is consent to share medical information with the contact.
             * @member {boolean} consentToShare
             * @memberof PatientInfo.ContactAdditionalData
             * @instance
             */
            ContactAdditionalData.prototype.consentToShare = false;
    
            /**
             * Cyph username for the contact if they have one.
             * @member {string} cyphAccount
             * @memberof PatientInfo.ContactAdditionalData
             * @instance
             */
            ContactAdditionalData.prototype.cyphAccount = "";
    
            /**
             * Creates a new ContactAdditionalData instance using the specified properties.
             * @function create
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {PatientInfo.IContactAdditionalData=} [properties] Properties to set
             * @returns {PatientInfo.ContactAdditionalData} ContactAdditionalData instance
             */
            ContactAdditionalData.create = function create(properties) {
                return new ContactAdditionalData(properties);
            };
    
            /**
             * Encodes the specified ContactAdditionalData message. Does not implicitly {@link PatientInfo.ContactAdditionalData.verify|verify} messages.
             * @function encode
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {PatientInfo.IContactAdditionalData} message ContactAdditionalData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactAdditionalData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.consentToShare != undefined && message.hasOwnProperty("consentToShare"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.consentToShare);
                if (message.cyphAccount != undefined && message.hasOwnProperty("cyphAccount"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cyphAccount);
                return writer;
            };
    
            /**
             * Encodes the specified ContactAdditionalData message, length delimited. Does not implicitly {@link PatientInfo.ContactAdditionalData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {PatientInfo.IContactAdditionalData} message ContactAdditionalData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactAdditionalData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a ContactAdditionalData message from the specified reader or buffer.
             * @function decode
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {PatientInfo.ContactAdditionalData} ContactAdditionalData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactAdditionalData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.PatientInfo.ContactAdditionalData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.consentToShare = reader.bool();
                        break;
                    case 2:
                        message.cyphAccount = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a ContactAdditionalData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {PatientInfo.ContactAdditionalData} ContactAdditionalData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactAdditionalData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a ContactAdditionalData message.
             * @function verify
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            ContactAdditionalData.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.consentToShare != undefined && message.hasOwnProperty("consentToShare"))
                    if (typeof message.consentToShare !== "boolean")
                        return "consentToShare: boolean expected";
                if (message.cyphAccount != undefined && message.hasOwnProperty("cyphAccount"))
                    if (!$util.isString(message.cyphAccount))
                        return "cyphAccount: string expected";
                return undefined;
            };
    
            /**
             * Creates a ContactAdditionalData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {PatientInfo.ContactAdditionalData} ContactAdditionalData
             */
            ContactAdditionalData.fromObject = function fromObject(object) {
                if (object instanceof $root.PatientInfo.ContactAdditionalData)
                    return object;
                var message = new $root.PatientInfo.ContactAdditionalData();
                if (object.consentToShare != undefined)
                    message.consentToShare = Boolean(object.consentToShare);
                if (object.cyphAccount != undefined)
                    message.cyphAccount = String(object.cyphAccount);
                return message;
            };
    
            /**
             * Creates a plain object from a ContactAdditionalData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof PatientInfo.ContactAdditionalData
             * @static
             * @param {PatientInfo.ContactAdditionalData} message ContactAdditionalData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactAdditionalData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.consentToShare = false;
                    object.cyphAccount = "";
                }
                if (message.consentToShare != undefined && message.hasOwnProperty("consentToShare"))
                    object.consentToShare = message.consentToShare;
                if (message.cyphAccount != undefined && message.hasOwnProperty("cyphAccount"))
                    object.cyphAccount = message.cyphAccount;
                return object;
            };
    
            /**
             * Converts this ContactAdditionalData to JSON.
             * @function toJSON
             * @memberof PatientInfo.ContactAdditionalData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactAdditionalData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return ContactAdditionalData;
        })();
    
        return PatientInfo;
    })();
    
    $root.RedoxAppointment = (function() {
    
        /**
         * Properties of a RedoxAppointment.
         * @exports IRedoxAppointment
         * @interface IRedoxAppointment
         * @property {Array.<RedoxTypes.IAppointmentInfo>|undefined} [AppointmentInfo] @see RedoxTypes.AppointmentInfo
         * @property {RedoxAppointment.IPatientType|undefined} [Patient] @see PatientType
         * @property {Array.<RedoxTypes.IVisit>|undefined} [Visit] @see RedoxTypes.Visit
         */
    
        /**
         * Constructs a new RedoxAppointment.
         * @exports RedoxAppointment
         * @classdesc @see https://developer.redoxengine.com/data-models/Scheduling.html#New
         * @implements IRedoxAppointment
         * @constructor
         * @param {IRedoxAppointment=} [properties] Properties to set
         */
        function RedoxAppointment(properties) {
            this.AppointmentInfo = [];
            this.Visit = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see RedoxTypes.AppointmentInfo
         * @member {Array.<RedoxTypes.IAppointmentInfo>} AppointmentInfo
         * @memberof RedoxAppointment
         * @instance
         */
        RedoxAppointment.prototype.AppointmentInfo = $util.emptyArray;
    
        /**
         * @see PatientType
         * @member {RedoxAppointment.IPatientType|undefined|undefined} Patient
         * @memberof RedoxAppointment
         * @instance
         */
        RedoxAppointment.prototype.Patient = undefined;
    
        /**
         * @see RedoxTypes.Visit
         * @member {Array.<RedoxTypes.IVisit>} Visit
         * @memberof RedoxAppointment
         * @instance
         */
        RedoxAppointment.prototype.Visit = $util.emptyArray;
    
        /**
         * Creates a new RedoxAppointment instance using the specified properties.
         * @function create
         * @memberof RedoxAppointment
         * @static
         * @param {IRedoxAppointment=} [properties] Properties to set
         * @returns {RedoxAppointment} RedoxAppointment instance
         */
        RedoxAppointment.create = function create(properties) {
            return new RedoxAppointment(properties);
        };
    
        /**
         * Encodes the specified RedoxAppointment message. Does not implicitly {@link RedoxAppointment.verify|verify} messages.
         * @function encode
         * @memberof RedoxAppointment
         * @static
         * @param {IRedoxAppointment} message RedoxAppointment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxAppointment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AppointmentInfo != undefined && message.AppointmentInfo.length)
                for (var i = 0; i < message.AppointmentInfo.length; ++i)
                    $root.RedoxTypes.AppointmentInfo.encode(message.AppointmentInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Patient != undefined && message.hasOwnProperty("Patient"))
                $root.RedoxAppointment.PatientType.encode(message.Patient, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Visit != undefined && message.Visit.length)
                for (var i = 0; i < message.Visit.length; ++i)
                    $root.RedoxTypes.Visit.encode(message.Visit[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified RedoxAppointment message, length delimited. Does not implicitly {@link RedoxAppointment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RedoxAppointment
         * @static
         * @param {IRedoxAppointment} message RedoxAppointment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxAppointment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RedoxAppointment message from the specified reader or buffer.
         * @function decode
         * @memberof RedoxAppointment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedoxAppointment} RedoxAppointment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxAppointment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxAppointment();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.AppointmentInfo && message.AppointmentInfo.length))
                        message.AppointmentInfo = [];
                    message.AppointmentInfo.push($root.RedoxTypes.AppointmentInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.Patient = $root.RedoxAppointment.PatientType.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.Visit && message.Visit.length))
                        message.Visit = [];
                    message.Visit.push($root.RedoxTypes.Visit.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RedoxAppointment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedoxAppointment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedoxAppointment} RedoxAppointment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxAppointment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RedoxAppointment message.
         * @function verify
         * @memberof RedoxAppointment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        RedoxAppointment.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.AppointmentInfo != undefined && message.hasOwnProperty("AppointmentInfo")) {
                if (!Array.isArray(message.AppointmentInfo))
                    return "AppointmentInfo: array expected";
                for (var i = 0; i < message.AppointmentInfo.length; ++i) {
                    var error = $root.RedoxTypes.AppointmentInfo.verify(message.AppointmentInfo[i]);
                    if (error)
                        return "AppointmentInfo." + error;
                }
            }
            if (message.Patient != undefined && message.hasOwnProperty("Patient")) {
                var error = $root.RedoxAppointment.PatientType.verify(message.Patient);
                if (error)
                    return "Patient." + error;
            }
            if (message.Visit != undefined && message.hasOwnProperty("Visit")) {
                if (!Array.isArray(message.Visit))
                    return "Visit: array expected";
                for (var i = 0; i < message.Visit.length; ++i) {
                    var error = $root.RedoxTypes.Visit.verify(message.Visit[i]);
                    if (error)
                        return "Visit." + error;
                }
            }
            return undefined;
        };
    
        /**
         * Creates a RedoxAppointment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RedoxAppointment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RedoxAppointment} RedoxAppointment
         */
        RedoxAppointment.fromObject = function fromObject(object) {
            if (object instanceof $root.RedoxAppointment)
                return object;
            var message = new $root.RedoxAppointment();
            if (object.AppointmentInfo) {
                if (!Array.isArray(object.AppointmentInfo))
                    throw TypeError(".RedoxAppointment.AppointmentInfo: array expected");
                message.AppointmentInfo = [];
                for (var i = 0; i < object.AppointmentInfo.length; ++i) {
                    if (typeof object.AppointmentInfo[i] !== "object")
                        throw TypeError(".RedoxAppointment.AppointmentInfo: object expected");
                    message.AppointmentInfo[i] = $root.RedoxTypes.AppointmentInfo.fromObject(object.AppointmentInfo[i]);
                }
            }
            if (object.Patient != undefined) {
                if (typeof object.Patient !== "object")
                    throw TypeError(".RedoxAppointment.Patient: object expected");
                message.Patient = $root.RedoxAppointment.PatientType.fromObject(object.Patient);
            }
            if (object.Visit) {
                if (!Array.isArray(object.Visit))
                    throw TypeError(".RedoxAppointment.Visit: array expected");
                message.Visit = [];
                for (var i = 0; i < object.Visit.length; ++i) {
                    if (typeof object.Visit[i] !== "object")
                        throw TypeError(".RedoxAppointment.Visit: object expected");
                    message.Visit[i] = $root.RedoxTypes.Visit.fromObject(object.Visit[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a RedoxAppointment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RedoxAppointment
         * @static
         * @param {RedoxAppointment} message RedoxAppointment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoxAppointment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.AppointmentInfo = [];
                object.Visit = [];
            }
            if (options.defaults)
                object.Patient = undefined;
            if (message.AppointmentInfo && message.AppointmentInfo.length) {
                object.AppointmentInfo = [];
                for (var j = 0; j < message.AppointmentInfo.length; ++j)
                    object.AppointmentInfo[j] = $root.RedoxTypes.AppointmentInfo.toObject(message.AppointmentInfo[j], options);
            }
            if (message.Patient != undefined && message.hasOwnProperty("Patient"))
                object.Patient = $root.RedoxAppointment.PatientType.toObject(message.Patient, options);
            if (message.Visit && message.Visit.length) {
                object.Visit = [];
                for (var j = 0; j < message.Visit.length; ++j)
                    object.Visit[j] = $root.RedoxTypes.Visit.toObject(message.Visit[j], options);
            }
            return object;
        };
    
        /**
         * Converts this RedoxAppointment to JSON.
         * @function toJSON
         * @memberof RedoxAppointment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoxAppointment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        RedoxAppointment.PatientType = (function() {
    
            /**
             * Properties of a PatientType.
             * @memberof RedoxAppointment
             * @interface IPatientType
             * @property {RedoxTypes.IDemographics|undefined} [Demographics] @see RedoxPatient.Demographics
             * @property {Array.<RedoxTypes.IIdentifier>|undefined} [Identifiers] @see RedoxPatient.Identifiers
             * @property {Array.<string>|undefined} [Notes] @see RedoxPatient.Notes
             */
    
            /**
             * Constructs a new PatientType.
             * @memberof RedoxAppointment
             * @classdesc Patient data.
             * @implements IPatientType
             * @constructor
             * @param {RedoxAppointment.IPatientType=} [properties] Properties to set
             */
            function PatientType(properties) {
                this.Identifiers = [];
                this.Notes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see RedoxPatient.Demographics
             * @member {RedoxTypes.IDemographics|undefined|undefined} Demographics
             * @memberof RedoxAppointment.PatientType
             * @instance
             */
            PatientType.prototype.Demographics = undefined;
    
            /**
             * @see RedoxPatient.Identifiers
             * @member {Array.<RedoxTypes.IIdentifier>} Identifiers
             * @memberof RedoxAppointment.PatientType
             * @instance
             */
            PatientType.prototype.Identifiers = $util.emptyArray;
    
            /**
             * @see RedoxPatient.Notes
             * @member {Array.<string>} Notes
             * @memberof RedoxAppointment.PatientType
             * @instance
             */
            PatientType.prototype.Notes = $util.emptyArray;
    
            /**
             * Creates a new PatientType instance using the specified properties.
             * @function create
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {RedoxAppointment.IPatientType=} [properties] Properties to set
             * @returns {RedoxAppointment.PatientType} PatientType instance
             */
            PatientType.create = function create(properties) {
                return new PatientType(properties);
            };
    
            /**
             * Encodes the specified PatientType message. Does not implicitly {@link RedoxAppointment.PatientType.verify|verify} messages.
             * @function encode
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {RedoxAppointment.IPatientType} message PatientType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PatientType.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Demographics != undefined && message.hasOwnProperty("Demographics"))
                    $root.RedoxTypes.Demographics.encode(message.Demographics, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Identifiers != undefined && message.Identifiers.length)
                    for (var i = 0; i < message.Identifiers.length; ++i)
                        $root.RedoxTypes.Identifier.encode(message.Identifiers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.Notes != undefined && message.Notes.length)
                    for (var i = 0; i < message.Notes.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Notes[i]);
                return writer;
            };
    
            /**
             * Encodes the specified PatientType message, length delimited. Does not implicitly {@link RedoxAppointment.PatientType.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {RedoxAppointment.IPatientType} message PatientType message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PatientType.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PatientType message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxAppointment.PatientType} PatientType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PatientType.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxAppointment.PatientType();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Demographics = $root.RedoxTypes.Demographics.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.Identifiers && message.Identifiers.length))
                            message.Identifiers = [];
                        message.Identifiers.push($root.RedoxTypes.Identifier.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.Notes && message.Notes.length))
                            message.Notes = [];
                        message.Notes.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PatientType message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxAppointment.PatientType} PatientType
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PatientType.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PatientType message.
             * @function verify
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            PatientType.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Demographics != undefined && message.hasOwnProperty("Demographics")) {
                    var error = $root.RedoxTypes.Demographics.verify(message.Demographics);
                    if (error)
                        return "Demographics." + error;
                }
                if (message.Identifiers != undefined && message.hasOwnProperty("Identifiers")) {
                    if (!Array.isArray(message.Identifiers))
                        return "Identifiers: array expected";
                    for (var i = 0; i < message.Identifiers.length; ++i) {
                        var error = $root.RedoxTypes.Identifier.verify(message.Identifiers[i]);
                        if (error)
                            return "Identifiers." + error;
                    }
                }
                if (message.Notes != undefined && message.hasOwnProperty("Notes")) {
                    if (!Array.isArray(message.Notes))
                        return "Notes: array expected";
                    for (var i = 0; i < message.Notes.length; ++i)
                        if (!$util.isString(message.Notes[i]))
                            return "Notes: string[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a PatientType message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxAppointment.PatientType} PatientType
             */
            PatientType.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxAppointment.PatientType)
                    return object;
                var message = new $root.RedoxAppointment.PatientType();
                if (object.Demographics != undefined) {
                    if (typeof object.Demographics !== "object")
                        throw TypeError(".RedoxAppointment.PatientType.Demographics: object expected");
                    message.Demographics = $root.RedoxTypes.Demographics.fromObject(object.Demographics);
                }
                if (object.Identifiers) {
                    if (!Array.isArray(object.Identifiers))
                        throw TypeError(".RedoxAppointment.PatientType.Identifiers: array expected");
                    message.Identifiers = [];
                    for (var i = 0; i < object.Identifiers.length; ++i) {
                        if (typeof object.Identifiers[i] !== "object")
                            throw TypeError(".RedoxAppointment.PatientType.Identifiers: object expected");
                        message.Identifiers[i] = $root.RedoxTypes.Identifier.fromObject(object.Identifiers[i]);
                    }
                }
                if (object.Notes) {
                    if (!Array.isArray(object.Notes))
                        throw TypeError(".RedoxAppointment.PatientType.Notes: array expected");
                    message.Notes = [];
                    for (var i = 0; i < object.Notes.length; ++i)
                        message.Notes[i] = String(object.Notes[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PatientType message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxAppointment.PatientType
             * @static
             * @param {RedoxAppointment.PatientType} message PatientType
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PatientType.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.Identifiers = [];
                    object.Notes = [];
                }
                if (options.defaults)
                    object.Demographics = undefined;
                if (message.Demographics != undefined && message.hasOwnProperty("Demographics"))
                    object.Demographics = $root.RedoxTypes.Demographics.toObject(message.Demographics, options);
                if (message.Identifiers && message.Identifiers.length) {
                    object.Identifiers = [];
                    for (var j = 0; j < message.Identifiers.length; ++j)
                        object.Identifiers[j] = $root.RedoxTypes.Identifier.toObject(message.Identifiers[j], options);
                }
                if (message.Notes && message.Notes.length) {
                    object.Notes = [];
                    for (var j = 0; j < message.Notes.length; ++j)
                        object.Notes[j] = message.Notes[j];
                }
                return object;
            };
    
            /**
             * Converts this PatientType to JSON.
             * @function toJSON
             * @memberof RedoxAppointment.PatientType
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PatientType.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PatientType;
        })();
    
        return RedoxAppointment;
    })();
    
    $root.RedoxClinicalSummary = (function() {
    
        /**
         * Properties of a RedoxClinicalSummary.
         * @exports IRedoxClinicalSummary
         * @interface IRedoxClinicalSummary
         * @property {Array.<RedoxTypes.IAllergy>|undefined} [allergies] List of patient's allergies.
         */
    
        /**
         * Constructs a new RedoxClinicalSummary.
         * @exports RedoxClinicalSummary
         * @classdesc @see https://developer.redoxengine.com/data-models/ClinicalSummary.html#PatientQueryResponse
         * TODO: Finish this.
         * @implements IRedoxClinicalSummary
         * @constructor
         * @param {IRedoxClinicalSummary=} [properties] Properties to set
         */
        function RedoxClinicalSummary(properties) {
            this.allergies = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * List of patient's allergies.
         * @member {Array.<RedoxTypes.IAllergy>} allergies
         * @memberof RedoxClinicalSummary
         * @instance
         */
        RedoxClinicalSummary.prototype.allergies = $util.emptyArray;
    
        /**
         * Creates a new RedoxClinicalSummary instance using the specified properties.
         * @function create
         * @memberof RedoxClinicalSummary
         * @static
         * @param {IRedoxClinicalSummary=} [properties] Properties to set
         * @returns {RedoxClinicalSummary} RedoxClinicalSummary instance
         */
        RedoxClinicalSummary.create = function create(properties) {
            return new RedoxClinicalSummary(properties);
        };
    
        /**
         * Encodes the specified RedoxClinicalSummary message. Does not implicitly {@link RedoxClinicalSummary.verify|verify} messages.
         * @function encode
         * @memberof RedoxClinicalSummary
         * @static
         * @param {IRedoxClinicalSummary} message RedoxClinicalSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxClinicalSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.allergies != undefined && message.allergies.length)
                for (var i = 0; i < message.allergies.length; ++i)
                    $root.RedoxTypes.Allergy.encode(message.allergies[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified RedoxClinicalSummary message, length delimited. Does not implicitly {@link RedoxClinicalSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RedoxClinicalSummary
         * @static
         * @param {IRedoxClinicalSummary} message RedoxClinicalSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxClinicalSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RedoxClinicalSummary message from the specified reader or buffer.
         * @function decode
         * @memberof RedoxClinicalSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedoxClinicalSummary} RedoxClinicalSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxClinicalSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxClinicalSummary();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.allergies && message.allergies.length))
                        message.allergies = [];
                    message.allergies.push($root.RedoxTypes.Allergy.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RedoxClinicalSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedoxClinicalSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedoxClinicalSummary} RedoxClinicalSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxClinicalSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RedoxClinicalSummary message.
         * @function verify
         * @memberof RedoxClinicalSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        RedoxClinicalSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.allergies != undefined && message.hasOwnProperty("allergies")) {
                if (!Array.isArray(message.allergies))
                    return "allergies: array expected";
                for (var i = 0; i < message.allergies.length; ++i) {
                    var error = $root.RedoxTypes.Allergy.verify(message.allergies[i]);
                    if (error)
                        return "allergies." + error;
                }
            }
            return undefined;
        };
    
        /**
         * Creates a RedoxClinicalSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RedoxClinicalSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RedoxClinicalSummary} RedoxClinicalSummary
         */
        RedoxClinicalSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.RedoxClinicalSummary)
                return object;
            var message = new $root.RedoxClinicalSummary();
            if (object.allergies) {
                if (!Array.isArray(object.allergies))
                    throw TypeError(".RedoxClinicalSummary.allergies: array expected");
                message.allergies = [];
                for (var i = 0; i < object.allergies.length; ++i) {
                    if (typeof object.allergies[i] !== "object")
                        throw TypeError(".RedoxClinicalSummary.allergies: object expected");
                    message.allergies[i] = $root.RedoxTypes.Allergy.fromObject(object.allergies[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a RedoxClinicalSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RedoxClinicalSummary
         * @static
         * @param {RedoxClinicalSummary} message RedoxClinicalSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoxClinicalSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.allergies = [];
            if (message.allergies && message.allergies.length) {
                object.allergies = [];
                for (var j = 0; j < message.allergies.length; ++j)
                    object.allergies[j] = $root.RedoxTypes.Allergy.toObject(message.allergies[j], options);
            }
            return object;
        };
    
        /**
         * Converts this RedoxClinicalSummary to JSON.
         * @function toJSON
         * @memberof RedoxClinicalSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoxClinicalSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RedoxClinicalSummary;
    })();
    
    $root.RedoxPatient = (function() {
    
        /**
         * Properties of a RedoxPatient.
         * @exports IRedoxPatient
         * @interface IRedoxPatient
         * @property {Array.<RedoxTypes.IContact>|undefined} [Contacts] List of (emergency) contacts for the patient.
         * @property {RedoxTypes.IDemographics|undefined} [Demographics] Descriptive patient information - modeled from Redox.
         * @property {Array.<RedoxTypes.IIdentifier>|undefined} [Identifiers] Patient identifiers.
         * @property {Array.<RedoxTypes.IInsurance>|undefined} [Insurances] List of insurance(s) for the patient.
         * @property {Array.<string>|undefined} [Notes] List of patient-level notes.
         * @property {RedoxTypes.IPCP|undefined} [PCP] Patient's Primary Care Provider.
         */
    
        /**
         * Constructs a new RedoxPatient.
         * @exports RedoxPatient
         * @classdesc @see https://developer.redoxengine.com/data-models/PatientSearch.html#Response
         * @implements IRedoxPatient
         * @constructor
         * @param {IRedoxPatient=} [properties] Properties to set
         */
        function RedoxPatient(properties) {
            this.Contacts = [];
            this.Identifiers = [];
            this.Insurances = [];
            this.Notes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * List of (emergency) contacts for the patient.
         * @member {Array.<RedoxTypes.IContact>} Contacts
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.Contacts = $util.emptyArray;
    
        /**
         * Descriptive patient information - modeled from Redox.
         * @member {RedoxTypes.IDemographics|undefined|undefined} Demographics
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.Demographics = undefined;
    
        /**
         * Patient identifiers.
         * @member {Array.<RedoxTypes.IIdentifier>} Identifiers
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.Identifiers = $util.emptyArray;
    
        /**
         * List of insurance(s) for the patient.
         * @member {Array.<RedoxTypes.IInsurance>} Insurances
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.Insurances = $util.emptyArray;
    
        /**
         * List of patient-level notes.
         * @member {Array.<string>} Notes
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.Notes = $util.emptyArray;
    
        /**
         * Patient's Primary Care Provider.
         * @member {RedoxTypes.IPCP|undefined|undefined} PCP
         * @memberof RedoxPatient
         * @instance
         */
        RedoxPatient.prototype.PCP = undefined;
    
        /**
         * Creates a new RedoxPatient instance using the specified properties.
         * @function create
         * @memberof RedoxPatient
         * @static
         * @param {IRedoxPatient=} [properties] Properties to set
         * @returns {RedoxPatient} RedoxPatient instance
         */
        RedoxPatient.create = function create(properties) {
            return new RedoxPatient(properties);
        };
    
        /**
         * Encodes the specified RedoxPatient message. Does not implicitly {@link RedoxPatient.verify|verify} messages.
         * @function encode
         * @memberof RedoxPatient
         * @static
         * @param {IRedoxPatient} message RedoxPatient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxPatient.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Contacts != undefined && message.Contacts.length)
                for (var i = 0; i < message.Contacts.length; ++i)
                    $root.RedoxTypes.Contact.encode(message.Contacts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Demographics != undefined && message.hasOwnProperty("Demographics"))
                $root.RedoxTypes.Demographics.encode(message.Demographics, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Identifiers != undefined && message.Identifiers.length)
                for (var i = 0; i < message.Identifiers.length; ++i)
                    $root.RedoxTypes.Identifier.encode(message.Identifiers[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Insurances != undefined && message.Insurances.length)
                for (var i = 0; i < message.Insurances.length; ++i)
                    $root.RedoxTypes.Insurance.encode(message.Insurances[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.Notes != undefined && message.Notes.length)
                for (var i = 0; i < message.Notes.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.Notes[i]);
            if (message.PCP != undefined && message.hasOwnProperty("PCP"))
                $root.RedoxTypes.PCP.encode(message.PCP, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified RedoxPatient message, length delimited. Does not implicitly {@link RedoxPatient.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RedoxPatient
         * @static
         * @param {IRedoxPatient} message RedoxPatient message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxPatient.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RedoxPatient message from the specified reader or buffer.
         * @function decode
         * @memberof RedoxPatient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedoxPatient} RedoxPatient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxPatient.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxPatient();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Contacts && message.Contacts.length))
                        message.Contacts = [];
                    message.Contacts.push($root.RedoxTypes.Contact.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.Demographics = $root.RedoxTypes.Demographics.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.Identifiers && message.Identifiers.length))
                        message.Identifiers = [];
                    message.Identifiers.push($root.RedoxTypes.Identifier.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.Insurances && message.Insurances.length))
                        message.Insurances = [];
                    message.Insurances.push($root.RedoxTypes.Insurance.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.Notes && message.Notes.length))
                        message.Notes = [];
                    message.Notes.push(reader.string());
                    break;
                case 6:
                    message.PCP = $root.RedoxTypes.PCP.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RedoxPatient message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedoxPatient
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedoxPatient} RedoxPatient
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxPatient.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RedoxPatient message.
         * @function verify
         * @memberof RedoxPatient
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        RedoxPatient.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.Contacts != undefined && message.hasOwnProperty("Contacts")) {
                if (!Array.isArray(message.Contacts))
                    return "Contacts: array expected";
                for (var i = 0; i < message.Contacts.length; ++i) {
                    var error = $root.RedoxTypes.Contact.verify(message.Contacts[i]);
                    if (error)
                        return "Contacts." + error;
                }
            }
            if (message.Demographics != undefined && message.hasOwnProperty("Demographics")) {
                var error = $root.RedoxTypes.Demographics.verify(message.Demographics);
                if (error)
                    return "Demographics." + error;
            }
            if (message.Identifiers != undefined && message.hasOwnProperty("Identifiers")) {
                if (!Array.isArray(message.Identifiers))
                    return "Identifiers: array expected";
                for (var i = 0; i < message.Identifiers.length; ++i) {
                    var error = $root.RedoxTypes.Identifier.verify(message.Identifiers[i]);
                    if (error)
                        return "Identifiers." + error;
                }
            }
            if (message.Insurances != undefined && message.hasOwnProperty("Insurances")) {
                if (!Array.isArray(message.Insurances))
                    return "Insurances: array expected";
                for (var i = 0; i < message.Insurances.length; ++i) {
                    var error = $root.RedoxTypes.Insurance.verify(message.Insurances[i]);
                    if (error)
                        return "Insurances." + error;
                }
            }
            if (message.Notes != undefined && message.hasOwnProperty("Notes")) {
                if (!Array.isArray(message.Notes))
                    return "Notes: array expected";
                for (var i = 0; i < message.Notes.length; ++i)
                    if (!$util.isString(message.Notes[i]))
                        return "Notes: string[] expected";
            }
            if (message.PCP != undefined && message.hasOwnProperty("PCP")) {
                var error = $root.RedoxTypes.PCP.verify(message.PCP);
                if (error)
                    return "PCP." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a RedoxPatient message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RedoxPatient
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RedoxPatient} RedoxPatient
         */
        RedoxPatient.fromObject = function fromObject(object) {
            if (object instanceof $root.RedoxPatient)
                return object;
            var message = new $root.RedoxPatient();
            if (object.Contacts) {
                if (!Array.isArray(object.Contacts))
                    throw TypeError(".RedoxPatient.Contacts: array expected");
                message.Contacts = [];
                for (var i = 0; i < object.Contacts.length; ++i) {
                    if (typeof object.Contacts[i] !== "object")
                        throw TypeError(".RedoxPatient.Contacts: object expected");
                    message.Contacts[i] = $root.RedoxTypes.Contact.fromObject(object.Contacts[i]);
                }
            }
            if (object.Demographics != undefined) {
                if (typeof object.Demographics !== "object")
                    throw TypeError(".RedoxPatient.Demographics: object expected");
                message.Demographics = $root.RedoxTypes.Demographics.fromObject(object.Demographics);
            }
            if (object.Identifiers) {
                if (!Array.isArray(object.Identifiers))
                    throw TypeError(".RedoxPatient.Identifiers: array expected");
                message.Identifiers = [];
                for (var i = 0; i < object.Identifiers.length; ++i) {
                    if (typeof object.Identifiers[i] !== "object")
                        throw TypeError(".RedoxPatient.Identifiers: object expected");
                    message.Identifiers[i] = $root.RedoxTypes.Identifier.fromObject(object.Identifiers[i]);
                }
            }
            if (object.Insurances) {
                if (!Array.isArray(object.Insurances))
                    throw TypeError(".RedoxPatient.Insurances: array expected");
                message.Insurances = [];
                for (var i = 0; i < object.Insurances.length; ++i) {
                    if (typeof object.Insurances[i] !== "object")
                        throw TypeError(".RedoxPatient.Insurances: object expected");
                    message.Insurances[i] = $root.RedoxTypes.Insurance.fromObject(object.Insurances[i]);
                }
            }
            if (object.Notes) {
                if (!Array.isArray(object.Notes))
                    throw TypeError(".RedoxPatient.Notes: array expected");
                message.Notes = [];
                for (var i = 0; i < object.Notes.length; ++i)
                    message.Notes[i] = String(object.Notes[i]);
            }
            if (object.PCP != undefined) {
                if (typeof object.PCP !== "object")
                    throw TypeError(".RedoxPatient.PCP: object expected");
                message.PCP = $root.RedoxTypes.PCP.fromObject(object.PCP);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a RedoxPatient message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RedoxPatient
         * @static
         * @param {RedoxPatient} message RedoxPatient
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoxPatient.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.Contacts = [];
                object.Identifiers = [];
                object.Insurances = [];
                object.Notes = [];
            }
            if (options.defaults) {
                object.Demographics = undefined;
                object.PCP = undefined;
            }
            if (message.Contacts && message.Contacts.length) {
                object.Contacts = [];
                for (var j = 0; j < message.Contacts.length; ++j)
                    object.Contacts[j] = $root.RedoxTypes.Contact.toObject(message.Contacts[j], options);
            }
            if (message.Demographics != undefined && message.hasOwnProperty("Demographics"))
                object.Demographics = $root.RedoxTypes.Demographics.toObject(message.Demographics, options);
            if (message.Identifiers && message.Identifiers.length) {
                object.Identifiers = [];
                for (var j = 0; j < message.Identifiers.length; ++j)
                    object.Identifiers[j] = $root.RedoxTypes.Identifier.toObject(message.Identifiers[j], options);
            }
            if (message.Insurances && message.Insurances.length) {
                object.Insurances = [];
                for (var j = 0; j < message.Insurances.length; ++j)
                    object.Insurances[j] = $root.RedoxTypes.Insurance.toObject(message.Insurances[j], options);
            }
            if (message.Notes && message.Notes.length) {
                object.Notes = [];
                for (var j = 0; j < message.Notes.length; ++j)
                    object.Notes[j] = message.Notes[j];
            }
            if (message.PCP != undefined && message.hasOwnProperty("PCP"))
                object.PCP = $root.RedoxTypes.PCP.toObject(message.PCP, options);
            return object;
        };
    
        /**
         * Converts this RedoxPatient to JSON.
         * @function toJSON
         * @memberof RedoxPatient
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoxPatient.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return RedoxPatient;
    })();
    
    $root.RedoxTypes = (function() {
    
        /**
         * Properties of a RedoxTypes.
         * @exports IRedoxTypes
         * @interface IRedoxTypes
         */
    
        /**
         * Constructs a new RedoxTypes.
         * @exports RedoxTypes
         * @classdesc Redox data types.
         * @implements IRedoxTypes
         * @constructor
         * @param {IRedoxTypes=} [properties] Properties to set
         */
        function RedoxTypes(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new RedoxTypes instance using the specified properties.
         * @function create
         * @memberof RedoxTypes
         * @static
         * @param {IRedoxTypes=} [properties] Properties to set
         * @returns {RedoxTypes} RedoxTypes instance
         */
        RedoxTypes.create = function create(properties) {
            return new RedoxTypes(properties);
        };
    
        /**
         * Encodes the specified RedoxTypes message. Does not implicitly {@link RedoxTypes.verify|verify} messages.
         * @function encode
         * @memberof RedoxTypes
         * @static
         * @param {IRedoxTypes} message RedoxTypes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxTypes.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified RedoxTypes message, length delimited. Does not implicitly {@link RedoxTypes.verify|verify} messages.
         * @function encodeDelimited
         * @memberof RedoxTypes
         * @static
         * @param {IRedoxTypes} message RedoxTypes message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RedoxTypes.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a RedoxTypes message from the specified reader or buffer.
         * @function decode
         * @memberof RedoxTypes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {RedoxTypes} RedoxTypes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxTypes.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a RedoxTypes message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof RedoxTypes
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {RedoxTypes} RedoxTypes
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RedoxTypes.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a RedoxTypes message.
         * @function verify
         * @memberof RedoxTypes
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        RedoxTypes.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            return undefined;
        };
    
        /**
         * Creates a RedoxTypes message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof RedoxTypes
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {RedoxTypes} RedoxTypes
         */
        RedoxTypes.fromObject = function fromObject(object) {
            if (object instanceof $root.RedoxTypes)
                return object;
            return new $root.RedoxTypes();
        };
    
        /**
         * Creates a plain object from a RedoxTypes message. Also converts values to other types if specified.
         * @function toObject
         * @memberof RedoxTypes
         * @static
         * @param {RedoxTypes} message RedoxTypes
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RedoxTypes.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this RedoxTypes to JSON.
         * @function toJSON
         * @memberof RedoxTypes
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RedoxTypes.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        RedoxTypes.Address = (function() {
    
            /**
             * Properties of an Address.
             * @memberof RedoxTypes
             * @interface IAddress
             * @property {string|undefined} [City] City for the address, e.g. McLean.
             * @property {string|undefined} [Country] Country for the address, e.g. US.
             * @property {string|undefined} [County] County for the address, e.g. Fairfax.
             * @property {string|undefined} [State] State for the address, e.g. VA.
             * @property {string|undefined} [StreetAddress] Street address for the address, e.g. 6885 Elm Street.
             * @property {string|undefined} [ZIP] 5 digit zip code for the address, e.g. 22101.
             */
    
            /**
             * Constructs a new Address.
             * @memberof RedoxTypes
             * @classdesc Address / Physical Location.
             * @implements IAddress
             * @constructor
             * @param {RedoxTypes.IAddress=} [properties] Properties to set
             */
            function Address(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * City for the address, e.g. McLean.
             * @member {string} City
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.City = "";
    
            /**
             * Country for the address, e.g. US.
             * @member {string} Country
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.Country = "";
    
            /**
             * County for the address, e.g. Fairfax.
             * @member {string} County
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.County = "";
    
            /**
             * State for the address, e.g. VA.
             * @member {string} State
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.State = "";
    
            /**
             * Street address for the address, e.g. 6885 Elm Street.
             * @member {string} StreetAddress
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.StreetAddress = "";
    
            /**
             * 5 digit zip code for the address, e.g. 22101.
             * @member {string} ZIP
             * @memberof RedoxTypes.Address
             * @instance
             */
            Address.prototype.ZIP = "";
    
            /**
             * Creates a new Address instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Address
             * @static
             * @param {RedoxTypes.IAddress=} [properties] Properties to set
             * @returns {RedoxTypes.Address} Address instance
             */
            Address.create = function create(properties) {
                return new Address(properties);
            };
    
            /**
             * Encodes the specified Address message. Does not implicitly {@link RedoxTypes.Address.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Address
             * @static
             * @param {RedoxTypes.IAddress} message Address message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Address.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.City != undefined && message.hasOwnProperty("City"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.City);
                if (message.Country != undefined && message.hasOwnProperty("Country"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Country);
                if (message.County != undefined && message.hasOwnProperty("County"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.County);
                if (message.State != undefined && message.hasOwnProperty("State"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.State);
                if (message.StreetAddress != undefined && message.hasOwnProperty("StreetAddress"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.StreetAddress);
                if (message.ZIP != undefined && message.hasOwnProperty("ZIP"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.ZIP);
                return writer;
            };
    
            /**
             * Encodes the specified Address message, length delimited. Does not implicitly {@link RedoxTypes.Address.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Address
             * @static
             * @param {RedoxTypes.IAddress} message Address message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Address.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Address message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Address
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Address} Address
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Address.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Address();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.City = reader.string();
                        break;
                    case 2:
                        message.Country = reader.string();
                        break;
                    case 3:
                        message.County = reader.string();
                        break;
                    case 4:
                        message.State = reader.string();
                        break;
                    case 5:
                        message.StreetAddress = reader.string();
                        break;
                    case 6:
                        message.ZIP = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Address message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Address
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Address} Address
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Address.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Address message.
             * @function verify
             * @memberof RedoxTypes.Address
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Address.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.City != undefined && message.hasOwnProperty("City"))
                    if (!$util.isString(message.City))
                        return "City: string expected";
                if (message.Country != undefined && message.hasOwnProperty("Country"))
                    if (!$util.isString(message.Country))
                        return "Country: string expected";
                if (message.County != undefined && message.hasOwnProperty("County"))
                    if (!$util.isString(message.County))
                        return "County: string expected";
                if (message.State != undefined && message.hasOwnProperty("State"))
                    if (!$util.isString(message.State))
                        return "State: string expected";
                if (message.StreetAddress != undefined && message.hasOwnProperty("StreetAddress"))
                    if (!$util.isString(message.StreetAddress))
                        return "StreetAddress: string expected";
                if (message.ZIP != undefined && message.hasOwnProperty("ZIP"))
                    if (!$util.isString(message.ZIP))
                        return "ZIP: string expected";
                return undefined;
            };
    
            /**
             * Creates an Address message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Address
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Address} Address
             */
            Address.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Address)
                    return object;
                var message = new $root.RedoxTypes.Address();
                if (object.City != undefined)
                    message.City = String(object.City);
                if (object.Country != undefined)
                    message.Country = String(object.Country);
                if (object.County != undefined)
                    message.County = String(object.County);
                if (object.State != undefined)
                    message.State = String(object.State);
                if (object.StreetAddress != undefined)
                    message.StreetAddress = String(object.StreetAddress);
                if (object.ZIP != undefined)
                    message.ZIP = String(object.ZIP);
                return message;
            };
    
            /**
             * Creates a plain object from an Address message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Address
             * @static
             * @param {RedoxTypes.Address} message Address
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Address.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.City = "";
                    object.Country = "";
                    object.County = "";
                    object.State = "";
                    object.StreetAddress = "";
                    object.ZIP = "";
                }
                if (message.City != undefined && message.hasOwnProperty("City"))
                    object.City = message.City;
                if (message.Country != undefined && message.hasOwnProperty("Country"))
                    object.Country = message.Country;
                if (message.County != undefined && message.hasOwnProperty("County"))
                    object.County = message.County;
                if (message.State != undefined && message.hasOwnProperty("State"))
                    object.State = message.State;
                if (message.StreetAddress != undefined && message.hasOwnProperty("StreetAddress"))
                    object.StreetAddress = message.StreetAddress;
                if (message.ZIP != undefined && message.hasOwnProperty("ZIP"))
                    object.ZIP = message.ZIP;
                return object;
            };
    
            /**
             * Converts this Address to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Address
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Address.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Address;
        })();
    
        RedoxTypes.Allergy = (function() {
    
            /**
             * Properties of an Allergy.
             * @memberof RedoxTypes
             * @interface IAllergy
             * @property {string|undefined} [Comment] Free text comment about the allergy.
             * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Criticality] Represents the gravity of potential risk for future life-threatening reactions.
             * @property {string|undefined} [EndDate] When the allergy was no longer a problem (if applicable). (ISO 8601)
             * @property {Array.<RedoxTypes.Allergy.IReactionType>|undefined} [Reaction] List of reactions that occur when the allergen is introduced.
             * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Severity] Describes the severity of the reaction.
             * @property {string|undefined} [StartDate] Date the allergy was identified. (ISO 8601)
             * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Status] Describes the current status of the allergy (active, historic, etc.).
             * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Substance] Describes the substance that causes the allergy. Typically RxNorm or SNOMED.
             * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Type] Describes the type of allergy intolerance this is (food, drug, etc.).
             */
    
            /**
             * Constructs a new Allergy.
             * @memberof RedoxTypes
             * @classdesc An allergy to a medication, food, or substance.
             * @implements IAllergy
             * @constructor
             * @param {RedoxTypes.IAllergy=} [properties] Properties to set
             */
            function Allergy(properties) {
                this.Reaction = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Free text comment about the allergy.
             * @member {string} Comment
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Comment = "";
    
            /**
             * Represents the gravity of potential risk for future life-threatening reactions.
             * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Criticality
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Criticality = undefined;
    
            /**
             * When the allergy was no longer a problem (if applicable). (ISO 8601)
             * @member {string} EndDate
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.EndDate = "";
    
            /**
             * List of reactions that occur when the allergen is introduced.
             * @member {Array.<RedoxTypes.Allergy.IReactionType>} Reaction
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Reaction = $util.emptyArray;
    
            /**
             * Describes the severity of the reaction.
             * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Severity
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Severity = undefined;
    
            /**
             * Date the allergy was identified. (ISO 8601)
             * @member {string} StartDate
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.StartDate = "";
    
            /**
             * Describes the current status of the allergy (active, historic, etc.).
             * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Status
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Status = undefined;
    
            /**
             * Describes the substance that causes the allergy. Typically RxNorm or SNOMED.
             * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Substance
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Substance = undefined;
    
            /**
             * Describes the type of allergy intolerance this is (food, drug, etc.).
             * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Type
             * @memberof RedoxTypes.Allergy
             * @instance
             */
            Allergy.prototype.Type = undefined;
    
            /**
             * Creates a new Allergy instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {RedoxTypes.IAllergy=} [properties] Properties to set
             * @returns {RedoxTypes.Allergy} Allergy instance
             */
            Allergy.create = function create(properties) {
                return new Allergy(properties);
            };
    
            /**
             * Encodes the specified Allergy message. Does not implicitly {@link RedoxTypes.Allergy.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {RedoxTypes.IAllergy} message Allergy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Allergy.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Comment != undefined && message.hasOwnProperty("Comment"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Comment);
                if (message.Criticality != undefined && message.hasOwnProperty("Criticality"))
                    $root.RedoxTypes.Allergy.CodedValue.encode(message.Criticality, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.EndDate != undefined && message.hasOwnProperty("EndDate"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.EndDate);
                if (message.Reaction != undefined && message.Reaction.length)
                    for (var i = 0; i < message.Reaction.length; ++i)
                        $root.RedoxTypes.Allergy.ReactionType.encode(message.Reaction[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.Severity != undefined && message.hasOwnProperty("Severity"))
                    $root.RedoxTypes.Allergy.CodedValue.encode(message.Severity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.StartDate != undefined && message.hasOwnProperty("StartDate"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.StartDate);
                if (message.Status != undefined && message.hasOwnProperty("Status"))
                    $root.RedoxTypes.Allergy.CodedValue.encode(message.Status, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.Substance != undefined && message.hasOwnProperty("Substance"))
                    $root.RedoxTypes.Allergy.CodedValue.encode(message.Substance, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    $root.RedoxTypes.Allergy.CodedValue.encode(message.Type, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Allergy message, length delimited. Does not implicitly {@link RedoxTypes.Allergy.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {RedoxTypes.IAllergy} message Allergy message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Allergy.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Allergy message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Allergy} Allergy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Allergy.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Allergy();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Comment = reader.string();
                        break;
                    case 2:
                        message.Criticality = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.EndDate = reader.string();
                        break;
                    case 4:
                        if (!(message.Reaction && message.Reaction.length))
                            message.Reaction = [];
                        message.Reaction.push($root.RedoxTypes.Allergy.ReactionType.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.Severity = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.StartDate = reader.string();
                        break;
                    case 7:
                        message.Status = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.Substance = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.Type = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Allergy message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Allergy} Allergy
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Allergy.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Allergy message.
             * @function verify
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Allergy.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Comment != undefined && message.hasOwnProperty("Comment"))
                    if (!$util.isString(message.Comment))
                        return "Comment: string expected";
                if (message.Criticality != undefined && message.hasOwnProperty("Criticality")) {
                    var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Criticality);
                    if (error)
                        return "Criticality." + error;
                }
                if (message.EndDate != undefined && message.hasOwnProperty("EndDate"))
                    if (!$util.isString(message.EndDate))
                        return "EndDate: string expected";
                if (message.Reaction != undefined && message.hasOwnProperty("Reaction")) {
                    if (!Array.isArray(message.Reaction))
                        return "Reaction: array expected";
                    for (var i = 0; i < message.Reaction.length; ++i) {
                        var error = $root.RedoxTypes.Allergy.ReactionType.verify(message.Reaction[i]);
                        if (error)
                            return "Reaction." + error;
                    }
                }
                if (message.Severity != undefined && message.hasOwnProperty("Severity")) {
                    var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Severity);
                    if (error)
                        return "Severity." + error;
                }
                if (message.StartDate != undefined && message.hasOwnProperty("StartDate"))
                    if (!$util.isString(message.StartDate))
                        return "StartDate: string expected";
                if (message.Status != undefined && message.hasOwnProperty("Status")) {
                    var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Status);
                    if (error)
                        return "Status." + error;
                }
                if (message.Substance != undefined && message.hasOwnProperty("Substance")) {
                    var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Substance);
                    if (error)
                        return "Substance." + error;
                }
                if (message.Type != undefined && message.hasOwnProperty("Type")) {
                    var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Type);
                    if (error)
                        return "Type." + error;
                }
                return undefined;
            };
    
            /**
             * Creates an Allergy message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Allergy} Allergy
             */
            Allergy.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Allergy)
                    return object;
                var message = new $root.RedoxTypes.Allergy();
                if (object.Comment != undefined)
                    message.Comment = String(object.Comment);
                if (object.Criticality != undefined) {
                    if (typeof object.Criticality !== "object")
                        throw TypeError(".RedoxTypes.Allergy.Criticality: object expected");
                    message.Criticality = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Criticality);
                }
                if (object.EndDate != undefined)
                    message.EndDate = String(object.EndDate);
                if (object.Reaction) {
                    if (!Array.isArray(object.Reaction))
                        throw TypeError(".RedoxTypes.Allergy.Reaction: array expected");
                    message.Reaction = [];
                    for (var i = 0; i < object.Reaction.length; ++i) {
                        if (typeof object.Reaction[i] !== "object")
                            throw TypeError(".RedoxTypes.Allergy.Reaction: object expected");
                        message.Reaction[i] = $root.RedoxTypes.Allergy.ReactionType.fromObject(object.Reaction[i]);
                    }
                }
                if (object.Severity != undefined) {
                    if (typeof object.Severity !== "object")
                        throw TypeError(".RedoxTypes.Allergy.Severity: object expected");
                    message.Severity = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Severity);
                }
                if (object.StartDate != undefined)
                    message.StartDate = String(object.StartDate);
                if (object.Status != undefined) {
                    if (typeof object.Status !== "object")
                        throw TypeError(".RedoxTypes.Allergy.Status: object expected");
                    message.Status = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Status);
                }
                if (object.Substance != undefined) {
                    if (typeof object.Substance !== "object")
                        throw TypeError(".RedoxTypes.Allergy.Substance: object expected");
                    message.Substance = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Substance);
                }
                if (object.Type != undefined) {
                    if (typeof object.Type !== "object")
                        throw TypeError(".RedoxTypes.Allergy.Type: object expected");
                    message.Type = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Type);
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Allergy message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Allergy
             * @static
             * @param {RedoxTypes.Allergy} message Allergy
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Allergy.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.Reaction = [];
                if (options.defaults) {
                    object.Comment = "";
                    object.Criticality = undefined;
                    object.EndDate = "";
                    object.Severity = undefined;
                    object.StartDate = "";
                    object.Status = undefined;
                    object.Substance = undefined;
                    object.Type = undefined;
                }
                if (message.Comment != undefined && message.hasOwnProperty("Comment"))
                    object.Comment = message.Comment;
                if (message.Criticality != undefined && message.hasOwnProperty("Criticality"))
                    object.Criticality = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Criticality, options);
                if (message.EndDate != undefined && message.hasOwnProperty("EndDate"))
                    object.EndDate = message.EndDate;
                if (message.Reaction && message.Reaction.length) {
                    object.Reaction = [];
                    for (var j = 0; j < message.Reaction.length; ++j)
                        object.Reaction[j] = $root.RedoxTypes.Allergy.ReactionType.toObject(message.Reaction[j], options);
                }
                if (message.Severity != undefined && message.hasOwnProperty("Severity"))
                    object.Severity = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Severity, options);
                if (message.StartDate != undefined && message.hasOwnProperty("StartDate"))
                    object.StartDate = message.StartDate;
                if (message.Status != undefined && message.hasOwnProperty("Status"))
                    object.Status = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Status, options);
                if (message.Substance != undefined && message.hasOwnProperty("Substance"))
                    object.Substance = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Substance, options);
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    object.Type = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Type, options);
                return object;
            };
    
            /**
             * Converts this Allergy to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Allergy
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Allergy.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            Allergy.CodedValue = (function() {
    
                /**
                 * Properties of a CodedValue.
                 * @memberof RedoxTypes.Allergy
                 * @interface ICodedValue
                 * @property {string|undefined} [Code] Code value.
                 * @property {string|undefined} [CodeSystem] ID of the coding system to which the code belongs in OID format.
                 * @property {string|undefined} [CodeSystemName] * Coding system to which the code belogs.
                 * * (e.g. SNOMED CT, LOINC, RxNorm, CVX, ICD9, ICD10)
                 * @property {string|undefined} [Name] Name of the code value.
                 */
    
                /**
                 * Constructs a new CodedValue.
                 * @memberof RedoxTypes.Allergy
                 * @classdesc A value represented by some code.
                 * @implements ICodedValue
                 * @constructor
                 * @param {RedoxTypes.Allergy.ICodedValue=} [properties] Properties to set
                 */
                function CodedValue(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != undefined)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Code value.
                 * @member {string} Code
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @instance
                 */
                CodedValue.prototype.Code = "";
    
                /**
                 * ID of the coding system to which the code belongs in OID format.
                 * @member {string} CodeSystem
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @instance
                 */
                CodedValue.prototype.CodeSystem = "";
    
                /**
                 * * Coding system to which the code belogs.
                 * * (e.g. SNOMED CT, LOINC, RxNorm, CVX, ICD9, ICD10)
                 * @member {string} CodeSystemName
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @instance
                 */
                CodedValue.prototype.CodeSystemName = "";
    
                /**
                 * Name of the code value.
                 * @member {string} Name
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @instance
                 */
                CodedValue.prototype.Name = "";
    
                /**
                 * Creates a new CodedValue instance using the specified properties.
                 * @function create
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {RedoxTypes.Allergy.ICodedValue=} [properties] Properties to set
                 * @returns {RedoxTypes.Allergy.CodedValue} CodedValue instance
                 */
                CodedValue.create = function create(properties) {
                    return new CodedValue(properties);
                };
    
                /**
                 * Encodes the specified CodedValue message. Does not implicitly {@link RedoxTypes.Allergy.CodedValue.verify|verify} messages.
                 * @function encode
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {RedoxTypes.Allergy.ICodedValue} message CodedValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValue.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Code);
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.CodeSystem);
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.CodeSystemName);
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Name);
                    return writer;
                };
    
                /**
                 * Encodes the specified CodedValue message, length delimited. Does not implicitly {@link RedoxTypes.Allergy.CodedValue.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {RedoxTypes.Allergy.ICodedValue} message CodedValue message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CodedValue.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CodedValue message from the specified reader or buffer.
                 * @function decode
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {RedoxTypes.Allergy.CodedValue} CodedValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValue.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Allergy.CodedValue();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Code = reader.string();
                            break;
                        case 2:
                            message.CodeSystem = reader.string();
                            break;
                        case 3:
                            message.CodeSystemName = reader.string();
                            break;
                        case 4:
                            message.Name = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CodedValue message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {RedoxTypes.Allergy.CodedValue} CodedValue
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CodedValue.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CodedValue message.
                 * @function verify
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
                 */
                CodedValue.verify = function verify(message) {
                    if (typeof message !== "object" || message === undefined)
                        return "object expected";
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        if (!$util.isString(message.Code))
                            return "Code: string expected";
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        if (!$util.isString(message.CodeSystem))
                            return "CodeSystem: string expected";
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        if (!$util.isString(message.CodeSystemName))
                            return "CodeSystemName: string expected";
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        if (!$util.isString(message.Name))
                            return "Name: string expected";
                    return undefined;
                };
    
                /**
                 * Creates a CodedValue message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {RedoxTypes.Allergy.CodedValue} CodedValue
                 */
                CodedValue.fromObject = function fromObject(object) {
                    if (object instanceof $root.RedoxTypes.Allergy.CodedValue)
                        return object;
                    var message = new $root.RedoxTypes.Allergy.CodedValue();
                    if (object.Code != undefined)
                        message.Code = String(object.Code);
                    if (object.CodeSystem != undefined)
                        message.CodeSystem = String(object.CodeSystem);
                    if (object.CodeSystemName != undefined)
                        message.CodeSystemName = String(object.CodeSystemName);
                    if (object.Name != undefined)
                        message.Name = String(object.Name);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CodedValue message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @static
                 * @param {RedoxTypes.Allergy.CodedValue} message CodedValue
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CodedValue.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Code = "";
                        object.CodeSystem = "";
                        object.CodeSystemName = "";
                        object.Name = "";
                    }
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        object.Code = message.Code;
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        object.CodeSystem = message.CodeSystem;
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        object.CodeSystemName = message.CodeSystemName;
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        object.Name = message.Name;
                    return object;
                };
    
                /**
                 * Converts this CodedValue to JSON.
                 * @function toJSON
                 * @memberof RedoxTypes.Allergy.CodedValue
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CodedValue.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CodedValue;
            })();
    
            Allergy.ReactionType = (function() {
    
                /**
                 * Properties of a ReactionType.
                 * @memberof RedoxTypes.Allergy
                 * @interface IReactionType
                 * @property {string|undefined} [Code] @see CodedValue.Code
                 * @property {string|undefined} [CodeSystem] @see CodedValue.CodeSystem
                 * @property {string|undefined} [CodeSystemName] @see CodedValue.CodeSystemName
                 * @property {string|undefined} [Name] @see CodedValue.Name
                 * @property {RedoxTypes.Allergy.ICodedValue|undefined} [Severity] Severity.
                 * @property {string|undefined} [Text] * Free text form of reactions to this substance.
                 * * Includes information that cannot be captured by coded value.
                 */
    
                /**
                 * Constructs a new ReactionType.
                 * @memberof RedoxTypes.Allergy
                 * @classdesc A reaction that occurs when the allergen is introduced.
                 * @implements IReactionType
                 * @constructor
                 * @param {RedoxTypes.Allergy.IReactionType=} [properties] Properties to set
                 */
                function ReactionType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != undefined)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * @see CodedValue.Code
                 * @member {string} Code
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.Code = "";
    
                /**
                 * @see CodedValue.CodeSystem
                 * @member {string} CodeSystem
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.CodeSystem = "";
    
                /**
                 * @see CodedValue.CodeSystemName
                 * @member {string} CodeSystemName
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.CodeSystemName = "";
    
                /**
                 * @see CodedValue.Name
                 * @member {string} Name
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.Name = "";
    
                /**
                 * Severity.
                 * @member {RedoxTypes.Allergy.ICodedValue|undefined|undefined} Severity
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.Severity = undefined;
    
                /**
                 * * Free text form of reactions to this substance.
                 * * Includes information that cannot be captured by coded value.
                 * @member {string} Text
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 */
                ReactionType.prototype.Text = "";
    
                /**
                 * Creates a new ReactionType instance using the specified properties.
                 * @function create
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {RedoxTypes.Allergy.IReactionType=} [properties] Properties to set
                 * @returns {RedoxTypes.Allergy.ReactionType} ReactionType instance
                 */
                ReactionType.create = function create(properties) {
                    return new ReactionType(properties);
                };
    
                /**
                 * Encodes the specified ReactionType message. Does not implicitly {@link RedoxTypes.Allergy.ReactionType.verify|verify} messages.
                 * @function encode
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {RedoxTypes.Allergy.IReactionType} message ReactionType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.Code);
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.CodeSystem);
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.CodeSystemName);
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Name);
                    if (message.Severity != undefined && message.hasOwnProperty("Severity"))
                        $root.RedoxTypes.Allergy.CodedValue.encode(message.Severity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.Text != undefined && message.hasOwnProperty("Text"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.Text);
                    return writer;
                };
    
                /**
                 * Encodes the specified ReactionType message, length delimited. Does not implicitly {@link RedoxTypes.Allergy.ReactionType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {RedoxTypes.Allergy.IReactionType} message ReactionType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReactionType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReactionType message from the specified reader or buffer.
                 * @function decode
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {RedoxTypes.Allergy.ReactionType} ReactionType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Allergy.ReactionType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Code = reader.string();
                            break;
                        case 2:
                            message.CodeSystem = reader.string();
                            break;
                        case 3:
                            message.CodeSystemName = reader.string();
                            break;
                        case 4:
                            message.Name = reader.string();
                            break;
                        case 5:
                            message.Severity = $root.RedoxTypes.Allergy.CodedValue.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.Text = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReactionType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {RedoxTypes.Allergy.ReactionType} ReactionType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReactionType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReactionType message.
                 * @function verify
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
                 */
                ReactionType.verify = function verify(message) {
                    if (typeof message !== "object" || message === undefined)
                        return "object expected";
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        if (!$util.isString(message.Code))
                            return "Code: string expected";
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        if (!$util.isString(message.CodeSystem))
                            return "CodeSystem: string expected";
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        if (!$util.isString(message.CodeSystemName))
                            return "CodeSystemName: string expected";
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        if (!$util.isString(message.Name))
                            return "Name: string expected";
                    if (message.Severity != undefined && message.hasOwnProperty("Severity")) {
                        var error = $root.RedoxTypes.Allergy.CodedValue.verify(message.Severity);
                        if (error)
                            return "Severity." + error;
                    }
                    if (message.Text != undefined && message.hasOwnProperty("Text"))
                        if (!$util.isString(message.Text))
                            return "Text: string expected";
                    return undefined;
                };
    
                /**
                 * Creates a ReactionType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {RedoxTypes.Allergy.ReactionType} ReactionType
                 */
                ReactionType.fromObject = function fromObject(object) {
                    if (object instanceof $root.RedoxTypes.Allergy.ReactionType)
                        return object;
                    var message = new $root.RedoxTypes.Allergy.ReactionType();
                    if (object.Code != undefined)
                        message.Code = String(object.Code);
                    if (object.CodeSystem != undefined)
                        message.CodeSystem = String(object.CodeSystem);
                    if (object.CodeSystemName != undefined)
                        message.CodeSystemName = String(object.CodeSystemName);
                    if (object.Name != undefined)
                        message.Name = String(object.Name);
                    if (object.Severity != undefined) {
                        if (typeof object.Severity !== "object")
                            throw TypeError(".RedoxTypes.Allergy.ReactionType.Severity: object expected");
                        message.Severity = $root.RedoxTypes.Allergy.CodedValue.fromObject(object.Severity);
                    }
                    if (object.Text != undefined)
                        message.Text = String(object.Text);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReactionType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @static
                 * @param {RedoxTypes.Allergy.ReactionType} message ReactionType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReactionType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Code = "";
                        object.CodeSystem = "";
                        object.CodeSystemName = "";
                        object.Name = "";
                        object.Severity = undefined;
                        object.Text = "";
                    }
                    if (message.Code != undefined && message.hasOwnProperty("Code"))
                        object.Code = message.Code;
                    if (message.CodeSystem != undefined && message.hasOwnProperty("CodeSystem"))
                        object.CodeSystem = message.CodeSystem;
                    if (message.CodeSystemName != undefined && message.hasOwnProperty("CodeSystemName"))
                        object.CodeSystemName = message.CodeSystemName;
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        object.Name = message.Name;
                    if (message.Severity != undefined && message.hasOwnProperty("Severity"))
                        object.Severity = $root.RedoxTypes.Allergy.CodedValue.toObject(message.Severity, options);
                    if (message.Text != undefined && message.hasOwnProperty("Text"))
                        object.Text = message.Text;
                    return object;
                };
    
                /**
                 * Converts this ReactionType to JSON.
                 * @function toJSON
                 * @memberof RedoxTypes.Allergy.ReactionType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReactionType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ReactionType;
            })();
    
            return Allergy;
        })();
    
        RedoxTypes.AppointmentInfo = (function() {
    
            /**
             * Properties of an AppointmentInfo.
             * @memberof RedoxTypes
             * @interface IAppointmentInfo
             * @property {string|undefined} [Code] Code for the information element.
             * @property {string|undefined} [Codeset] Code set used to identify the information element.
             * @property {string|undefined} [Description] Description of the information element.
             * @property {string|undefined} [Value] The value of the corresponding AppointmentInfo code.
             */
    
            /**
             * Constructs a new AppointmentInfo.
             * @memberof RedoxTypes
             * @classdesc List of supplementary clinical information associated with the appointment.
             * @implements IAppointmentInfo
             * @constructor
             * @param {RedoxTypes.IAppointmentInfo=} [properties] Properties to set
             */
            function AppointmentInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Code for the information element.
             * @member {string} Code
             * @memberof RedoxTypes.AppointmentInfo
             * @instance
             */
            AppointmentInfo.prototype.Code = "";
    
            /**
             * Code set used to identify the information element.
             * @member {string} Codeset
             * @memberof RedoxTypes.AppointmentInfo
             * @instance
             */
            AppointmentInfo.prototype.Codeset = "";
    
            /**
             * Description of the information element.
             * @member {string} Description
             * @memberof RedoxTypes.AppointmentInfo
             * @instance
             */
            AppointmentInfo.prototype.Description = "";
    
            /**
             * The value of the corresponding AppointmentInfo code.
             * @member {string} Value
             * @memberof RedoxTypes.AppointmentInfo
             * @instance
             */
            AppointmentInfo.prototype.Value = "";
    
            /**
             * Creates a new AppointmentInfo instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {RedoxTypes.IAppointmentInfo=} [properties] Properties to set
             * @returns {RedoxTypes.AppointmentInfo} AppointmentInfo instance
             */
            AppointmentInfo.create = function create(properties) {
                return new AppointmentInfo(properties);
            };
    
            /**
             * Encodes the specified AppointmentInfo message. Does not implicitly {@link RedoxTypes.AppointmentInfo.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {RedoxTypes.IAppointmentInfo} message AppointmentInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppointmentInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Code);
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Codeset);
                if (message.Description != undefined && message.hasOwnProperty("Description"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Description);
                if (message.Value != undefined && message.hasOwnProperty("Value"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.Value);
                return writer;
            };
    
            /**
             * Encodes the specified AppointmentInfo message, length delimited. Does not implicitly {@link RedoxTypes.AppointmentInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {RedoxTypes.IAppointmentInfo} message AppointmentInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AppointmentInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an AppointmentInfo message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.AppointmentInfo} AppointmentInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppointmentInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.AppointmentInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Code = reader.string();
                        break;
                    case 2:
                        message.Codeset = reader.string();
                        break;
                    case 3:
                        message.Description = reader.string();
                        break;
                    case 4:
                        message.Value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an AppointmentInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.AppointmentInfo} AppointmentInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AppointmentInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an AppointmentInfo message.
             * @function verify
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            AppointmentInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    if (!$util.isString(message.Code))
                        return "Code: string expected";
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    if (!$util.isString(message.Codeset))
                        return "Codeset: string expected";
                if (message.Description != undefined && message.hasOwnProperty("Description"))
                    if (!$util.isString(message.Description))
                        return "Description: string expected";
                if (message.Value != undefined && message.hasOwnProperty("Value"))
                    if (!$util.isString(message.Value))
                        return "Value: string expected";
                return undefined;
            };
    
            /**
             * Creates an AppointmentInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.AppointmentInfo} AppointmentInfo
             */
            AppointmentInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.AppointmentInfo)
                    return object;
                var message = new $root.RedoxTypes.AppointmentInfo();
                if (object.Code != undefined)
                    message.Code = String(object.Code);
                if (object.Codeset != undefined)
                    message.Codeset = String(object.Codeset);
                if (object.Description != undefined)
                    message.Description = String(object.Description);
                if (object.Value != undefined)
                    message.Value = String(object.Value);
                return message;
            };
    
            /**
             * Creates a plain object from an AppointmentInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.AppointmentInfo
             * @static
             * @param {RedoxTypes.AppointmentInfo} message AppointmentInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AppointmentInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Code = "";
                    object.Codeset = "";
                    object.Description = "";
                    object.Value = "";
                }
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    object.Code = message.Code;
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    object.Codeset = message.Codeset;
                if (message.Description != undefined && message.hasOwnProperty("Description"))
                    object.Description = message.Description;
                if (message.Value != undefined && message.hasOwnProperty("Value"))
                    object.Value = message.Value;
                return object;
            };
    
            /**
             * Converts this AppointmentInfo to JSON.
             * @function toJSON
             * @memberof RedoxTypes.AppointmentInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AppointmentInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return AppointmentInfo;
        })();
    
        RedoxTypes.CodesetValue = (function() {
    
            /**
             * Properties of a CodesetValue.
             * @memberof RedoxTypes
             * @interface ICodesetValue
             * @property {string|undefined} [Code] Code for the information element.
             * @property {string|undefined} [Codeset] Code set used to identify the information element.
             * @property {string|undefined} [Name] Name.
             * @property {string|undefined} [Type] Type.
             */
    
            /**
             * Constructs a new CodesetValue.
             * @memberof RedoxTypes
             * @classdesc A value represented by some code and codeset.
             * @implements ICodesetValue
             * @constructor
             * @param {RedoxTypes.ICodesetValue=} [properties] Properties to set
             */
            function CodesetValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Code for the information element.
             * @member {string} Code
             * @memberof RedoxTypes.CodesetValue
             * @instance
             */
            CodesetValue.prototype.Code = "";
    
            /**
             * Code set used to identify the information element.
             * @member {string} Codeset
             * @memberof RedoxTypes.CodesetValue
             * @instance
             */
            CodesetValue.prototype.Codeset = "";
    
            /**
             * Name.
             * @member {string} Name
             * @memberof RedoxTypes.CodesetValue
             * @instance
             */
            CodesetValue.prototype.Name = "";
    
            /**
             * Type.
             * @member {string} Type
             * @memberof RedoxTypes.CodesetValue
             * @instance
             */
            CodesetValue.prototype.Type = "";
    
            /**
             * Creates a new CodesetValue instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {RedoxTypes.ICodesetValue=} [properties] Properties to set
             * @returns {RedoxTypes.CodesetValue} CodesetValue instance
             */
            CodesetValue.create = function create(properties) {
                return new CodesetValue(properties);
            };
    
            /**
             * Encodes the specified CodesetValue message. Does not implicitly {@link RedoxTypes.CodesetValue.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {RedoxTypes.ICodesetValue} message CodesetValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CodesetValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Code);
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Codeset);
                if (message.Name != undefined && message.hasOwnProperty("Name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.Type);
                return writer;
            };
    
            /**
             * Encodes the specified CodesetValue message, length delimited. Does not implicitly {@link RedoxTypes.CodesetValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {RedoxTypes.ICodesetValue} message CodesetValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CodesetValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a CodesetValue message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.CodesetValue} CodesetValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CodesetValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.CodesetValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Code = reader.string();
                        break;
                    case 2:
                        message.Codeset = reader.string();
                        break;
                    case 3:
                        message.Name = reader.string();
                        break;
                    case 4:
                        message.Type = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a CodesetValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.CodesetValue} CodesetValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CodesetValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a CodesetValue message.
             * @function verify
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            CodesetValue.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    if (!$util.isString(message.Code))
                        return "Code: string expected";
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    if (!$util.isString(message.Codeset))
                        return "Codeset: string expected";
                if (message.Name != undefined && message.hasOwnProperty("Name"))
                    if (!$util.isString(message.Name))
                        return "Name: string expected";
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    if (!$util.isString(message.Type))
                        return "Type: string expected";
                return undefined;
            };
    
            /**
             * Creates a CodesetValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.CodesetValue} CodesetValue
             */
            CodesetValue.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.CodesetValue)
                    return object;
                var message = new $root.RedoxTypes.CodesetValue();
                if (object.Code != undefined)
                    message.Code = String(object.Code);
                if (object.Codeset != undefined)
                    message.Codeset = String(object.Codeset);
                if (object.Name != undefined)
                    message.Name = String(object.Name);
                if (object.Type != undefined)
                    message.Type = String(object.Type);
                return message;
            };
    
            /**
             * Creates a plain object from a CodesetValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.CodesetValue
             * @static
             * @param {RedoxTypes.CodesetValue} message CodesetValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CodesetValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Code = "";
                    object.Codeset = "";
                    object.Name = "";
                    object.Type = "";
                }
                if (message.Code != undefined && message.hasOwnProperty("Code"))
                    object.Code = message.Code;
                if (message.Codeset != undefined && message.hasOwnProperty("Codeset"))
                    object.Codeset = message.Codeset;
                if (message.Name != undefined && message.hasOwnProperty("Name"))
                    object.Name = message.Name;
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    object.Type = message.Type;
                return object;
            };
    
            /**
             * Converts this CodesetValue to JSON.
             * @function toJSON
             * @memberof RedoxTypes.CodesetValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CodesetValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return CodesetValue;
        })();
    
        RedoxTypes.Contact = (function() {
    
            /**
             * Properties of a Contact.
             * @memberof RedoxTypes
             * @interface IContact
             * @property {RedoxTypes.IAddress|undefined} [Address] @see Address
             * @property {Array.<string>|undefined} [EmailAddresses] List of emails for the contact.
             * @property {string|undefined} [FirstName] First name.
             * @property {string|undefined} [LastName] Last name.
             * @property {string|undefined} [MiddleName] Middle name - multiple middle names concatenated into this field.
             * @property {RedoxTypes.IPhoneNumber|undefined} [PhoneNumber] @see PhoneNumber
             * @property {string|undefined} [RelationToPatient] Personal relationship to the patient. e.g. Father, Spouse.
             * @property {Array.<string>|undefined} [Roles] Role of this contact for the patient. e.g. Employer, Emergency Contact.
             */
    
            /**
             * Constructs a new Contact.
             * @memberof RedoxTypes
             * @classdesc Emergency Contact for the patient.
             * @implements IContact
             * @constructor
             * @param {RedoxTypes.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                this.EmailAddresses = [];
                this.Roles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see Address
             * @member {RedoxTypes.IAddress|undefined|undefined} Address
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.Address = undefined;
    
            /**
             * List of emails for the contact.
             * @member {Array.<string>} EmailAddresses
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.EmailAddresses = $util.emptyArray;
    
            /**
             * First name.
             * @member {string} FirstName
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.FirstName = "";
    
            /**
             * Last name.
             * @member {string} LastName
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.LastName = "";
    
            /**
             * Middle name - multiple middle names concatenated into this field.
             * @member {string} MiddleName
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.MiddleName = "";
    
            /**
             * @see PhoneNumber
             * @member {RedoxTypes.IPhoneNumber|undefined|undefined} PhoneNumber
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.PhoneNumber = undefined;
    
            /**
             * Personal relationship to the patient. e.g. Father, Spouse.
             * @member {string} RelationToPatient
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.RelationToPatient = "";
    
            /**
             * Role of this contact for the patient. e.g. Employer, Emergency Contact.
             * @member {Array.<string>} Roles
             * @memberof RedoxTypes.Contact
             * @instance
             */
            Contact.prototype.Roles = $util.emptyArray;
    
            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Contact
             * @static
             * @param {RedoxTypes.IContact=} [properties] Properties to set
             * @returns {RedoxTypes.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };
    
            /**
             * Encodes the specified Contact message. Does not implicitly {@link RedoxTypes.Contact.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Contact
             * @static
             * @param {RedoxTypes.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.EmailAddresses != undefined && message.EmailAddresses.length)
                    for (var i = 0; i < message.EmailAddresses.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.EmailAddresses[i]);
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.FirstName);
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.LastName);
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.MiddleName);
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    $root.RedoxTypes.PhoneNumber.encode(message.PhoneNumber, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.RelationToPatient != undefined && message.hasOwnProperty("RelationToPatient"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.RelationToPatient);
                if (message.Roles != undefined && message.Roles.length)
                    for (var i = 0; i < message.Roles.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.Roles[i]);
                return writer;
            };
    
            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link RedoxTypes.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Contact
             * @static
             * @param {RedoxTypes.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Contact();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.EmailAddresses && message.EmailAddresses.length))
                            message.EmailAddresses = [];
                        message.EmailAddresses.push(reader.string());
                        break;
                    case 3:
                        message.FirstName = reader.string();
                        break;
                    case 4:
                        message.LastName = reader.string();
                        break;
                    case 5:
                        message.MiddleName = reader.string();
                        break;
                    case 6:
                        message.PhoneNumber = $root.RedoxTypes.PhoneNumber.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.RelationToPatient = reader.string();
                        break;
                    case 8:
                        if (!(message.Roles && message.Roles.length))
                            message.Roles = [];
                        message.Roles.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof RedoxTypes.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Address != undefined && message.hasOwnProperty("Address")) {
                    var error = $root.RedoxTypes.Address.verify(message.Address);
                    if (error)
                        return "Address." + error;
                }
                if (message.EmailAddresses != undefined && message.hasOwnProperty("EmailAddresses")) {
                    if (!Array.isArray(message.EmailAddresses))
                        return "EmailAddresses: array expected";
                    for (var i = 0; i < message.EmailAddresses.length; ++i)
                        if (!$util.isString(message.EmailAddresses[i]))
                            return "EmailAddresses: string[] expected";
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    if (!$util.isString(message.FirstName))
                        return "FirstName: string expected";
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    if (!$util.isString(message.LastName))
                        return "LastName: string expected";
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    if (!$util.isString(message.MiddleName))
                        return "MiddleName: string expected";
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber")) {
                    var error = $root.RedoxTypes.PhoneNumber.verify(message.PhoneNumber);
                    if (error)
                        return "PhoneNumber." + error;
                }
                if (message.RelationToPatient != undefined && message.hasOwnProperty("RelationToPatient"))
                    if (!$util.isString(message.RelationToPatient))
                        return "RelationToPatient: string expected";
                if (message.Roles != undefined && message.hasOwnProperty("Roles")) {
                    if (!Array.isArray(message.Roles))
                        return "Roles: array expected";
                    for (var i = 0; i < message.Roles.length; ++i)
                        if (!$util.isString(message.Roles[i]))
                            return "Roles: string[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Contact)
                    return object;
                var message = new $root.RedoxTypes.Contact();
                if (object.Address != undefined) {
                    if (typeof object.Address !== "object")
                        throw TypeError(".RedoxTypes.Contact.Address: object expected");
                    message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                }
                if (object.EmailAddresses) {
                    if (!Array.isArray(object.EmailAddresses))
                        throw TypeError(".RedoxTypes.Contact.EmailAddresses: array expected");
                    message.EmailAddresses = [];
                    for (var i = 0; i < object.EmailAddresses.length; ++i)
                        message.EmailAddresses[i] = String(object.EmailAddresses[i]);
                }
                if (object.FirstName != undefined)
                    message.FirstName = String(object.FirstName);
                if (object.LastName != undefined)
                    message.LastName = String(object.LastName);
                if (object.MiddleName != undefined)
                    message.MiddleName = String(object.MiddleName);
                if (object.PhoneNumber != undefined) {
                    if (typeof object.PhoneNumber !== "object")
                        throw TypeError(".RedoxTypes.Contact.PhoneNumber: object expected");
                    message.PhoneNumber = $root.RedoxTypes.PhoneNumber.fromObject(object.PhoneNumber);
                }
                if (object.RelationToPatient != undefined)
                    message.RelationToPatient = String(object.RelationToPatient);
                if (object.Roles) {
                    if (!Array.isArray(object.Roles))
                        throw TypeError(".RedoxTypes.Contact.Roles: array expected");
                    message.Roles = [];
                    for (var i = 0; i < object.Roles.length; ++i)
                        message.Roles[i] = String(object.Roles[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Contact
             * @static
             * @param {RedoxTypes.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.EmailAddresses = [];
                    object.Roles = [];
                }
                if (options.defaults) {
                    object.Address = undefined;
                    object.FirstName = "";
                    object.LastName = "";
                    object.MiddleName = "";
                    object.PhoneNumber = undefined;
                    object.RelationToPatient = "";
                }
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                if (message.EmailAddresses && message.EmailAddresses.length) {
                    object.EmailAddresses = [];
                    for (var j = 0; j < message.EmailAddresses.length; ++j)
                        object.EmailAddresses[j] = message.EmailAddresses[j];
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    object.FirstName = message.FirstName;
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    object.LastName = message.LastName;
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    object.MiddleName = message.MiddleName;
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    object.PhoneNumber = $root.RedoxTypes.PhoneNumber.toObject(message.PhoneNumber, options);
                if (message.RelationToPatient != undefined && message.hasOwnProperty("RelationToPatient"))
                    object.RelationToPatient = message.RelationToPatient;
                if (message.Roles && message.Roles.length) {
                    object.Roles = [];
                    for (var j = 0; j < message.Roles.length; ++j)
                        object.Roles[j] = message.Roles[j];
                }
                return object;
            };
    
            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Contact;
        })();
    
        RedoxTypes.Demographics = (function() {
    
            /**
             * Properties of a Demographics.
             * @memberof RedoxTypes
             * @interface IDemographics
             * @property {RedoxTypes.IAddress|undefined} [Address] The patient's address.
             * @property {Array.<string>|undefined} [Citizenship] Reference: http://www.nationsonline.org/oneworld/country_code_list.htm
             * @property {string|undefined} [DeathDateTime] Date and time the patient was proclaimed deceased. (ISO 8601)
             * @property {string|undefined} [DOB] Patient's date of birth. (ISO 8601)
             * @property {Array.<string>|undefined} [EmailAddresses] List of emails for the patient.
             * @property {string|undefined} [FirstName] First name.
             * @property {boolean|undefined} [IsDeceased] He's dead, Jim.
             * @property {boolean|undefined} [IsHispanic] Is the patient hispanic?
             * @property {string|undefined} [Language] Patient's primary spoken language. In ISO 639-1 alpha values (e.g. 'en').
             * @property {string|undefined} [LastName] Last name.
             * @property {string|undefined} [MaritalStatus] Supported values: http://www.hl7.org/FHIR/v2/0002/index.html
             * @property {string|undefined} [MiddleName] Middle name - multiple middle names concatenated into this field.
             * @property {RedoxTypes.IPhoneNumber|undefined} [PhoneNumber] @see PhoneNumber
             * @property {string|undefined} [Race] The patient's race.
             * @property {string|undefined} [Sex] * The patient's sex.
             * * One of the following: "Female", "Male", "Unknown", "Other" (Redox).
             * @property {string|undefined} [SSN] The patient's social security number.
             */
    
            /**
             * Constructs a new Demographics.
             * @memberof RedoxTypes
             * @classdesc Descriptive patient information - modeled from Redox.
             * @implements IDemographics
             * @constructor
             * @param {RedoxTypes.IDemographics=} [properties] Properties to set
             */
            function Demographics(properties) {
                this.Citizenship = [];
                this.EmailAddresses = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * The patient's address.
             * @member {RedoxTypes.IAddress|undefined|undefined} Address
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.Address = undefined;
    
            /**
             * Reference: http://www.nationsonline.org/oneworld/country_code_list.htm
             * @member {Array.<string>} Citizenship
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.Citizenship = $util.emptyArray;
    
            /**
             * Date and time the patient was proclaimed deceased. (ISO 8601)
             * @member {string} DeathDateTime
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.DeathDateTime = "";
    
            /**
             * Patient's date of birth. (ISO 8601)
             * @member {string} DOB
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.DOB = "";
    
            /**
             * List of emails for the patient.
             * @member {Array.<string>} EmailAddresses
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.EmailAddresses = $util.emptyArray;
    
            /**
             * First name.
             * @member {string} FirstName
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.FirstName = "";
    
            /**
             * He's dead, Jim.
             * @member {boolean} IsDeceased
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.IsDeceased = false;
    
            /**
             * Is the patient hispanic?
             * @member {boolean} IsHispanic
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.IsHispanic = false;
    
            /**
             * Patient's primary spoken language. In ISO 639-1 alpha values (e.g. 'en').
             * @member {string} Language
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.Language = "";
    
            /**
             * Last name.
             * @member {string} LastName
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.LastName = "";
    
            /**
             * Supported values: http://www.hl7.org/FHIR/v2/0002/index.html
             * @member {string} MaritalStatus
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.MaritalStatus = "";
    
            /**
             * Middle name - multiple middle names concatenated into this field.
             * @member {string} MiddleName
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.MiddleName = "";
    
            /**
             * @see PhoneNumber
             * @member {RedoxTypes.IPhoneNumber|undefined|undefined} PhoneNumber
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.PhoneNumber = undefined;
    
            /**
             * The patient's race.
             * @member {string} Race
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.Race = "";
    
            /**
             * * The patient's sex.
             * * One of the following: "Female", "Male", "Unknown", "Other" (Redox).
             * @member {string} Sex
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.Sex = "";
    
            /**
             * The patient's social security number.
             * @member {string} SSN
             * @memberof RedoxTypes.Demographics
             * @instance
             */
            Demographics.prototype.SSN = "";
    
            /**
             * Creates a new Demographics instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {RedoxTypes.IDemographics=} [properties] Properties to set
             * @returns {RedoxTypes.Demographics} Demographics instance
             */
            Demographics.create = function create(properties) {
                return new Demographics(properties);
            };
    
            /**
             * Encodes the specified Demographics message. Does not implicitly {@link RedoxTypes.Demographics.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {RedoxTypes.IDemographics} message Demographics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Demographics.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Citizenship != undefined && message.Citizenship.length)
                    for (var i = 0; i < message.Citizenship.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Citizenship[i]);
                if (message.DeathDateTime != undefined && message.hasOwnProperty("DeathDateTime"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.DeathDateTime);
                if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.DOB);
                if (message.EmailAddresses != undefined && message.EmailAddresses.length)
                    for (var i = 0; i < message.EmailAddresses.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.EmailAddresses[i]);
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.FirstName);
                if (message.IsDeceased != undefined && message.hasOwnProperty("IsDeceased"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.IsDeceased);
                if (message.IsHispanic != undefined && message.hasOwnProperty("IsHispanic"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsHispanic);
                if (message.Language != undefined && message.hasOwnProperty("Language"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.Language);
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.LastName);
                if (message.MaritalStatus != undefined && message.hasOwnProperty("MaritalStatus"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.MaritalStatus);
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.MiddleName);
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    $root.RedoxTypes.PhoneNumber.encode(message.PhoneNumber, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.Race != undefined && message.hasOwnProperty("Race"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.Race);
                if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.Sex);
                if (message.SSN != undefined && message.hasOwnProperty("SSN"))
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.SSN);
                return writer;
            };
    
            /**
             * Encodes the specified Demographics message, length delimited. Does not implicitly {@link RedoxTypes.Demographics.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {RedoxTypes.IDemographics} message Demographics message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Demographics.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Demographics message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Demographics} Demographics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Demographics.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Demographics();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.Citizenship && message.Citizenship.length))
                            message.Citizenship = [];
                        message.Citizenship.push(reader.string());
                        break;
                    case 3:
                        message.DeathDateTime = reader.string();
                        break;
                    case 4:
                        message.DOB = reader.string();
                        break;
                    case 5:
                        if (!(message.EmailAddresses && message.EmailAddresses.length))
                            message.EmailAddresses = [];
                        message.EmailAddresses.push(reader.string());
                        break;
                    case 6:
                        message.FirstName = reader.string();
                        break;
                    case 7:
                        message.IsDeceased = reader.bool();
                        break;
                    case 8:
                        message.IsHispanic = reader.bool();
                        break;
                    case 9:
                        message.Language = reader.string();
                        break;
                    case 10:
                        message.LastName = reader.string();
                        break;
                    case 11:
                        message.MaritalStatus = reader.string();
                        break;
                    case 12:
                        message.MiddleName = reader.string();
                        break;
                    case 13:
                        message.PhoneNumber = $root.RedoxTypes.PhoneNumber.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.Race = reader.string();
                        break;
                    case 15:
                        message.Sex = reader.string();
                        break;
                    case 16:
                        message.SSN = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Demographics message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Demographics} Demographics
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Demographics.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Demographics message.
             * @function verify
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Demographics.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Address != undefined && message.hasOwnProperty("Address")) {
                    var error = $root.RedoxTypes.Address.verify(message.Address);
                    if (error)
                        return "Address." + error;
                }
                if (message.Citizenship != undefined && message.hasOwnProperty("Citizenship")) {
                    if (!Array.isArray(message.Citizenship))
                        return "Citizenship: array expected";
                    for (var i = 0; i < message.Citizenship.length; ++i)
                        if (!$util.isString(message.Citizenship[i]))
                            return "Citizenship: string[] expected";
                }
                if (message.DeathDateTime != undefined && message.hasOwnProperty("DeathDateTime"))
                    if (!$util.isString(message.DeathDateTime))
                        return "DeathDateTime: string expected";
                if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                    if (!$util.isString(message.DOB))
                        return "DOB: string expected";
                if (message.EmailAddresses != undefined && message.hasOwnProperty("EmailAddresses")) {
                    if (!Array.isArray(message.EmailAddresses))
                        return "EmailAddresses: array expected";
                    for (var i = 0; i < message.EmailAddresses.length; ++i)
                        if (!$util.isString(message.EmailAddresses[i]))
                            return "EmailAddresses: string[] expected";
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    if (!$util.isString(message.FirstName))
                        return "FirstName: string expected";
                if (message.IsDeceased != undefined && message.hasOwnProperty("IsDeceased"))
                    if (typeof message.IsDeceased !== "boolean")
                        return "IsDeceased: boolean expected";
                if (message.IsHispanic != undefined && message.hasOwnProperty("IsHispanic"))
                    if (typeof message.IsHispanic !== "boolean")
                        return "IsHispanic: boolean expected";
                if (message.Language != undefined && message.hasOwnProperty("Language"))
                    if (!$util.isString(message.Language))
                        return "Language: string expected";
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    if (!$util.isString(message.LastName))
                        return "LastName: string expected";
                if (message.MaritalStatus != undefined && message.hasOwnProperty("MaritalStatus"))
                    if (!$util.isString(message.MaritalStatus))
                        return "MaritalStatus: string expected";
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    if (!$util.isString(message.MiddleName))
                        return "MiddleName: string expected";
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber")) {
                    var error = $root.RedoxTypes.PhoneNumber.verify(message.PhoneNumber);
                    if (error)
                        return "PhoneNumber." + error;
                }
                if (message.Race != undefined && message.hasOwnProperty("Race"))
                    if (!$util.isString(message.Race))
                        return "Race: string expected";
                if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                    if (!$util.isString(message.Sex))
                        return "Sex: string expected";
                if (message.SSN != undefined && message.hasOwnProperty("SSN"))
                    if (!$util.isString(message.SSN))
                        return "SSN: string expected";
                return undefined;
            };
    
            /**
             * Creates a Demographics message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Demographics} Demographics
             */
            Demographics.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Demographics)
                    return object;
                var message = new $root.RedoxTypes.Demographics();
                if (object.Address != undefined) {
                    if (typeof object.Address !== "object")
                        throw TypeError(".RedoxTypes.Demographics.Address: object expected");
                    message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                }
                if (object.Citizenship) {
                    if (!Array.isArray(object.Citizenship))
                        throw TypeError(".RedoxTypes.Demographics.Citizenship: array expected");
                    message.Citizenship = [];
                    for (var i = 0; i < object.Citizenship.length; ++i)
                        message.Citizenship[i] = String(object.Citizenship[i]);
                }
                if (object.DeathDateTime != undefined)
                    message.DeathDateTime = String(object.DeathDateTime);
                if (object.DOB != undefined)
                    message.DOB = String(object.DOB);
                if (object.EmailAddresses) {
                    if (!Array.isArray(object.EmailAddresses))
                        throw TypeError(".RedoxTypes.Demographics.EmailAddresses: array expected");
                    message.EmailAddresses = [];
                    for (var i = 0; i < object.EmailAddresses.length; ++i)
                        message.EmailAddresses[i] = String(object.EmailAddresses[i]);
                }
                if (object.FirstName != undefined)
                    message.FirstName = String(object.FirstName);
                if (object.IsDeceased != undefined)
                    message.IsDeceased = Boolean(object.IsDeceased);
                if (object.IsHispanic != undefined)
                    message.IsHispanic = Boolean(object.IsHispanic);
                if (object.Language != undefined)
                    message.Language = String(object.Language);
                if (object.LastName != undefined)
                    message.LastName = String(object.LastName);
                if (object.MaritalStatus != undefined)
                    message.MaritalStatus = String(object.MaritalStatus);
                if (object.MiddleName != undefined)
                    message.MiddleName = String(object.MiddleName);
                if (object.PhoneNumber != undefined) {
                    if (typeof object.PhoneNumber !== "object")
                        throw TypeError(".RedoxTypes.Demographics.PhoneNumber: object expected");
                    message.PhoneNumber = $root.RedoxTypes.PhoneNumber.fromObject(object.PhoneNumber);
                }
                if (object.Race != undefined)
                    message.Race = String(object.Race);
                if (object.Sex != undefined)
                    message.Sex = String(object.Sex);
                if (object.SSN != undefined)
                    message.SSN = String(object.SSN);
                return message;
            };
    
            /**
             * Creates a plain object from a Demographics message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Demographics
             * @static
             * @param {RedoxTypes.Demographics} message Demographics
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Demographics.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.Citizenship = [];
                    object.EmailAddresses = [];
                }
                if (options.defaults) {
                    object.Address = undefined;
                    object.DeathDateTime = "";
                    object.DOB = "";
                    object.FirstName = "";
                    object.IsDeceased = false;
                    object.IsHispanic = false;
                    object.Language = "";
                    object.LastName = "";
                    object.MaritalStatus = "";
                    object.MiddleName = "";
                    object.PhoneNumber = undefined;
                    object.Race = "";
                    object.Sex = "";
                    object.SSN = "";
                }
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                if (message.Citizenship && message.Citizenship.length) {
                    object.Citizenship = [];
                    for (var j = 0; j < message.Citizenship.length; ++j)
                        object.Citizenship[j] = message.Citizenship[j];
                }
                if (message.DeathDateTime != undefined && message.hasOwnProperty("DeathDateTime"))
                    object.DeathDateTime = message.DeathDateTime;
                if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                    object.DOB = message.DOB;
                if (message.EmailAddresses && message.EmailAddresses.length) {
                    object.EmailAddresses = [];
                    for (var j = 0; j < message.EmailAddresses.length; ++j)
                        object.EmailAddresses[j] = message.EmailAddresses[j];
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    object.FirstName = message.FirstName;
                if (message.IsDeceased != undefined && message.hasOwnProperty("IsDeceased"))
                    object.IsDeceased = message.IsDeceased;
                if (message.IsHispanic != undefined && message.hasOwnProperty("IsHispanic"))
                    object.IsHispanic = message.IsHispanic;
                if (message.Language != undefined && message.hasOwnProperty("Language"))
                    object.Language = message.Language;
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    object.LastName = message.LastName;
                if (message.MaritalStatus != undefined && message.hasOwnProperty("MaritalStatus"))
                    object.MaritalStatus = message.MaritalStatus;
                if (message.MiddleName != undefined && message.hasOwnProperty("MiddleName"))
                    object.MiddleName = message.MiddleName;
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    object.PhoneNumber = $root.RedoxTypes.PhoneNumber.toObject(message.PhoneNumber, options);
                if (message.Race != undefined && message.hasOwnProperty("Race"))
                    object.Race = message.Race;
                if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                    object.Sex = message.Sex;
                if (message.SSN != undefined && message.hasOwnProperty("SSN"))
                    object.SSN = message.SSN;
                return object;
            };
    
            /**
             * Converts this Demographics to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Demographics
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Demographics.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Demographics;
        })();
    
        RedoxTypes.Identifier = (function() {
    
            /**
             * Properties of an Identifier.
             * @memberof RedoxTypes
             * @interface IIdentifier
             * @property {string} ID Unique ID value.
             * @property {string} IDType Type of ID. e.g. MRN, EPI.
             */
    
            /**
             * Constructs a new Identifier.
             * @memberof RedoxTypes
             * @classdesc Identifiers - from Redox.
             * @implements IIdentifier
             * @constructor
             * @param {RedoxTypes.IIdentifier=} [properties] Properties to set
             */
            function Identifier(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Unique ID value.
             * @member {string} ID
             * @memberof RedoxTypes.Identifier
             * @instance
             */
            Identifier.prototype.ID = "";
    
            /**
             * Type of ID. e.g. MRN, EPI.
             * @member {string} IDType
             * @memberof RedoxTypes.Identifier
             * @instance
             */
            Identifier.prototype.IDType = "";
    
            /**
             * Creates a new Identifier instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {RedoxTypes.IIdentifier=} [properties] Properties to set
             * @returns {RedoxTypes.Identifier} Identifier instance
             */
            Identifier.create = function create(properties) {
                return new Identifier(properties);
            };
    
            /**
             * Encodes the specified Identifier message. Does not implicitly {@link RedoxTypes.Identifier.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {RedoxTypes.IIdentifier} message Identifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Identifier.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ID);
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.IDType);
                return writer;
            };
    
            /**
             * Encodes the specified Identifier message, length delimited. Does not implicitly {@link RedoxTypes.Identifier.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {RedoxTypes.IIdentifier} message Identifier message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Identifier.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Identifier message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Identifier} Identifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Identifier.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Identifier();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ID = reader.string();
                        break;
                    case 2:
                        message.IDType = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("ID"))
                    throw $util.ProtocolError("missing required 'ID'", { instance: message });
                if (!message.hasOwnProperty("IDType"))
                    throw $util.ProtocolError("missing required 'IDType'", { instance: message });
                return message;
            };
    
            /**
             * Decodes an Identifier message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Identifier} Identifier
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Identifier.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Identifier message.
             * @function verify
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Identifier.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (!$util.isString(message.ID))
                    return "ID: string expected";
                if (!$util.isString(message.IDType))
                    return "IDType: string expected";
                return undefined;
            };
    
            /**
             * Creates an Identifier message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Identifier} Identifier
             */
            Identifier.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Identifier)
                    return object;
                var message = new $root.RedoxTypes.Identifier();
                if (object.ID != undefined)
                    message.ID = String(object.ID);
                if (object.IDType != undefined)
                    message.IDType = String(object.IDType);
                return message;
            };
    
            /**
             * Creates a plain object from an Identifier message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Identifier
             * @static
             * @param {RedoxTypes.Identifier} message Identifier
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Identifier.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.ID = "";
                    object.IDType = "";
                }
                if (message.ID != undefined && message.hasOwnProperty("ID"))
                    object.ID = message.ID;
                if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                    object.IDType = message.IDType;
                return object;
            };
    
            /**
             * Converts this Identifier to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Identifier
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Identifier.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Identifier;
        })();
    
        RedoxTypes.Insurance = (function() {
    
            /**
             * Properties of an Insurance.
             * @memberof RedoxTypes
             * @interface IInsurance
             * @property {string|undefined} [AgreementType] * Type of insurance agreement.
             * * One of the following: "Standard", "Unified", "Maternity" (Redox).
             * @property {RedoxTypes.Insurance.ICompanyType|undefined} [Company] @see CompanyType
             * @property {string|undefined} [CoverageType] * Type of insurance agreement. Indicates who will be receiving the bill for the service.
             * * One of the following: "Patient", "Clinic", "Insurance", "Other" (Redox).
             * @property {string|undefined} [EffectiveDate] Effective date of this insurance policy. (Redox uses YYYY-MM-DD).
             * @property {string|undefined} [ExpirationDate] Expiration date of this insurance policy. (Redox uses YYYY-MM-DD).
             * @property {string|undefined} [GroupName] Insurance policy group name.
             * @property {string|undefined} [GroupNumber] Insurance policy group number.
             * @property {RedoxTypes.Insurance.IInsuredType|undefined} [Insured] @see InsuredType
             * @property {string|undefined} [MemberNumber] Insurance member number.
             * @property {RedoxTypes.Insurance.IPlanType|undefined} [Plan] @see PlanType
             * @property {string|undefined} [PolicyNumber] Insurance policy number.
             */
    
            /**
             * Constructs a new Insurance.
             * @memberof RedoxTypes
             * @classdesc Patient's insurance info.
             * @implements IInsurance
             * @constructor
             * @param {RedoxTypes.IInsurance=} [properties] Properties to set
             */
            function Insurance(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * * Type of insurance agreement.
             * * One of the following: "Standard", "Unified", "Maternity" (Redox).
             * @member {string} AgreementType
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.AgreementType = "";
    
            /**
             * @see CompanyType
             * @member {RedoxTypes.Insurance.ICompanyType|undefined|undefined} Company
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.Company = undefined;
    
            /**
             * * Type of insurance agreement. Indicates who will be receiving the bill for the service.
             * * One of the following: "Patient", "Clinic", "Insurance", "Other" (Redox).
             * @member {string} CoverageType
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.CoverageType = "";
    
            /**
             * Effective date of this insurance policy. (Redox uses YYYY-MM-DD).
             * @member {string} EffectiveDate
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.EffectiveDate = "";
    
            /**
             * Expiration date of this insurance policy. (Redox uses YYYY-MM-DD).
             * @member {string} ExpirationDate
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.ExpirationDate = "";
    
            /**
             * Insurance policy group name.
             * @member {string} GroupName
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.GroupName = "";
    
            /**
             * Insurance policy group number.
             * @member {string} GroupNumber
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.GroupNumber = "";
    
            /**
             * @see InsuredType
             * @member {RedoxTypes.Insurance.IInsuredType|undefined|undefined} Insured
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.Insured = undefined;
    
            /**
             * Insurance member number.
             * @member {string} MemberNumber
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.MemberNumber = "";
    
            /**
             * @see PlanType
             * @member {RedoxTypes.Insurance.IPlanType|undefined|undefined} Plan
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.Plan = undefined;
    
            /**
             * Insurance policy number.
             * @member {string} PolicyNumber
             * @memberof RedoxTypes.Insurance
             * @instance
             */
            Insurance.prototype.PolicyNumber = "";
    
            /**
             * Creates a new Insurance instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {RedoxTypes.IInsurance=} [properties] Properties to set
             * @returns {RedoxTypes.Insurance} Insurance instance
             */
            Insurance.create = function create(properties) {
                return new Insurance(properties);
            };
    
            /**
             * Encodes the specified Insurance message. Does not implicitly {@link RedoxTypes.Insurance.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {RedoxTypes.IInsurance} message Insurance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Insurance.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.AgreementType != undefined && message.hasOwnProperty("AgreementType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.AgreementType);
                if (message.CoverageType != undefined && message.hasOwnProperty("CoverageType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.CoverageType);
                if (message.EffectiveDate != undefined && message.hasOwnProperty("EffectiveDate"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.EffectiveDate);
                if (message.ExpirationDate != undefined && message.hasOwnProperty("ExpirationDate"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.ExpirationDate);
                if (message.GroupNumber != undefined && message.hasOwnProperty("GroupNumber"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.GroupNumber);
                if (message.GroupName != undefined && message.hasOwnProperty("GroupName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.GroupName);
                if (message.Company != undefined && message.hasOwnProperty("Company"))
                    $root.RedoxTypes.Insurance.CompanyType.encode(message.Company, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.Insured != undefined && message.hasOwnProperty("Insured"))
                    $root.RedoxTypes.Insurance.InsuredType.encode(message.Insured, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.MemberNumber != undefined && message.hasOwnProperty("MemberNumber"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.MemberNumber);
                if (message.Plan != undefined && message.hasOwnProperty("Plan"))
                    $root.RedoxTypes.Insurance.PlanType.encode(message.Plan, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.PolicyNumber != undefined && message.hasOwnProperty("PolicyNumber"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.PolicyNumber);
                return writer;
            };
    
            /**
             * Encodes the specified Insurance message, length delimited. Does not implicitly {@link RedoxTypes.Insurance.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {RedoxTypes.IInsurance} message Insurance message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Insurance.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Insurance message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Insurance} Insurance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Insurance.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Insurance();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.AgreementType = reader.string();
                        break;
                    case 7:
                        message.Company = $root.RedoxTypes.Insurance.CompanyType.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.CoverageType = reader.string();
                        break;
                    case 3:
                        message.EffectiveDate = reader.string();
                        break;
                    case 4:
                        message.ExpirationDate = reader.string();
                        break;
                    case 6:
                        message.GroupName = reader.string();
                        break;
                    case 5:
                        message.GroupNumber = reader.string();
                        break;
                    case 8:
                        message.Insured = $root.RedoxTypes.Insurance.InsuredType.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.MemberNumber = reader.string();
                        break;
                    case 10:
                        message.Plan = $root.RedoxTypes.Insurance.PlanType.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.PolicyNumber = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Insurance message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Insurance} Insurance
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Insurance.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Insurance message.
             * @function verify
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Insurance.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.AgreementType != undefined && message.hasOwnProperty("AgreementType"))
                    if (!$util.isString(message.AgreementType))
                        return "AgreementType: string expected";
                if (message.Company != undefined && message.hasOwnProperty("Company")) {
                    var error = $root.RedoxTypes.Insurance.CompanyType.verify(message.Company);
                    if (error)
                        return "Company." + error;
                }
                if (message.CoverageType != undefined && message.hasOwnProperty("CoverageType"))
                    if (!$util.isString(message.CoverageType))
                        return "CoverageType: string expected";
                if (message.EffectiveDate != undefined && message.hasOwnProperty("EffectiveDate"))
                    if (!$util.isString(message.EffectiveDate))
                        return "EffectiveDate: string expected";
                if (message.ExpirationDate != undefined && message.hasOwnProperty("ExpirationDate"))
                    if (!$util.isString(message.ExpirationDate))
                        return "ExpirationDate: string expected";
                if (message.GroupName != undefined && message.hasOwnProperty("GroupName"))
                    if (!$util.isString(message.GroupName))
                        return "GroupName: string expected";
                if (message.GroupNumber != undefined && message.hasOwnProperty("GroupNumber"))
                    if (!$util.isString(message.GroupNumber))
                        return "GroupNumber: string expected";
                if (message.Insured != undefined && message.hasOwnProperty("Insured")) {
                    var error = $root.RedoxTypes.Insurance.InsuredType.verify(message.Insured);
                    if (error)
                        return "Insured." + error;
                }
                if (message.MemberNumber != undefined && message.hasOwnProperty("MemberNumber"))
                    if (!$util.isString(message.MemberNumber))
                        return "MemberNumber: string expected";
                if (message.Plan != undefined && message.hasOwnProperty("Plan")) {
                    var error = $root.RedoxTypes.Insurance.PlanType.verify(message.Plan);
                    if (error)
                        return "Plan." + error;
                }
                if (message.PolicyNumber != undefined && message.hasOwnProperty("PolicyNumber"))
                    if (!$util.isString(message.PolicyNumber))
                        return "PolicyNumber: string expected";
                return undefined;
            };
    
            /**
             * Creates an Insurance message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Insurance} Insurance
             */
            Insurance.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Insurance)
                    return object;
                var message = new $root.RedoxTypes.Insurance();
                if (object.AgreementType != undefined)
                    message.AgreementType = String(object.AgreementType);
                if (object.Company != undefined) {
                    if (typeof object.Company !== "object")
                        throw TypeError(".RedoxTypes.Insurance.Company: object expected");
                    message.Company = $root.RedoxTypes.Insurance.CompanyType.fromObject(object.Company);
                }
                if (object.CoverageType != undefined)
                    message.CoverageType = String(object.CoverageType);
                if (object.EffectiveDate != undefined)
                    message.EffectiveDate = String(object.EffectiveDate);
                if (object.ExpirationDate != undefined)
                    message.ExpirationDate = String(object.ExpirationDate);
                if (object.GroupName != undefined)
                    message.GroupName = String(object.GroupName);
                if (object.GroupNumber != undefined)
                    message.GroupNumber = String(object.GroupNumber);
                if (object.Insured != undefined) {
                    if (typeof object.Insured !== "object")
                        throw TypeError(".RedoxTypes.Insurance.Insured: object expected");
                    message.Insured = $root.RedoxTypes.Insurance.InsuredType.fromObject(object.Insured);
                }
                if (object.MemberNumber != undefined)
                    message.MemberNumber = String(object.MemberNumber);
                if (object.Plan != undefined) {
                    if (typeof object.Plan !== "object")
                        throw TypeError(".RedoxTypes.Insurance.Plan: object expected");
                    message.Plan = $root.RedoxTypes.Insurance.PlanType.fromObject(object.Plan);
                }
                if (object.PolicyNumber != undefined)
                    message.PolicyNumber = String(object.PolicyNumber);
                return message;
            };
    
            /**
             * Creates a plain object from an Insurance message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Insurance
             * @static
             * @param {RedoxTypes.Insurance} message Insurance
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Insurance.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.AgreementType = "";
                    object.CoverageType = "";
                    object.EffectiveDate = "";
                    object.ExpirationDate = "";
                    object.GroupNumber = "";
                    object.GroupName = "";
                    object.Company = undefined;
                    object.Insured = undefined;
                    object.MemberNumber = "";
                    object.Plan = undefined;
                    object.PolicyNumber = "";
                }
                if (message.AgreementType != undefined && message.hasOwnProperty("AgreementType"))
                    object.AgreementType = message.AgreementType;
                if (message.CoverageType != undefined && message.hasOwnProperty("CoverageType"))
                    object.CoverageType = message.CoverageType;
                if (message.EffectiveDate != undefined && message.hasOwnProperty("EffectiveDate"))
                    object.EffectiveDate = message.EffectiveDate;
                if (message.ExpirationDate != undefined && message.hasOwnProperty("ExpirationDate"))
                    object.ExpirationDate = message.ExpirationDate;
                if (message.GroupNumber != undefined && message.hasOwnProperty("GroupNumber"))
                    object.GroupNumber = message.GroupNumber;
                if (message.GroupName != undefined && message.hasOwnProperty("GroupName"))
                    object.GroupName = message.GroupName;
                if (message.Company != undefined && message.hasOwnProperty("Company"))
                    object.Company = $root.RedoxTypes.Insurance.CompanyType.toObject(message.Company, options);
                if (message.Insured != undefined && message.hasOwnProperty("Insured"))
                    object.Insured = $root.RedoxTypes.Insurance.InsuredType.toObject(message.Insured, options);
                if (message.MemberNumber != undefined && message.hasOwnProperty("MemberNumber"))
                    object.MemberNumber = message.MemberNumber;
                if (message.Plan != undefined && message.hasOwnProperty("Plan"))
                    object.Plan = $root.RedoxTypes.Insurance.PlanType.toObject(message.Plan, options);
                if (message.PolicyNumber != undefined && message.hasOwnProperty("PolicyNumber"))
                    object.PolicyNumber = message.PolicyNumber;
                return object;
            };
    
            /**
             * Converts this Insurance to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Insurance
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Insurance.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            Insurance.CompanyType = (function() {
    
                /**
                 * Properties of a CompanyType.
                 * @memberof RedoxTypes.Insurance
                 * @interface ICompanyType
                 * @property {RedoxTypes.IAddress|undefined} [Address] @see Address
                 * @property {string|undefined} [ID] ID of insurance company (payor).
                 * @property {string|undefined} [IDType] ID type of insurance company (payor).
                 * @property {string|undefined} [Name] Name of insurance company (payor).
                 * @property {string|undefined} [PhoneNumber] Insurance company's phone number. In E. 164 Format (i.e. +16085551234).
                 */
    
                /**
                 * Constructs a new CompanyType.
                 * @memberof RedoxTypes.Insurance
                 * @classdesc The insurance company.
                 * @implements ICompanyType
                 * @constructor
                 * @param {RedoxTypes.Insurance.ICompanyType=} [properties] Properties to set
                 */
                function CompanyType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != undefined)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * @see Address
                 * @member {RedoxTypes.IAddress|undefined|undefined} Address
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 */
                CompanyType.prototype.Address = undefined;
    
                /**
                 * ID of insurance company (payor).
                 * @member {string} ID
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 */
                CompanyType.prototype.ID = "";
    
                /**
                 * ID type of insurance company (payor).
                 * @member {string} IDType
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 */
                CompanyType.prototype.IDType = "";
    
                /**
                 * Name of insurance company (payor).
                 * @member {string} Name
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 */
                CompanyType.prototype.Name = "";
    
                /**
                 * Insurance company's phone number. In E. 164 Format (i.e. +16085551234).
                 * @member {string} PhoneNumber
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 */
                CompanyType.prototype.PhoneNumber = "";
    
                /**
                 * Creates a new CompanyType instance using the specified properties.
                 * @function create
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {RedoxTypes.Insurance.ICompanyType=} [properties] Properties to set
                 * @returns {RedoxTypes.Insurance.CompanyType} CompanyType instance
                 */
                CompanyType.create = function create(properties) {
                    return new CompanyType(properties);
                };
    
                /**
                 * Encodes the specified CompanyType message. Does not implicitly {@link RedoxTypes.Insurance.CompanyType.verify|verify} messages.
                 * @function encode
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {RedoxTypes.Insurance.ICompanyType} message CompanyType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompanyType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Address != undefined && message.hasOwnProperty("Address"))
                        $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.ID);
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.IDType);
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Name);
                    if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.PhoneNumber);
                    return writer;
                };
    
                /**
                 * Encodes the specified CompanyType message, length delimited. Does not implicitly {@link RedoxTypes.Insurance.CompanyType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {RedoxTypes.Insurance.ICompanyType} message CompanyType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CompanyType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CompanyType message from the specified reader or buffer.
                 * @function decode
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {RedoxTypes.Insurance.CompanyType} CompanyType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompanyType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Insurance.CompanyType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.ID = reader.string();
                            break;
                        case 3:
                            message.IDType = reader.string();
                            break;
                        case 4:
                            message.Name = reader.string();
                            break;
                        case 5:
                            message.PhoneNumber = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CompanyType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {RedoxTypes.Insurance.CompanyType} CompanyType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CompanyType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CompanyType message.
                 * @function verify
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
                 */
                CompanyType.verify = function verify(message) {
                    if (typeof message !== "object" || message === undefined)
                        return "object expected";
                    if (message.Address != undefined && message.hasOwnProperty("Address")) {
                        var error = $root.RedoxTypes.Address.verify(message.Address);
                        if (error)
                            return "Address." + error;
                    }
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        if (!$util.isString(message.IDType))
                            return "IDType: string expected";
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        if (!$util.isString(message.Name))
                            return "Name: string expected";
                    if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                        if (!$util.isString(message.PhoneNumber))
                            return "PhoneNumber: string expected";
                    return undefined;
                };
    
                /**
                 * Creates a CompanyType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {RedoxTypes.Insurance.CompanyType} CompanyType
                 */
                CompanyType.fromObject = function fromObject(object) {
                    if (object instanceof $root.RedoxTypes.Insurance.CompanyType)
                        return object;
                    var message = new $root.RedoxTypes.Insurance.CompanyType();
                    if (object.Address != undefined) {
                        if (typeof object.Address !== "object")
                            throw TypeError(".RedoxTypes.Insurance.CompanyType.Address: object expected");
                        message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                    }
                    if (object.ID != undefined)
                        message.ID = String(object.ID);
                    if (object.IDType != undefined)
                        message.IDType = String(object.IDType);
                    if (object.Name != undefined)
                        message.Name = String(object.Name);
                    if (object.PhoneNumber != undefined)
                        message.PhoneNumber = String(object.PhoneNumber);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CompanyType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @static
                 * @param {RedoxTypes.Insurance.CompanyType} message CompanyType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CompanyType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Address = undefined;
                        object.ID = "";
                        object.IDType = "";
                        object.Name = "";
                        object.PhoneNumber = "";
                    }
                    if (message.Address != undefined && message.hasOwnProperty("Address"))
                        object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        object.IDType = message.IDType;
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        object.Name = message.Name;
                    if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                        object.PhoneNumber = message.PhoneNumber;
                    return object;
                };
    
                /**
                 * Converts this CompanyType to JSON.
                 * @function toJSON
                 * @memberof RedoxTypes.Insurance.CompanyType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CompanyType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CompanyType;
            })();
    
            Insurance.InsuredType = (function() {
    
                /**
                 * Properties of an InsuredType.
                 * @memberof RedoxTypes.Insurance
                 * @interface IInsuredType
                 * @property {RedoxTypes.IAddress|undefined} [Address] @see Address
                 * @property {string|undefined} [DOB] Insurance policy holder's date of birth. (ISO 8601)
                 * @property {string|undefined} [FirstName] First name.
                 * @property {string|undefined} [LastName] Last name.
                 * @property {string|undefined} [Relationship] * Relationship of the insured to the patient.
                 * * One of the following: "Self", "Spouse", "Other" (Redox).
                 * @property {string|undefined} [Sex] * Insurance policy holder's sex.
                 * * One of the following: "Female", "Male", "Unknown", "Other" (Redox).
                 */
    
                /**
                 * Constructs a new InsuredType.
                 * @memberof RedoxTypes.Insurance
                 * @classdesc Individual who has the agreement with the insurance company for the related policy.
                 * @implements IInsuredType
                 * @constructor
                 * @param {RedoxTypes.Insurance.IInsuredType=} [properties] Properties to set
                 */
                function InsuredType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != undefined)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * @see Address
                 * @member {RedoxTypes.IAddress|undefined|undefined} Address
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.Address = undefined;
    
                /**
                 * Insurance policy holder's date of birth. (ISO 8601)
                 * @member {string} DOB
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.DOB = "";
    
                /**
                 * First name.
                 * @member {string} FirstName
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.FirstName = "";
    
                /**
                 * Last name.
                 * @member {string} LastName
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.LastName = "";
    
                /**
                 * * Relationship of the insured to the patient.
                 * * One of the following: "Self", "Spouse", "Other" (Redox).
                 * @member {string} Relationship
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.Relationship = "";
    
                /**
                 * * Insurance policy holder's sex.
                 * * One of the following: "Female", "Male", "Unknown", "Other" (Redox).
                 * @member {string} Sex
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 */
                InsuredType.prototype.Sex = "";
    
                /**
                 * Creates a new InsuredType instance using the specified properties.
                 * @function create
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {RedoxTypes.Insurance.IInsuredType=} [properties] Properties to set
                 * @returns {RedoxTypes.Insurance.InsuredType} InsuredType instance
                 */
                InsuredType.create = function create(properties) {
                    return new InsuredType(properties);
                };
    
                /**
                 * Encodes the specified InsuredType message. Does not implicitly {@link RedoxTypes.Insurance.InsuredType.verify|verify} messages.
                 * @function encode
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {RedoxTypes.Insurance.IInsuredType} message InsuredType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsuredType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.Address != undefined && message.hasOwnProperty("Address"))
                        $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.DOB);
                    if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.FirstName);
                    if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.LastName);
                    if (message.Relationship != undefined && message.hasOwnProperty("Relationship"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.Relationship);
                    if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.Sex);
                    return writer;
                };
    
                /**
                 * Encodes the specified InsuredType message, length delimited. Does not implicitly {@link RedoxTypes.Insurance.InsuredType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {RedoxTypes.Insurance.IInsuredType} message InsuredType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsuredType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InsuredType message from the specified reader or buffer.
                 * @function decode
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {RedoxTypes.Insurance.InsuredType} InsuredType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsuredType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Insurance.InsuredType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.DOB = reader.string();
                            break;
                        case 3:
                            message.FirstName = reader.string();
                            break;
                        case 4:
                            message.LastName = reader.string();
                            break;
                        case 5:
                            message.Relationship = reader.string();
                            break;
                        case 6:
                            message.Sex = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InsuredType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {RedoxTypes.Insurance.InsuredType} InsuredType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsuredType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InsuredType message.
                 * @function verify
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
                 */
                InsuredType.verify = function verify(message) {
                    if (typeof message !== "object" || message === undefined)
                        return "object expected";
                    if (message.Address != undefined && message.hasOwnProperty("Address")) {
                        var error = $root.RedoxTypes.Address.verify(message.Address);
                        if (error)
                            return "Address." + error;
                    }
                    if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                        if (!$util.isString(message.DOB))
                            return "DOB: string expected";
                    if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                        if (!$util.isString(message.FirstName))
                            return "FirstName: string expected";
                    if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                        if (!$util.isString(message.LastName))
                            return "LastName: string expected";
                    if (message.Relationship != undefined && message.hasOwnProperty("Relationship"))
                        if (!$util.isString(message.Relationship))
                            return "Relationship: string expected";
                    if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                        if (!$util.isString(message.Sex))
                            return "Sex: string expected";
                    return undefined;
                };
    
                /**
                 * Creates an InsuredType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {RedoxTypes.Insurance.InsuredType} InsuredType
                 */
                InsuredType.fromObject = function fromObject(object) {
                    if (object instanceof $root.RedoxTypes.Insurance.InsuredType)
                        return object;
                    var message = new $root.RedoxTypes.Insurance.InsuredType();
                    if (object.Address != undefined) {
                        if (typeof object.Address !== "object")
                            throw TypeError(".RedoxTypes.Insurance.InsuredType.Address: object expected");
                        message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                    }
                    if (object.DOB != undefined)
                        message.DOB = String(object.DOB);
                    if (object.FirstName != undefined)
                        message.FirstName = String(object.FirstName);
                    if (object.LastName != undefined)
                        message.LastName = String(object.LastName);
                    if (object.Relationship != undefined)
                        message.Relationship = String(object.Relationship);
                    if (object.Sex != undefined)
                        message.Sex = String(object.Sex);
                    return message;
                };
    
                /**
                 * Creates a plain object from an InsuredType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @static
                 * @param {RedoxTypes.Insurance.InsuredType} message InsuredType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InsuredType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.Address = undefined;
                        object.DOB = "";
                        object.FirstName = "";
                        object.LastName = "";
                        object.Relationship = "";
                        object.Sex = "";
                    }
                    if (message.Address != undefined && message.hasOwnProperty("Address"))
                        object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                    if (message.DOB != undefined && message.hasOwnProperty("DOB"))
                        object.DOB = message.DOB;
                    if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                        object.FirstName = message.FirstName;
                    if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                        object.LastName = message.LastName;
                    if (message.Relationship != undefined && message.hasOwnProperty("Relationship"))
                        object.Relationship = message.Relationship;
                    if (message.Sex != undefined && message.hasOwnProperty("Sex"))
                        object.Sex = message.Sex;
                    return object;
                };
    
                /**
                 * Converts this InsuredType to JSON.
                 * @function toJSON
                 * @memberof RedoxTypes.Insurance.InsuredType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InsuredType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InsuredType;
            })();
    
            Insurance.PlanType = (function() {
    
                /**
                 * Properties of a PlanType.
                 * @memberof RedoxTypes.Insurance
                 * @interface IPlanType
                 * @property {string|undefined} [ID] Identifier of insurance plan.
                 * @property {string|undefined} [IDType] ID type of insurance plan.
                 * @property {string|undefined} [Name] Name of insurance plan.
                 * @property {string|undefined} [Type] Type of insurance plan.
                 */
    
                /**
                 * Constructs a new PlanType.
                 * @memberof RedoxTypes.Insurance
                 * @classdesc The insurance plan.
                 * @implements IPlanType
                 * @constructor
                 * @param {RedoxTypes.Insurance.IPlanType=} [properties] Properties to set
                 */
                function PlanType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != undefined)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Identifier of insurance plan.
                 * @member {string} ID
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @instance
                 */
                PlanType.prototype.ID = "";
    
                /**
                 * ID type of insurance plan.
                 * @member {string} IDType
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @instance
                 */
                PlanType.prototype.IDType = "";
    
                /**
                 * Name of insurance plan.
                 * @member {string} Name
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @instance
                 */
                PlanType.prototype.Name = "";
    
                /**
                 * Type of insurance plan.
                 * @member {string} Type
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @instance
                 */
                PlanType.prototype.Type = "";
    
                /**
                 * Creates a new PlanType instance using the specified properties.
                 * @function create
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {RedoxTypes.Insurance.IPlanType=} [properties] Properties to set
                 * @returns {RedoxTypes.Insurance.PlanType} PlanType instance
                 */
                PlanType.create = function create(properties) {
                    return new PlanType(properties);
                };
    
                /**
                 * Encodes the specified PlanType message. Does not implicitly {@link RedoxTypes.Insurance.PlanType.verify|verify} messages.
                 * @function encode
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {RedoxTypes.Insurance.IPlanType} message PlanType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlanType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ID);
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.IDType);
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
                    if (message.Type != undefined && message.hasOwnProperty("Type"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.Type);
                    return writer;
                };
    
                /**
                 * Encodes the specified PlanType message, length delimited. Does not implicitly {@link RedoxTypes.Insurance.PlanType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {RedoxTypes.Insurance.IPlanType} message PlanType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PlanType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PlanType message from the specified reader or buffer.
                 * @function decode
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {RedoxTypes.Insurance.PlanType} PlanType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlanType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Insurance.PlanType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ID = reader.string();
                            break;
                        case 2:
                            message.IDType = reader.string();
                            break;
                        case 3:
                            message.Name = reader.string();
                            break;
                        case 4:
                            message.Type = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PlanType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {RedoxTypes.Insurance.PlanType} PlanType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PlanType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PlanType message.
                 * @function verify
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
                 */
                PlanType.verify = function verify(message) {
                    if (typeof message !== "object" || message === undefined)
                        return "object expected";
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        if (!$util.isString(message.ID))
                            return "ID: string expected";
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        if (!$util.isString(message.IDType))
                            return "IDType: string expected";
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        if (!$util.isString(message.Name))
                            return "Name: string expected";
                    if (message.Type != undefined && message.hasOwnProperty("Type"))
                        if (!$util.isString(message.Type))
                            return "Type: string expected";
                    return undefined;
                };
    
                /**
                 * Creates a PlanType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {RedoxTypes.Insurance.PlanType} PlanType
                 */
                PlanType.fromObject = function fromObject(object) {
                    if (object instanceof $root.RedoxTypes.Insurance.PlanType)
                        return object;
                    var message = new $root.RedoxTypes.Insurance.PlanType();
                    if (object.ID != undefined)
                        message.ID = String(object.ID);
                    if (object.IDType != undefined)
                        message.IDType = String(object.IDType);
                    if (object.Name != undefined)
                        message.Name = String(object.Name);
                    if (object.Type != undefined)
                        message.Type = String(object.Type);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PlanType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @static
                 * @param {RedoxTypes.Insurance.PlanType} message PlanType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PlanType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ID = "";
                        object.IDType = "";
                        object.Name = "";
                        object.Type = "";
                    }
                    if (message.ID != undefined && message.hasOwnProperty("ID"))
                        object.ID = message.ID;
                    if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                        object.IDType = message.IDType;
                    if (message.Name != undefined && message.hasOwnProperty("Name"))
                        object.Name = message.Name;
                    if (message.Type != undefined && message.hasOwnProperty("Type"))
                        object.Type = message.Type;
                    return object;
                };
    
                /**
                 * Converts this PlanType to JSON.
                 * @function toJSON
                 * @memberof RedoxTypes.Insurance.PlanType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PlanType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PlanType;
            })();
    
            return Insurance;
        })();
    
        RedoxTypes.Location = (function() {
    
            /**
             * Properties of a Location.
             * @memberof RedoxTypes
             * @interface ILocation
             * @property {string|undefined} [Department] Department.
             * @property {string|undefined} [Facility] e.g. Community Hospital.
             * @property {string|undefined} [Room] e.g. 136.
             * @property {string|undefined} [Type] e.g. Clinic, Department, Home, Nursing Unit, Provider's Office, Phone.
             */
    
            /**
             * Constructs a new Location.
             * @memberof RedoxTypes
             * @classdesc Location details.
             * @implements ILocation
             * @constructor
             * @param {RedoxTypes.ILocation=} [properties] Properties to set
             */
            function Location(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Department.
             * @member {string} Department
             * @memberof RedoxTypes.Location
             * @instance
             */
            Location.prototype.Department = "";
    
            /**
             * e.g. Community Hospital.
             * @member {string} Facility
             * @memberof RedoxTypes.Location
             * @instance
             */
            Location.prototype.Facility = "";
    
            /**
             * e.g. 136.
             * @member {string} Room
             * @memberof RedoxTypes.Location
             * @instance
             */
            Location.prototype.Room = "";
    
            /**
             * e.g. Clinic, Department, Home, Nursing Unit, Provider's Office, Phone.
             * @member {string} Type
             * @memberof RedoxTypes.Location
             * @instance
             */
            Location.prototype.Type = "";
    
            /**
             * Creates a new Location instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Location
             * @static
             * @param {RedoxTypes.ILocation=} [properties] Properties to set
             * @returns {RedoxTypes.Location} Location instance
             */
            Location.create = function create(properties) {
                return new Location(properties);
            };
    
            /**
             * Encodes the specified Location message. Does not implicitly {@link RedoxTypes.Location.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Location
             * @static
             * @param {RedoxTypes.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Department != undefined && message.hasOwnProperty("Department"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Department);
                if (message.Facility != undefined && message.hasOwnProperty("Facility"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Facility);
                if (message.Room != undefined && message.hasOwnProperty("Room"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Room);
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.Type);
                return writer;
            };
    
            /**
             * Encodes the specified Location message, length delimited. Does not implicitly {@link RedoxTypes.Location.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Location
             * @static
             * @param {RedoxTypes.ILocation} message Location message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Location.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Location message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Location();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Department = reader.string();
                        break;
                    case 2:
                        message.Facility = reader.string();
                        break;
                    case 3:
                        message.Room = reader.string();
                        break;
                    case 4:
                        message.Type = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Location message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Location
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Location} Location
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Location.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Location message.
             * @function verify
             * @memberof RedoxTypes.Location
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Location.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Department != undefined && message.hasOwnProperty("Department"))
                    if (!$util.isString(message.Department))
                        return "Department: string expected";
                if (message.Facility != undefined && message.hasOwnProperty("Facility"))
                    if (!$util.isString(message.Facility))
                        return "Facility: string expected";
                if (message.Room != undefined && message.hasOwnProperty("Room"))
                    if (!$util.isString(message.Room))
                        return "Room: string expected";
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    if (!$util.isString(message.Type))
                        return "Type: string expected";
                return undefined;
            };
    
            /**
             * Creates a Location message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Location
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Location} Location
             */
            Location.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Location)
                    return object;
                var message = new $root.RedoxTypes.Location();
                if (object.Department != undefined)
                    message.Department = String(object.Department);
                if (object.Facility != undefined)
                    message.Facility = String(object.Facility);
                if (object.Room != undefined)
                    message.Room = String(object.Room);
                if (object.Type != undefined)
                    message.Type = String(object.Type);
                return message;
            };
    
            /**
             * Creates a plain object from a Location message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Location
             * @static
             * @param {RedoxTypes.Location} message Location
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Location.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Department = "";
                    object.Facility = "";
                    object.Room = "";
                    object.Type = "";
                }
                if (message.Department != undefined && message.hasOwnProperty("Department"))
                    object.Department = message.Department;
                if (message.Facility != undefined && message.hasOwnProperty("Facility"))
                    object.Facility = message.Facility;
                if (message.Room != undefined && message.hasOwnProperty("Room"))
                    object.Room = message.Room;
                if (message.Type != undefined && message.hasOwnProperty("Type"))
                    object.Type = message.Type;
                return object;
            };
    
            /**
             * Converts this Location to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Location
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Location.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Location;
        })();
    
        RedoxTypes.PCP = (function() {
    
            /**
             * Properties of a PCP.
             * @memberof RedoxTypes
             * @interface IPCP
             * @property {RedoxTypes.IAddress|undefined} [Address] @see Provider.Address
             * @property {Array.<string>|undefined} [Credentials] @see Provider.Credentials
             * @property {string|undefined} [FirstName] @see Provider.FirstName
             * @property {string} ID @see Provider.ID
             * @property {string} IDType @see Provider.IDType
             * @property {string|undefined} [LastName] @see Provider.LastName
             * @property {RedoxTypes.ILocation|undefined} [Location] @see Provider.Location
             * @property {string|undefined} [NPI] National Provider Identifier for the primary care provider.
             * @property {RedoxTypes.IPhoneNumber|undefined} [PhoneNumber] @see Provider.PhoneNumber
             */
    
            /**
             * Constructs a new PCP.
             * @memberof RedoxTypes
             * @classdesc Primary Care Provider for the Patient.
             * @implements IPCP
             * @constructor
             * @param {RedoxTypes.IPCP=} [properties] Properties to set
             */
            function PCP(properties) {
                this.Credentials = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see Provider.Address
             * @member {RedoxTypes.IAddress|undefined|undefined} Address
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.Address = undefined;
    
            /**
             * @see Provider.Credentials
             * @member {Array.<string>} Credentials
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.Credentials = $util.emptyArray;
    
            /**
             * @see Provider.FirstName
             * @member {string} FirstName
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.FirstName = "";
    
            /**
             * @see Provider.ID
             * @member {string} ID
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.ID = "";
    
            /**
             * @see Provider.IDType
             * @member {string} IDType
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.IDType = "";
    
            /**
             * @see Provider.LastName
             * @member {string} LastName
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.LastName = "";
    
            /**
             * @see Provider.Location
             * @member {RedoxTypes.ILocation|undefined|undefined} Location
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.Location = undefined;
    
            /**
             * National Provider Identifier for the primary care provider.
             * @member {string} NPI
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.NPI = "";
    
            /**
             * @see Provider.PhoneNumber
             * @member {RedoxTypes.IPhoneNumber|undefined|undefined} PhoneNumber
             * @memberof RedoxTypes.PCP
             * @instance
             */
            PCP.prototype.PhoneNumber = undefined;
    
            /**
             * Creates a new PCP instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.PCP
             * @static
             * @param {RedoxTypes.IPCP=} [properties] Properties to set
             * @returns {RedoxTypes.PCP} PCP instance
             */
            PCP.create = function create(properties) {
                return new PCP(properties);
            };
    
            /**
             * Encodes the specified PCP message. Does not implicitly {@link RedoxTypes.PCP.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.PCP
             * @static
             * @param {RedoxTypes.IPCP} message PCP message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PCP.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Credentials != undefined && message.Credentials.length)
                    for (var i = 0; i < message.Credentials.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Credentials[i]);
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.FirstName);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ID);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.IDType);
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.LastName);
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    $root.RedoxTypes.Location.encode(message.Location, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.NPI != undefined && message.hasOwnProperty("NPI"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.NPI);
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    $root.RedoxTypes.PhoneNumber.encode(message.PhoneNumber, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified PCP message, length delimited. Does not implicitly {@link RedoxTypes.PCP.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.PCP
             * @static
             * @param {RedoxTypes.IPCP} message PCP message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PCP.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PCP message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.PCP
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.PCP} PCP
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PCP.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.PCP();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.Credentials && message.Credentials.length))
                            message.Credentials = [];
                        message.Credentials.push(reader.string());
                        break;
                    case 3:
                        message.FirstName = reader.string();
                        break;
                    case 4:
                        message.ID = reader.string();
                        break;
                    case 5:
                        message.IDType = reader.string();
                        break;
                    case 6:
                        message.LastName = reader.string();
                        break;
                    case 7:
                        message.Location = $root.RedoxTypes.Location.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.NPI = reader.string();
                        break;
                    case 9:
                        message.PhoneNumber = $root.RedoxTypes.PhoneNumber.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("ID"))
                    throw $util.ProtocolError("missing required 'ID'", { instance: message });
                if (!message.hasOwnProperty("IDType"))
                    throw $util.ProtocolError("missing required 'IDType'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a PCP message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.PCP
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.PCP} PCP
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PCP.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PCP message.
             * @function verify
             * @memberof RedoxTypes.PCP
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            PCP.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Address != undefined && message.hasOwnProperty("Address")) {
                    var error = $root.RedoxTypes.Address.verify(message.Address);
                    if (error)
                        return "Address." + error;
                }
                if (message.Credentials != undefined && message.hasOwnProperty("Credentials")) {
                    if (!Array.isArray(message.Credentials))
                        return "Credentials: array expected";
                    for (var i = 0; i < message.Credentials.length; ++i)
                        if (!$util.isString(message.Credentials[i]))
                            return "Credentials: string[] expected";
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    if (!$util.isString(message.FirstName))
                        return "FirstName: string expected";
                if (!$util.isString(message.ID))
                    return "ID: string expected";
                if (!$util.isString(message.IDType))
                    return "IDType: string expected";
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    if (!$util.isString(message.LastName))
                        return "LastName: string expected";
                if (message.Location != undefined && message.hasOwnProperty("Location")) {
                    var error = $root.RedoxTypes.Location.verify(message.Location);
                    if (error)
                        return "Location." + error;
                }
                if (message.NPI != undefined && message.hasOwnProperty("NPI"))
                    if (!$util.isString(message.NPI))
                        return "NPI: string expected";
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber")) {
                    var error = $root.RedoxTypes.PhoneNumber.verify(message.PhoneNumber);
                    if (error)
                        return "PhoneNumber." + error;
                }
                return undefined;
            };
    
            /**
             * Creates a PCP message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.PCP
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.PCP} PCP
             */
            PCP.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.PCP)
                    return object;
                var message = new $root.RedoxTypes.PCP();
                if (object.Address != undefined) {
                    if (typeof object.Address !== "object")
                        throw TypeError(".RedoxTypes.PCP.Address: object expected");
                    message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                }
                if (object.Credentials) {
                    if (!Array.isArray(object.Credentials))
                        throw TypeError(".RedoxTypes.PCP.Credentials: array expected");
                    message.Credentials = [];
                    for (var i = 0; i < object.Credentials.length; ++i)
                        message.Credentials[i] = String(object.Credentials[i]);
                }
                if (object.FirstName != undefined)
                    message.FirstName = String(object.FirstName);
                if (object.ID != undefined)
                    message.ID = String(object.ID);
                if (object.IDType != undefined)
                    message.IDType = String(object.IDType);
                if (object.LastName != undefined)
                    message.LastName = String(object.LastName);
                if (object.Location != undefined) {
                    if (typeof object.Location !== "object")
                        throw TypeError(".RedoxTypes.PCP.Location: object expected");
                    message.Location = $root.RedoxTypes.Location.fromObject(object.Location);
                }
                if (object.NPI != undefined)
                    message.NPI = String(object.NPI);
                if (object.PhoneNumber != undefined) {
                    if (typeof object.PhoneNumber !== "object")
                        throw TypeError(".RedoxTypes.PCP.PhoneNumber: object expected");
                    message.PhoneNumber = $root.RedoxTypes.PhoneNumber.fromObject(object.PhoneNumber);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a PCP message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.PCP
             * @static
             * @param {RedoxTypes.PCP} message PCP
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PCP.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.Credentials = [];
                if (options.defaults) {
                    object.Address = undefined;
                    object.FirstName = "";
                    object.ID = "";
                    object.IDType = "";
                    object.LastName = "";
                    object.Location = undefined;
                    object.NPI = "";
                    object.PhoneNumber = undefined;
                }
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                if (message.Credentials && message.Credentials.length) {
                    object.Credentials = [];
                    for (var j = 0; j < message.Credentials.length; ++j)
                        object.Credentials[j] = message.Credentials[j];
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    object.FirstName = message.FirstName;
                if (message.ID != undefined && message.hasOwnProperty("ID"))
                    object.ID = message.ID;
                if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                    object.IDType = message.IDType;
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    object.LastName = message.LastName;
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    object.Location = $root.RedoxTypes.Location.toObject(message.Location, options);
                if (message.NPI != undefined && message.hasOwnProperty("NPI"))
                    object.NPI = message.NPI;
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    object.PhoneNumber = $root.RedoxTypes.PhoneNumber.toObject(message.PhoneNumber, options);
                return object;
            };
    
            /**
             * Converts this PCP to JSON.
             * @function toJSON
             * @memberof RedoxTypes.PCP
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PCP.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PCP;
        })();
    
        RedoxTypes.Provider = (function() {
    
            /**
             * Properties of a Provider.
             * @memberof RedoxTypes
             * @interface IProvider
             * @property {RedoxTypes.IAddress|undefined} [Address] @see Address
             * @property {Array.<string>|undefined} [Credentials] e.g. M.D., Psy.D.
             * @property {string|undefined} [FirstName] First name.
             * @property {string} ID Unique ID value.
             * @property {string} IDType Type of ID. e.g. MRN, EPI.
             * @property {string|undefined} [LastName] Last name.
             * @property {RedoxTypes.ILocation|undefined} [Location] @see Location
             * @property {RedoxTypes.IPhoneNumber|undefined} [PhoneNumber] @see PhoneNumber
             */
    
            /**
             * Constructs a new Provider.
             * @memberof RedoxTypes
             * @classdesc A care provider.
             * @implements IProvider
             * @constructor
             * @param {RedoxTypes.IProvider=} [properties] Properties to set
             */
            function Provider(properties) {
                this.Credentials = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * @see Address
             * @member {RedoxTypes.IAddress|undefined|undefined} Address
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.Address = undefined;
    
            /**
             * e.g. M.D., Psy.D.
             * @member {Array.<string>} Credentials
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.Credentials = $util.emptyArray;
    
            /**
             * First name.
             * @member {string} FirstName
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.FirstName = "";
    
            /**
             * Unique ID value.
             * @member {string} ID
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.ID = "";
    
            /**
             * Type of ID. e.g. MRN, EPI.
             * @member {string} IDType
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.IDType = "";
    
            /**
             * Last name.
             * @member {string} LastName
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.LastName = "";
    
            /**
             * @see Location
             * @member {RedoxTypes.ILocation|undefined|undefined} Location
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.Location = undefined;
    
            /**
             * @see PhoneNumber
             * @member {RedoxTypes.IPhoneNumber|undefined|undefined} PhoneNumber
             * @memberof RedoxTypes.Provider
             * @instance
             */
            Provider.prototype.PhoneNumber = undefined;
    
            /**
             * Creates a new Provider instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Provider
             * @static
             * @param {RedoxTypes.IProvider=} [properties] Properties to set
             * @returns {RedoxTypes.Provider} Provider instance
             */
            Provider.create = function create(properties) {
                return new Provider(properties);
            };
    
            /**
             * Encodes the specified Provider message. Does not implicitly {@link RedoxTypes.Provider.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Provider
             * @static
             * @param {RedoxTypes.IProvider} message Provider message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Provider.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    $root.RedoxTypes.Address.encode(message.Address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.Credentials != undefined && message.Credentials.length)
                    for (var i = 0; i < message.Credentials.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.Credentials[i]);
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.FirstName);
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ID);
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.IDType);
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.LastName);
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    $root.RedoxTypes.Location.encode(message.Location, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    $root.RedoxTypes.PhoneNumber.encode(message.PhoneNumber, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Provider message, length delimited. Does not implicitly {@link RedoxTypes.Provider.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Provider
             * @static
             * @param {RedoxTypes.IProvider} message Provider message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Provider.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Provider message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Provider
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Provider} Provider
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Provider.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Provider();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Address = $root.RedoxTypes.Address.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.Credentials && message.Credentials.length))
                            message.Credentials = [];
                        message.Credentials.push(reader.string());
                        break;
                    case 3:
                        message.FirstName = reader.string();
                        break;
                    case 4:
                        message.ID = reader.string();
                        break;
                    case 5:
                        message.IDType = reader.string();
                        break;
                    case 6:
                        message.LastName = reader.string();
                        break;
                    case 7:
                        message.Location = $root.RedoxTypes.Location.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.PhoneNumber = $root.RedoxTypes.PhoneNumber.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("ID"))
                    throw $util.ProtocolError("missing required 'ID'", { instance: message });
                if (!message.hasOwnProperty("IDType"))
                    throw $util.ProtocolError("missing required 'IDType'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a Provider message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Provider
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Provider} Provider
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Provider.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Provider message.
             * @function verify
             * @memberof RedoxTypes.Provider
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Provider.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Address != undefined && message.hasOwnProperty("Address")) {
                    var error = $root.RedoxTypes.Address.verify(message.Address);
                    if (error)
                        return "Address." + error;
                }
                if (message.Credentials != undefined && message.hasOwnProperty("Credentials")) {
                    if (!Array.isArray(message.Credentials))
                        return "Credentials: array expected";
                    for (var i = 0; i < message.Credentials.length; ++i)
                        if (!$util.isString(message.Credentials[i]))
                            return "Credentials: string[] expected";
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    if (!$util.isString(message.FirstName))
                        return "FirstName: string expected";
                if (!$util.isString(message.ID))
                    return "ID: string expected";
                if (!$util.isString(message.IDType))
                    return "IDType: string expected";
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    if (!$util.isString(message.LastName))
                        return "LastName: string expected";
                if (message.Location != undefined && message.hasOwnProperty("Location")) {
                    var error = $root.RedoxTypes.Location.verify(message.Location);
                    if (error)
                        return "Location." + error;
                }
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber")) {
                    var error = $root.RedoxTypes.PhoneNumber.verify(message.PhoneNumber);
                    if (error)
                        return "PhoneNumber." + error;
                }
                return undefined;
            };
    
            /**
             * Creates a Provider message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Provider
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Provider} Provider
             */
            Provider.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Provider)
                    return object;
                var message = new $root.RedoxTypes.Provider();
                if (object.Address != undefined) {
                    if (typeof object.Address !== "object")
                        throw TypeError(".RedoxTypes.Provider.Address: object expected");
                    message.Address = $root.RedoxTypes.Address.fromObject(object.Address);
                }
                if (object.Credentials) {
                    if (!Array.isArray(object.Credentials))
                        throw TypeError(".RedoxTypes.Provider.Credentials: array expected");
                    message.Credentials = [];
                    for (var i = 0; i < object.Credentials.length; ++i)
                        message.Credentials[i] = String(object.Credentials[i]);
                }
                if (object.FirstName != undefined)
                    message.FirstName = String(object.FirstName);
                if (object.ID != undefined)
                    message.ID = String(object.ID);
                if (object.IDType != undefined)
                    message.IDType = String(object.IDType);
                if (object.LastName != undefined)
                    message.LastName = String(object.LastName);
                if (object.Location != undefined) {
                    if (typeof object.Location !== "object")
                        throw TypeError(".RedoxTypes.Provider.Location: object expected");
                    message.Location = $root.RedoxTypes.Location.fromObject(object.Location);
                }
                if (object.PhoneNumber != undefined) {
                    if (typeof object.PhoneNumber !== "object")
                        throw TypeError(".RedoxTypes.Provider.PhoneNumber: object expected");
                    message.PhoneNumber = $root.RedoxTypes.PhoneNumber.fromObject(object.PhoneNumber);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Provider message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Provider
             * @static
             * @param {RedoxTypes.Provider} message Provider
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Provider.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.Credentials = [];
                if (options.defaults) {
                    object.Address = undefined;
                    object.FirstName = "";
                    object.ID = "";
                    object.IDType = "";
                    object.LastName = "";
                    object.Location = undefined;
                    object.PhoneNumber = undefined;
                }
                if (message.Address != undefined && message.hasOwnProperty("Address"))
                    object.Address = $root.RedoxTypes.Address.toObject(message.Address, options);
                if (message.Credentials && message.Credentials.length) {
                    object.Credentials = [];
                    for (var j = 0; j < message.Credentials.length; ++j)
                        object.Credentials[j] = message.Credentials[j];
                }
                if (message.FirstName != undefined && message.hasOwnProperty("FirstName"))
                    object.FirstName = message.FirstName;
                if (message.ID != undefined && message.hasOwnProperty("ID"))
                    object.ID = message.ID;
                if (message.IDType != undefined && message.hasOwnProperty("IDType"))
                    object.IDType = message.IDType;
                if (message.LastName != undefined && message.hasOwnProperty("LastName"))
                    object.LastName = message.LastName;
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    object.Location = $root.RedoxTypes.Location.toObject(message.Location, options);
                if (message.PhoneNumber != undefined && message.hasOwnProperty("PhoneNumber"))
                    object.PhoneNumber = $root.RedoxTypes.PhoneNumber.toObject(message.PhoneNumber, options);
                return object;
            };
    
            /**
             * Converts this Provider to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Provider
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Provider.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Provider;
        })();
    
        RedoxTypes.PhoneNumber = (function() {
    
            /**
             * Properties of a PhoneNumber.
             * @memberof RedoxTypes
             * @interface IPhoneNumber
             * @property {string|undefined} [Home] Home phone number.
             * @property {string|undefined} [Mobile] Mobile phone number.
             * @property {string|undefined} [Office] Office phone number.
             */
    
            /**
             * Constructs a new PhoneNumber.
             * @memberof RedoxTypes
             * @classdesc Someone's phone number.
             * @implements IPhoneNumber
             * @constructor
             * @param {RedoxTypes.IPhoneNumber=} [properties] Properties to set
             */
            function PhoneNumber(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Home phone number.
             * @member {string} Home
             * @memberof RedoxTypes.PhoneNumber
             * @instance
             */
            PhoneNumber.prototype.Home = "";
    
            /**
             * Mobile phone number.
             * @member {string} Mobile
             * @memberof RedoxTypes.PhoneNumber
             * @instance
             */
            PhoneNumber.prototype.Mobile = "";
    
            /**
             * Office phone number.
             * @member {string} Office
             * @memberof RedoxTypes.PhoneNumber
             * @instance
             */
            PhoneNumber.prototype.Office = "";
    
            /**
             * Creates a new PhoneNumber instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {RedoxTypes.IPhoneNumber=} [properties] Properties to set
             * @returns {RedoxTypes.PhoneNumber} PhoneNumber instance
             */
            PhoneNumber.create = function create(properties) {
                return new PhoneNumber(properties);
            };
    
            /**
             * Encodes the specified PhoneNumber message. Does not implicitly {@link RedoxTypes.PhoneNumber.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {RedoxTypes.IPhoneNumber} message PhoneNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhoneNumber.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Home != undefined && message.hasOwnProperty("Home"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.Home);
                if (message.Mobile != undefined && message.hasOwnProperty("Mobile"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.Mobile);
                if (message.Office != undefined && message.hasOwnProperty("Office"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Office);
                return writer;
            };
    
            /**
             * Encodes the specified PhoneNumber message, length delimited. Does not implicitly {@link RedoxTypes.PhoneNumber.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {RedoxTypes.IPhoneNumber} message PhoneNumber message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PhoneNumber.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a PhoneNumber message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.PhoneNumber} PhoneNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhoneNumber.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.PhoneNumber();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Home = reader.string();
                        break;
                    case 2:
                        message.Mobile = reader.string();
                        break;
                    case 3:
                        message.Office = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a PhoneNumber message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.PhoneNumber} PhoneNumber
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PhoneNumber.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a PhoneNumber message.
             * @function verify
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            PhoneNumber.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.Home != undefined && message.hasOwnProperty("Home"))
                    if (!$util.isString(message.Home))
                        return "Home: string expected";
                if (message.Mobile != undefined && message.hasOwnProperty("Mobile"))
                    if (!$util.isString(message.Mobile))
                        return "Mobile: string expected";
                if (message.Office != undefined && message.hasOwnProperty("Office"))
                    if (!$util.isString(message.Office))
                        return "Office: string expected";
                return undefined;
            };
    
            /**
             * Creates a PhoneNumber message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.PhoneNumber} PhoneNumber
             */
            PhoneNumber.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.PhoneNumber)
                    return object;
                var message = new $root.RedoxTypes.PhoneNumber();
                if (object.Home != undefined)
                    message.Home = String(object.Home);
                if (object.Mobile != undefined)
                    message.Mobile = String(object.Mobile);
                if (object.Office != undefined)
                    message.Office = String(object.Office);
                return message;
            };
    
            /**
             * Creates a plain object from a PhoneNumber message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.PhoneNumber
             * @static
             * @param {RedoxTypes.PhoneNumber} message PhoneNumber
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PhoneNumber.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.Home = "";
                    object.Mobile = "";
                    object.Office = "";
                }
                if (message.Home != undefined && message.hasOwnProperty("Home"))
                    object.Home = message.Home;
                if (message.Mobile != undefined && message.hasOwnProperty("Mobile"))
                    object.Mobile = message.Mobile;
                if (message.Office != undefined && message.hasOwnProperty("Office"))
                    object.Office = message.Office;
                return object;
            };
    
            /**
             * Converts this PhoneNumber to JSON.
             * @function toJSON
             * @memberof RedoxTypes.PhoneNumber
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PhoneNumber.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return PhoneNumber;
        })();
    
        RedoxTypes.Visit = (function() {
    
            /**
             * Properties of a Visit.
             * @memberof RedoxTypes
             * @interface IVisit
             * @property {string|undefined} [AccountNumber] * An ID that can span several visits often related to the same issue.
             * * (Pregnancy, surgeries, research study, etc.)
             * @property {RedoxTypes.IProvider|undefined} [AttendingProvider] Attending provider.
             * @property {RedoxTypes.IProvider|undefined} [ConsultingProvider] Consulting provider.
             * @property {Array.<RedoxTypes.ICodesetValue>|undefined} [Diagnoses] List of diagnoses associated with this visit.
             * @property {number|undefined} [Duration] Duration in minutes.
             * @property {Array.<string>|undefined} [Instructions] Appointment instructions.
             * @property {RedoxTypes.ILocation|undefined} [Location] Location.
             * @property {string|undefined} [PatientClass] * Patient class is used in many EHRs to determine where to put the patient.
             * * e.g. Outpatient, Hosptial Outpatient Department.
             * @property {string|undefined} [Reason] Reason for appointment.
             * @property {RedoxTypes.IProvider|undefined} [ReferringProvider] Referring provider.
             * @property {string|undefined} [Status] * One of the following: Scheduled, Arrived, Completed, Canceled,
             * * Left without being seen, No show.
             * @property {string|undefined} [VisitDateTime] Datetime. (ISO 8601)
             * @property {string|undefined} [VisitNumber] Unique ID of a single visit.
             * @property {RedoxTypes.IProvider|undefined} [VisitProvider] Visit provider.
             */
    
            /**
             * Constructs a new Visit.
             * @memberof RedoxTypes
             * @classdesc Visit metadata.
             * @implements IVisit
             * @constructor
             * @param {RedoxTypes.IVisit=} [properties] Properties to set
             */
            function Visit(properties) {
                this.Diagnoses = [];
                this.Instructions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * * An ID that can span several visits often related to the same issue.
             * * (Pregnancy, surgeries, research study, etc.)
             * @member {string} AccountNumber
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.AccountNumber = "";
    
            /**
             * Attending provider.
             * @member {RedoxTypes.IProvider|undefined|undefined} AttendingProvider
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.AttendingProvider = undefined;
    
            /**
             * Consulting provider.
             * @member {RedoxTypes.IProvider|undefined|undefined} ConsultingProvider
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.ConsultingProvider = undefined;
    
            /**
             * List of diagnoses associated with this visit.
             * @member {Array.<RedoxTypes.ICodesetValue>} Diagnoses
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Diagnoses = $util.emptyArray;
    
            /**
             * Duration in minutes.
             * @member {number} Duration
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Duration = 0;
    
            /**
             * Appointment instructions.
             * @member {Array.<string>} Instructions
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Instructions = $util.emptyArray;
    
            /**
             * Location.
             * @member {RedoxTypes.ILocation|undefined|undefined} Location
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Location = undefined;
    
            /**
             * * Patient class is used in many EHRs to determine where to put the patient.
             * * e.g. Outpatient, Hosptial Outpatient Department.
             * @member {string} PatientClass
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.PatientClass = "";
    
            /**
             * Reason for appointment.
             * @member {string} Reason
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Reason = "";
    
            /**
             * Referring provider.
             * @member {RedoxTypes.IProvider|undefined|undefined} ReferringProvider
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.ReferringProvider = undefined;
    
            /**
             * * One of the following: Scheduled, Arrived, Completed, Canceled,
             * * Left without being seen, No show.
             * @member {string} Status
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.Status = "";
    
            /**
             * Datetime. (ISO 8601)
             * @member {string} VisitDateTime
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.VisitDateTime = "";
    
            /**
             * Unique ID of a single visit.
             * @member {string} VisitNumber
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.VisitNumber = "";
    
            /**
             * Visit provider.
             * @member {RedoxTypes.IProvider|undefined|undefined} VisitProvider
             * @memberof RedoxTypes.Visit
             * @instance
             */
            Visit.prototype.VisitProvider = undefined;
    
            /**
             * Creates a new Visit instance using the specified properties.
             * @function create
             * @memberof RedoxTypes.Visit
             * @static
             * @param {RedoxTypes.IVisit=} [properties] Properties to set
             * @returns {RedoxTypes.Visit} Visit instance
             */
            Visit.create = function create(properties) {
                return new Visit(properties);
            };
    
            /**
             * Encodes the specified Visit message. Does not implicitly {@link RedoxTypes.Visit.verify|verify} messages.
             * @function encode
             * @memberof RedoxTypes.Visit
             * @static
             * @param {RedoxTypes.IVisit} message Visit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Visit.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.AccountNumber != undefined && message.hasOwnProperty("AccountNumber"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.AccountNumber);
                if (message.AttendingProvider != undefined && message.hasOwnProperty("AttendingProvider"))
                    $root.RedoxTypes.Provider.encode(message.AttendingProvider, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.ConsultingProvider != undefined && message.hasOwnProperty("ConsultingProvider"))
                    $root.RedoxTypes.Provider.encode(message.ConsultingProvider, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.Diagnoses != undefined && message.Diagnoses.length)
                    for (var i = 0; i < message.Diagnoses.length; ++i)
                        $root.RedoxTypes.CodesetValue.encode(message.Diagnoses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.Duration != undefined && message.hasOwnProperty("Duration"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.Duration);
                if (message.Instructions != undefined && message.Instructions.length)
                    for (var i = 0; i < message.Instructions.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.Instructions[i]);
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    $root.RedoxTypes.Location.encode(message.Location, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.PatientClass != undefined && message.hasOwnProperty("PatientClass"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.PatientClass);
                if (message.Reason != undefined && message.hasOwnProperty("Reason"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.Reason);
                if (message.ReferringProvider != undefined && message.hasOwnProperty("ReferringProvider"))
                    $root.RedoxTypes.Provider.encode(message.ReferringProvider, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.Status != undefined && message.hasOwnProperty("Status"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.Status);
                if (message.VisitDateTime != undefined && message.hasOwnProperty("VisitDateTime"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.VisitDateTime);
                if (message.VisitNumber != undefined && message.hasOwnProperty("VisitNumber"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.VisitNumber);
                if (message.VisitProvider != undefined && message.hasOwnProperty("VisitProvider"))
                    $root.RedoxTypes.Provider.encode(message.VisitProvider, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified Visit message, length delimited. Does not implicitly {@link RedoxTypes.Visit.verify|verify} messages.
             * @function encodeDelimited
             * @memberof RedoxTypes.Visit
             * @static
             * @param {RedoxTypes.IVisit} message Visit message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Visit.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a Visit message from the specified reader or buffer.
             * @function decode
             * @memberof RedoxTypes.Visit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {RedoxTypes.Visit} Visit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Visit.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.RedoxTypes.Visit();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.AccountNumber = reader.string();
                        break;
                    case 2:
                        message.AttendingProvider = $root.RedoxTypes.Provider.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.ConsultingProvider = $root.RedoxTypes.Provider.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.Diagnoses && message.Diagnoses.length))
                            message.Diagnoses = [];
                        message.Diagnoses.push($root.RedoxTypes.CodesetValue.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.Duration = reader.uint32();
                        break;
                    case 6:
                        if (!(message.Instructions && message.Instructions.length))
                            message.Instructions = [];
                        message.Instructions.push(reader.string());
                        break;
                    case 7:
                        message.Location = $root.RedoxTypes.Location.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.PatientClass = reader.string();
                        break;
                    case 9:
                        message.Reason = reader.string();
                        break;
                    case 10:
                        message.ReferringProvider = $root.RedoxTypes.Provider.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.Status = reader.string();
                        break;
                    case 12:
                        message.VisitDateTime = reader.string();
                        break;
                    case 13:
                        message.VisitNumber = reader.string();
                        break;
                    case 14:
                        message.VisitProvider = $root.RedoxTypes.Provider.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a Visit message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof RedoxTypes.Visit
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {RedoxTypes.Visit} Visit
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Visit.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a Visit message.
             * @function verify
             * @memberof RedoxTypes.Visit
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Visit.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.AccountNumber != undefined && message.hasOwnProperty("AccountNumber"))
                    if (!$util.isString(message.AccountNumber))
                        return "AccountNumber: string expected";
                if (message.AttendingProvider != undefined && message.hasOwnProperty("AttendingProvider")) {
                    var error = $root.RedoxTypes.Provider.verify(message.AttendingProvider);
                    if (error)
                        return "AttendingProvider." + error;
                }
                if (message.ConsultingProvider != undefined && message.hasOwnProperty("ConsultingProvider")) {
                    var error = $root.RedoxTypes.Provider.verify(message.ConsultingProvider);
                    if (error)
                        return "ConsultingProvider." + error;
                }
                if (message.Diagnoses != undefined && message.hasOwnProperty("Diagnoses")) {
                    if (!Array.isArray(message.Diagnoses))
                        return "Diagnoses: array expected";
                    for (var i = 0; i < message.Diagnoses.length; ++i) {
                        var error = $root.RedoxTypes.CodesetValue.verify(message.Diagnoses[i]);
                        if (error)
                            return "Diagnoses." + error;
                    }
                }
                if (message.Duration != undefined && message.hasOwnProperty("Duration"))
                    if (!$util.isInteger(message.Duration))
                        return "Duration: integer expected";
                if (message.Instructions != undefined && message.hasOwnProperty("Instructions")) {
                    if (!Array.isArray(message.Instructions))
                        return "Instructions: array expected";
                    for (var i = 0; i < message.Instructions.length; ++i)
                        if (!$util.isString(message.Instructions[i]))
                            return "Instructions: string[] expected";
                }
                if (message.Location != undefined && message.hasOwnProperty("Location")) {
                    var error = $root.RedoxTypes.Location.verify(message.Location);
                    if (error)
                        return "Location." + error;
                }
                if (message.PatientClass != undefined && message.hasOwnProperty("PatientClass"))
                    if (!$util.isString(message.PatientClass))
                        return "PatientClass: string expected";
                if (message.Reason != undefined && message.hasOwnProperty("Reason"))
                    if (!$util.isString(message.Reason))
                        return "Reason: string expected";
                if (message.ReferringProvider != undefined && message.hasOwnProperty("ReferringProvider")) {
                    var error = $root.RedoxTypes.Provider.verify(message.ReferringProvider);
                    if (error)
                        return "ReferringProvider." + error;
                }
                if (message.Status != undefined && message.hasOwnProperty("Status"))
                    if (!$util.isString(message.Status))
                        return "Status: string expected";
                if (message.VisitDateTime != undefined && message.hasOwnProperty("VisitDateTime"))
                    if (!$util.isString(message.VisitDateTime))
                        return "VisitDateTime: string expected";
                if (message.VisitNumber != undefined && message.hasOwnProperty("VisitNumber"))
                    if (!$util.isString(message.VisitNumber))
                        return "VisitNumber: string expected";
                if (message.VisitProvider != undefined && message.hasOwnProperty("VisitProvider")) {
                    var error = $root.RedoxTypes.Provider.verify(message.VisitProvider);
                    if (error)
                        return "VisitProvider." + error;
                }
                return undefined;
            };
    
            /**
             * Creates a Visit message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof RedoxTypes.Visit
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {RedoxTypes.Visit} Visit
             */
            Visit.fromObject = function fromObject(object) {
                if (object instanceof $root.RedoxTypes.Visit)
                    return object;
                var message = new $root.RedoxTypes.Visit();
                if (object.AccountNumber != undefined)
                    message.AccountNumber = String(object.AccountNumber);
                if (object.AttendingProvider != undefined) {
                    if (typeof object.AttendingProvider !== "object")
                        throw TypeError(".RedoxTypes.Visit.AttendingProvider: object expected");
                    message.AttendingProvider = $root.RedoxTypes.Provider.fromObject(object.AttendingProvider);
                }
                if (object.ConsultingProvider != undefined) {
                    if (typeof object.ConsultingProvider !== "object")
                        throw TypeError(".RedoxTypes.Visit.ConsultingProvider: object expected");
                    message.ConsultingProvider = $root.RedoxTypes.Provider.fromObject(object.ConsultingProvider);
                }
                if (object.Diagnoses) {
                    if (!Array.isArray(object.Diagnoses))
                        throw TypeError(".RedoxTypes.Visit.Diagnoses: array expected");
                    message.Diagnoses = [];
                    for (var i = 0; i < object.Diagnoses.length; ++i) {
                        if (typeof object.Diagnoses[i] !== "object")
                            throw TypeError(".RedoxTypes.Visit.Diagnoses: object expected");
                        message.Diagnoses[i] = $root.RedoxTypes.CodesetValue.fromObject(object.Diagnoses[i]);
                    }
                }
                if (object.Duration != undefined)
                    message.Duration = object.Duration >>> 0;
                if (object.Instructions) {
                    if (!Array.isArray(object.Instructions))
                        throw TypeError(".RedoxTypes.Visit.Instructions: array expected");
                    message.Instructions = [];
                    for (var i = 0; i < object.Instructions.length; ++i)
                        message.Instructions[i] = String(object.Instructions[i]);
                }
                if (object.Location != undefined) {
                    if (typeof object.Location !== "object")
                        throw TypeError(".RedoxTypes.Visit.Location: object expected");
                    message.Location = $root.RedoxTypes.Location.fromObject(object.Location);
                }
                if (object.PatientClass != undefined)
                    message.PatientClass = String(object.PatientClass);
                if (object.Reason != undefined)
                    message.Reason = String(object.Reason);
                if (object.ReferringProvider != undefined) {
                    if (typeof object.ReferringProvider !== "object")
                        throw TypeError(".RedoxTypes.Visit.ReferringProvider: object expected");
                    message.ReferringProvider = $root.RedoxTypes.Provider.fromObject(object.ReferringProvider);
                }
                if (object.Status != undefined)
                    message.Status = String(object.Status);
                if (object.VisitDateTime != undefined)
                    message.VisitDateTime = String(object.VisitDateTime);
                if (object.VisitNumber != undefined)
                    message.VisitNumber = String(object.VisitNumber);
                if (object.VisitProvider != undefined) {
                    if (typeof object.VisitProvider !== "object")
                        throw TypeError(".RedoxTypes.Visit.VisitProvider: object expected");
                    message.VisitProvider = $root.RedoxTypes.Provider.fromObject(object.VisitProvider);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a Visit message. Also converts values to other types if specified.
             * @function toObject
             * @memberof RedoxTypes.Visit
             * @static
             * @param {RedoxTypes.Visit} message Visit
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Visit.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.Diagnoses = [];
                    object.Instructions = [];
                }
                if (options.defaults) {
                    object.AccountNumber = "";
                    object.AttendingProvider = undefined;
                    object.ConsultingProvider = undefined;
                    object.Duration = 0;
                    object.Location = undefined;
                    object.PatientClass = "";
                    object.Reason = "";
                    object.ReferringProvider = undefined;
                    object.Status = "";
                    object.VisitDateTime = "";
                    object.VisitNumber = "";
                    object.VisitProvider = undefined;
                }
                if (message.AccountNumber != undefined && message.hasOwnProperty("AccountNumber"))
                    object.AccountNumber = message.AccountNumber;
                if (message.AttendingProvider != undefined && message.hasOwnProperty("AttendingProvider"))
                    object.AttendingProvider = $root.RedoxTypes.Provider.toObject(message.AttendingProvider, options);
                if (message.ConsultingProvider != undefined && message.hasOwnProperty("ConsultingProvider"))
                    object.ConsultingProvider = $root.RedoxTypes.Provider.toObject(message.ConsultingProvider, options);
                if (message.Diagnoses && message.Diagnoses.length) {
                    object.Diagnoses = [];
                    for (var j = 0; j < message.Diagnoses.length; ++j)
                        object.Diagnoses[j] = $root.RedoxTypes.CodesetValue.toObject(message.Diagnoses[j], options);
                }
                if (message.Duration != undefined && message.hasOwnProperty("Duration"))
                    object.Duration = message.Duration;
                if (message.Instructions && message.Instructions.length) {
                    object.Instructions = [];
                    for (var j = 0; j < message.Instructions.length; ++j)
                        object.Instructions[j] = message.Instructions[j];
                }
                if (message.Location != undefined && message.hasOwnProperty("Location"))
                    object.Location = $root.RedoxTypes.Location.toObject(message.Location, options);
                if (message.PatientClass != undefined && message.hasOwnProperty("PatientClass"))
                    object.PatientClass = message.PatientClass;
                if (message.Reason != undefined && message.hasOwnProperty("Reason"))
                    object.Reason = message.Reason;
                if (message.ReferringProvider != undefined && message.hasOwnProperty("ReferringProvider"))
                    object.ReferringProvider = $root.RedoxTypes.Provider.toObject(message.ReferringProvider, options);
                if (message.Status != undefined && message.hasOwnProperty("Status"))
                    object.Status = message.Status;
                if (message.VisitDateTime != undefined && message.hasOwnProperty("VisitDateTime"))
                    object.VisitDateTime = message.VisitDateTime;
                if (message.VisitNumber != undefined && message.hasOwnProperty("VisitNumber"))
                    object.VisitNumber = message.VisitNumber;
                if (message.VisitProvider != undefined && message.hasOwnProperty("VisitProvider"))
                    object.VisitProvider = $root.RedoxTypes.Provider.toObject(message.VisitProvider, options);
                return object;
            };
    
            /**
             * Converts this Visit to JSON.
             * @function toJSON
             * @memberof RedoxTypes.Visit
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Visit.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Visit;
        })();
    
        return RedoxTypes;
    })();
    
    $root.Review = (function() {
    
        /**
         * Properties of a Review.
         * @exports IReview
         * @interface IReview
         * @property {number} rating A rating between 0 and 100.
         * @property {string|undefined} [text] Review text.
         * @property {number} timestamp Timestamp of this review.
         */
    
        /**
         * Constructs a new Review.
         * @exports Review
         * @classdesc A review of something.
         * @implements IReview
         * @constructor
         * @param {IReview=} [properties] Properties to set
         */
        function Review(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * A rating between 0 and 100.
         * @member {number} rating
         * @memberof Review
         * @instance
         */
        Review.prototype.rating = 0;
    
        /**
         * Review text.
         * @member {string} text
         * @memberof Review
         * @instance
         */
        Review.prototype.text = "";
    
        /**
         * Timestamp of this review.
         * @member {number} timestamp
         * @memberof Review
         * @instance
         */
        Review.prototype.timestamp = 0;
    
        /**
         * Creates a new Review instance using the specified properties.
         * @function create
         * @memberof Review
         * @static
         * @param {IReview=} [properties] Properties to set
         * @returns {Review} Review instance
         */
        Review.create = function create(properties) {
            return new Review(properties);
        };
    
        /**
         * Encodes the specified Review message. Does not implicitly {@link Review.verify|verify} messages.
         * @function encode
         * @memberof Review
         * @static
         * @param {IReview} message Review message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Review.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rating);
            if (message.text != undefined && message.hasOwnProperty("text"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.text);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.timestamp);
            return writer;
        };
    
        /**
         * Encodes the specified Review message, length delimited. Does not implicitly {@link Review.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Review
         * @static
         * @param {IReview} message Review message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Review.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a Review message from the specified reader or buffer.
         * @function decode
         * @memberof Review
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Review} Review
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Review.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Review();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rating = reader.uint32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("rating"))
                throw $util.ProtocolError("missing required 'rating'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a Review message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Review
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Review} Review
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Review.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a Review message.
         * @function verify
         * @memberof Review
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        Review.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isInteger(message.rating))
                return "rating: integer expected";
            if (message.text != undefined && message.hasOwnProperty("text"))
                if (!$util.isString(message.text))
                    return "text: string expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            return undefined;
        };
    
        /**
         * Creates a Review message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Review
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Review} Review
         */
        Review.fromObject = function fromObject(object) {
            if (object instanceof $root.Review)
                return object;
            var message = new $root.Review();
            if (object.rating != undefined)
                message.rating = object.rating >>> 0;
            if (object.text != undefined)
                message.text = String(object.text);
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            return message;
        };
    
        /**
         * Creates a plain object from a Review message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Review
         * @static
         * @param {Review} message Review
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Review.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.rating = 0;
                object.text = "";
                object.timestamp = 0;
            }
            if (message.rating != undefined && message.hasOwnProperty("rating"))
                object.rating = message.rating;
            if (message.text != undefined && message.hasOwnProperty("text"))
                object.text = message.text;
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            return object;
        };
    
        /**
         * Converts this Review to JSON.
         * @function toJSON
         * @memberof Review
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Review.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return Review;
    })();
    
    $root.SessionCapabilities = (function() {
    
        /**
         * Properties of a SessionCapabilities.
         * @exports ISessionCapabilities
         * @interface ISessionCapabilities
         * @property {boolean} p2p P2P networking / WebRTC.
         * @property {boolean} walkieTalkieMode Walkie talkie mode active by default.
         */
    
        /**
         * Constructs a new SessionCapabilities.
         * @exports SessionCapabilities
         * @classdesc A set of supported capabilities.
         * @implements ISessionCapabilities
         * @constructor
         * @param {ISessionCapabilities=} [properties] Properties to set
         */
        function SessionCapabilities(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * P2P networking / WebRTC.
         * @member {boolean} p2p
         * @memberof SessionCapabilities
         * @instance
         */
        SessionCapabilities.prototype.p2p = false;
    
        /**
         * Walkie talkie mode active by default.
         * @member {boolean} walkieTalkieMode
         * @memberof SessionCapabilities
         * @instance
         */
        SessionCapabilities.prototype.walkieTalkieMode = false;
    
        /**
         * Creates a new SessionCapabilities instance using the specified properties.
         * @function create
         * @memberof SessionCapabilities
         * @static
         * @param {ISessionCapabilities=} [properties] Properties to set
         * @returns {SessionCapabilities} SessionCapabilities instance
         */
        SessionCapabilities.create = function create(properties) {
            return new SessionCapabilities(properties);
        };
    
        /**
         * Encodes the specified SessionCapabilities message. Does not implicitly {@link SessionCapabilities.verify|verify} messages.
         * @function encode
         * @memberof SessionCapabilities
         * @static
         * @param {ISessionCapabilities} message SessionCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCapabilities.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.p2p);
            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.walkieTalkieMode);
            return writer;
        };
    
        /**
         * Encodes the specified SessionCapabilities message, length delimited. Does not implicitly {@link SessionCapabilities.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionCapabilities
         * @static
         * @param {ISessionCapabilities} message SessionCapabilities message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCapabilities.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionCapabilities message from the specified reader or buffer.
         * @function decode
         * @memberof SessionCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionCapabilities} SessionCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCapabilities.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionCapabilities();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.p2p = reader.bool();
                    break;
                case 2:
                    message.walkieTalkieMode = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("p2p"))
                throw $util.ProtocolError("missing required 'p2p'", { instance: message });
            if (!message.hasOwnProperty("walkieTalkieMode"))
                throw $util.ProtocolError("missing required 'walkieTalkieMode'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionCapabilities message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionCapabilities
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionCapabilities} SessionCapabilities
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCapabilities.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionCapabilities message.
         * @function verify
         * @memberof SessionCapabilities
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionCapabilities.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (typeof message.p2p !== "boolean")
                return "p2p: boolean expected";
            if (typeof message.walkieTalkieMode !== "boolean")
                return "walkieTalkieMode: boolean expected";
            return undefined;
        };
    
        /**
         * Creates a SessionCapabilities message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionCapabilities
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionCapabilities} SessionCapabilities
         */
        SessionCapabilities.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionCapabilities)
                return object;
            var message = new $root.SessionCapabilities();
            if (object.p2p != undefined)
                message.p2p = Boolean(object.p2p);
            if (object.walkieTalkieMode != undefined)
                message.walkieTalkieMode = Boolean(object.walkieTalkieMode);
            return message;
        };
    
        /**
         * Creates a plain object from a SessionCapabilities message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionCapabilities
         * @static
         * @param {SessionCapabilities} message SessionCapabilities
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCapabilities.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.p2p = false;
                object.walkieTalkieMode = false;
            }
            if (message.p2p != undefined && message.hasOwnProperty("p2p"))
                object.p2p = message.p2p;
            if (message.walkieTalkieMode != undefined && message.hasOwnProperty("walkieTalkieMode"))
                object.walkieTalkieMode = message.walkieTalkieMode;
            return object;
        };
    
        /**
         * Converts this SessionCapabilities to JSON.
         * @function toJSON
         * @memberof SessionCapabilities
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCapabilities.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionCapabilities;
    })();
    
    $root.SessionChatState = (function() {
    
        /**
         * Properties of a SessionChatState.
         * @exports ISessionChatState
         * @interface ISessionChatState
         * @property {boolean} isTyping Indicates whether this party is actively typing.
         */
    
        /**
         * Constructs a new SessionChatState.
         * @exports SessionChatState
         * @classdesc Misc information about the state of a chat.
         * @implements ISessionChatState
         * @constructor
         * @param {ISessionChatState=} [properties] Properties to set
         */
        function SessionChatState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Indicates whether this party is actively typing.
         * @member {boolean} isTyping
         * @memberof SessionChatState
         * @instance
         */
        SessionChatState.prototype.isTyping = false;
    
        /**
         * Creates a new SessionChatState instance using the specified properties.
         * @function create
         * @memberof SessionChatState
         * @static
         * @param {ISessionChatState=} [properties] Properties to set
         * @returns {SessionChatState} SessionChatState instance
         */
        SessionChatState.create = function create(properties) {
            return new SessionChatState(properties);
        };
    
        /**
         * Encodes the specified SessionChatState message. Does not implicitly {@link SessionChatState.verify|verify} messages.
         * @function encode
         * @memberof SessionChatState
         * @static
         * @param {ISessionChatState} message SessionChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionChatState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isTyping);
            return writer;
        };
    
        /**
         * Encodes the specified SessionChatState message, length delimited. Does not implicitly {@link SessionChatState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionChatState
         * @static
         * @param {ISessionChatState} message SessionChatState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionChatState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionChatState message from the specified reader or buffer.
         * @function decode
         * @memberof SessionChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionChatState} SessionChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionChatState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionChatState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.isTyping = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("isTyping"))
                throw $util.ProtocolError("missing required 'isTyping'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionChatState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionChatState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionChatState} SessionChatState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionChatState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionChatState message.
         * @function verify
         * @memberof SessionChatState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionChatState.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (typeof message.isTyping !== "boolean")
                return "isTyping: boolean expected";
            return undefined;
        };
    
        /**
         * Creates a SessionChatState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionChatState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionChatState} SessionChatState
         */
        SessionChatState.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionChatState)
                return object;
            var message = new $root.SessionChatState();
            if (object.isTyping != undefined)
                message.isTyping = Boolean(object.isTyping);
            return message;
        };
    
        /**
         * Creates a plain object from a SessionChatState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionChatState
         * @static
         * @param {SessionChatState} message SessionChatState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionChatState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isTyping = false;
            if (message.isTyping != undefined && message.hasOwnProperty("isTyping"))
                object.isTyping = message.isTyping;
            return object;
        };
    
        /**
         * Converts this SessionChatState to JSON.
         * @function toJSON
         * @memberof SessionChatState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionChatState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionChatState;
    })();
    
    $root.SessionCommand = (function() {
    
        /**
         * Properties of a SessionCommand.
         * @exports ISessionCommand
         * @interface ISessionCommand
         * @property {string|undefined} [additionalData] Used to ensure that the command is being run in the correct context (e.g. P2P session).
         * @property {Uint8Array|undefined} [argument] Argument to pass to method (serialized with MessagePack).
         * @property {string} method Method name.
         */
    
        /**
         * Constructs a new SessionCommand.
         * @exports SessionCommand
         * @classdesc Contains an RPC call for a specific method.
         * @implements ISessionCommand
         * @constructor
         * @param {ISessionCommand=} [properties] Properties to set
         */
        function SessionCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Used to ensure that the command is being run in the correct context (e.g. P2P session).
         * @member {string} additionalData
         * @memberof SessionCommand
         * @instance
         */
        SessionCommand.prototype.additionalData = "";
    
        /**
         * Argument to pass to method (serialized with MessagePack).
         * @member {Uint8Array} argument
         * @memberof SessionCommand
         * @instance
         */
        SessionCommand.prototype.argument = $util.newBuffer([]);
    
        /**
         * Method name.
         * @member {string} method
         * @memberof SessionCommand
         * @instance
         */
        SessionCommand.prototype.method = "";
    
        /**
         * Creates a new SessionCommand instance using the specified properties.
         * @function create
         * @memberof SessionCommand
         * @static
         * @param {ISessionCommand=} [properties] Properties to set
         * @returns {SessionCommand} SessionCommand instance
         */
        SessionCommand.create = function create(properties) {
            return new SessionCommand(properties);
        };
    
        /**
         * Encodes the specified SessionCommand message. Does not implicitly {@link SessionCommand.verify|verify} messages.
         * @function encode
         * @memberof SessionCommand
         * @static
         * @param {ISessionCommand} message SessionCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.additionalData != undefined && message.hasOwnProperty("additionalData"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.additionalData);
            if (message.argument != undefined && message.hasOwnProperty("argument"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.argument);
            writer.uint32(/* id 3, wireType 2 =*/26).string(message.method);
            return writer;
        };
    
        /**
         * Encodes the specified SessionCommand message, length delimited. Does not implicitly {@link SessionCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionCommand
         * @static
         * @param {ISessionCommand} message SessionCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionCommand message from the specified reader or buffer.
         * @function decode
         * @memberof SessionCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionCommand} SessionCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.additionalData = reader.string();
                    break;
                case 2:
                    message.argument = reader.bytes();
                    break;
                case 3:
                    message.method = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("method"))
                throw $util.ProtocolError("missing required 'method'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionCommand} SessionCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionCommand message.
         * @function verify
         * @memberof SessionCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.additionalData != undefined && message.hasOwnProperty("additionalData"))
                if (!$util.isString(message.additionalData))
                    return "additionalData: string expected";
            if (message.argument != undefined && message.hasOwnProperty("argument"))
                if (!(message.argument && typeof message.argument.length === "number" || $util.isString(message.argument)))
                    return "argument: buffer expected";
            if (!$util.isString(message.method))
                return "method: string expected";
            return undefined;
        };
    
        /**
         * Creates a SessionCommand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionCommand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionCommand} SessionCommand
         */
        SessionCommand.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionCommand)
                return object;
            var message = new $root.SessionCommand();
            if (object.additionalData != undefined)
                message.additionalData = String(object.additionalData);
            if (object.argument != undefined)
                if (typeof object.argument === "string")
                    $util.base64.decode(object.argument, message.argument = $util.newBuffer($util.base64.length(object.argument)), 0);
                else if (object.argument.length)
                    message.argument = object.argument;
            if (object.method != undefined)
                message.method = String(object.method);
            return message;
        };
    
        /**
         * Creates a plain object from a SessionCommand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionCommand
         * @static
         * @param {SessionCommand} message SessionCommand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionCommand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.additionalData = "";
                object.argument = options.bytes === String ? "" : [];
                object.method = "";
            }
            if (message.additionalData != undefined && message.hasOwnProperty("additionalData"))
                object.additionalData = message.additionalData;
            if (message.argument != undefined && message.hasOwnProperty("argument"))
                object.argument = options.bytes === String ? $util.base64.encode(message.argument, 0, message.argument.length) : options.bytes === Array ? Array.prototype.slice.call(message.argument) : message.argument;
            if (message.method != undefined && message.hasOwnProperty("method"))
                object.method = message.method;
            return object;
        };
    
        /**
         * Converts this SessionCommand to JSON.
         * @function toJSON
         * @memberof SessionCommand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionCommand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionCommand;
    })();
    
    $root.SessionMessage = (function() {
    
        /**
         * Properties of a SessionMessage.
         * @exports ISessionMessage
         * @interface ISessionMessage
         * @property {string} event Event name (e.g. "text").
         * @property {ISessionMessageData} data Associated data (e.g. a user-facing chat message).
         */
    
        /**
         * Constructs a new SessionMessage.
         * @exports SessionMessage
         * @classdesc Message to be sent over a session, indicating some RPC event.
         * @implements ISessionMessage
         * @constructor
         * @param {ISessionMessage=} [properties] Properties to set
         */
        function SessionMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Event name (e.g. "text").
         * @member {string} event
         * @memberof SessionMessage
         * @instance
         */
        SessionMessage.prototype.event = "";
    
        /**
         * Associated data (e.g. a user-facing chat message).
         * @member {ISessionMessageData} data
         * @memberof SessionMessage
         * @instance
         */
        SessionMessage.prototype.data = undefined;
    
        /**
         * Creates a new SessionMessage instance using the specified properties.
         * @function create
         * @memberof SessionMessage
         * @static
         * @param {ISessionMessage=} [properties] Properties to set
         * @returns {SessionMessage} SessionMessage instance
         */
        SessionMessage.create = function create(properties) {
            return new SessionMessage(properties);
        };
    
        /**
         * Encodes the specified SessionMessage message. Does not implicitly {@link SessionMessage.verify|verify} messages.
         * @function encode
         * @memberof SessionMessage
         * @static
         * @param {ISessionMessage} message SessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.event);
            $root.SessionMessageData.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified SessionMessage message, length delimited. Does not implicitly {@link SessionMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionMessage
         * @static
         * @param {ISessionMessage} message SessionMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionMessage message from the specified reader or buffer.
         * @function decode
         * @memberof SessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionMessage} SessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.event = reader.string();
                    break;
                case 2:
                    message.data = $root.SessionMessageData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("event"))
                throw $util.ProtocolError("missing required 'event'", { instance: message });
            if (!message.hasOwnProperty("data"))
                throw $util.ProtocolError("missing required 'data'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionMessage} SessionMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionMessage message.
         * @function verify
         * @memberof SessionMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.event))
                return "event: string expected";
            {
                var error = $root.SessionMessageData.verify(message.data);
                if (error)
                    return "data." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a SessionMessage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionMessage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionMessage} SessionMessage
         */
        SessionMessage.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionMessage)
                return object;
            var message = new $root.SessionMessage();
            if (object.event != undefined)
                message.event = String(object.event);
            if (object.data != undefined) {
                if (typeof object.data !== "object")
                    throw TypeError(".SessionMessage.data: object expected");
                message.data = $root.SessionMessageData.fromObject(object.data);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SessionMessage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionMessage
         * @static
         * @param {SessionMessage} message SessionMessage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionMessage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.event = "";
                object.data = undefined;
            }
            if (message.event != undefined && message.hasOwnProperty("event"))
                object.event = message.event;
            if (message.data != undefined && message.hasOwnProperty("data"))
                object.data = $root.SessionMessageData.toObject(message.data, options);
            return object;
        };
    
        /**
         * Converts this SessionMessage to JSON.
         * @function toJSON
         * @memberof SessionMessage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionMessage;
    })();
    
    $root.SessionMessageData = (function() {
    
        /**
         * Properties of a SessionMessageData.
         * @exports ISessionMessageData
         * @interface ISessionMessageData
         * @property {string|undefined} [authorID] @see ChatMessage.authorID
         * @property {string} id Unique ID.
         * @property {number} timestamp Timestamp of this message.
         * @property {Uint8Array|undefined} [bytes] Arbitrary bytes.
         * @property {ISessionCapabilities|undefined} [capabilities] @see SessionCapabilities
         * @property {ISessionChatState|undefined} [chatState] @see SessionChatState
         * @property {ISessionCommand|undefined} [command] @see SessionCommand
         * @property {string|undefined} [sessionSubID] If applicable, ID of an isolated exchange of messages within a session.
         * @property {ISessionText|undefined} [text] @see SessionText
         * @property {ISessionTextConfirmation|undefined} [textConfirmation] @see SessionTextConfirmation
         * @property {ISessionTransfer|undefined} [transfer] @see SessionTransfer
         */
    
        /**
         * Constructs a new SessionMessageData.
         * @exports SessionMessageData
         * @classdesc Message data.
         * @implements ISessionMessageData
         * @constructor
         * @param {ISessionMessageData=} [properties] Properties to set
         */
        function SessionMessageData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see ChatMessage.authorID
         * @member {string} authorID
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.authorID = "";
    
        /**
         * Unique ID.
         * @member {string} id
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.id = "";
    
        /**
         * Timestamp of this message.
         * @member {number} timestamp
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.timestamp = 0;
    
        /**
         * Arbitrary bytes.
         * @member {Uint8Array} bytes
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.bytes = $util.newBuffer([]);
    
        /**
         * @see SessionCapabilities
         * @member {ISessionCapabilities|undefined|undefined} capabilities
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.capabilities = undefined;
    
        /**
         * @see SessionChatState
         * @member {ISessionChatState|undefined|undefined} chatState
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.chatState = undefined;
    
        /**
         * @see SessionCommand
         * @member {ISessionCommand|undefined|undefined} command
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.command = undefined;
    
        /**
         * If applicable, ID of an isolated exchange of messages within a session.
         * @member {string} sessionSubID
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.sessionSubID = "";
    
        /**
         * @see SessionText
         * @member {ISessionText|undefined|undefined} text
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.text = undefined;
    
        /**
         * @see SessionTextConfirmation
         * @member {ISessionTextConfirmation|undefined|undefined} textConfirmation
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.textConfirmation = undefined;
    
        /**
         * @see SessionTransfer
         * @member {ISessionTransfer|undefined|undefined} transfer
         * @memberof SessionMessageData
         * @instance
         */
        SessionMessageData.prototype.transfer = undefined;
    
        /**
         * Creates a new SessionMessageData instance using the specified properties.
         * @function create
         * @memberof SessionMessageData
         * @static
         * @param {ISessionMessageData=} [properties] Properties to set
         * @returns {SessionMessageData} SessionMessageData instance
         */
        SessionMessageData.create = function create(properties) {
            return new SessionMessageData(properties);
        };
    
        /**
         * Encodes the specified SessionMessageData message. Does not implicitly {@link SessionMessageData.verify|verify} messages.
         * @function encode
         * @memberof SessionMessageData
         * @static
         * @param {ISessionMessageData} message SessionMessageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessageData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.authorID);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            writer.uint32(/* id 3, wireType 1 =*/25).double(message.timestamp);
            if (message.bytes != undefined && message.hasOwnProperty("bytes"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.bytes);
            if (message.capabilities != undefined && message.hasOwnProperty("capabilities"))
                $root.SessionCapabilities.encode(message.capabilities, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.chatState != undefined && message.hasOwnProperty("chatState"))
                $root.SessionChatState.encode(message.chatState, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.command != undefined && message.hasOwnProperty("command"))
                $root.SessionCommand.encode(message.command, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sessionSubID);
            if (message.text != undefined && message.hasOwnProperty("text"))
                $root.SessionText.encode(message.text, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.textConfirmation != undefined && message.hasOwnProperty("textConfirmation"))
                $root.SessionTextConfirmation.encode(message.textConfirmation, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.transfer != undefined && message.hasOwnProperty("transfer"))
                $root.SessionTransfer.encode(message.transfer, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified SessionMessageData message, length delimited. Does not implicitly {@link SessionMessageData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionMessageData
         * @static
         * @param {ISessionMessageData} message SessionMessageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessageData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionMessageData message from the specified reader or buffer.
         * @function decode
         * @memberof SessionMessageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionMessageData} SessionMessageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessageData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionMessageData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.authorID = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.timestamp = reader.double();
                    break;
                case 4:
                    message.bytes = reader.bytes();
                    break;
                case 5:
                    message.capabilities = $root.SessionCapabilities.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.chatState = $root.SessionChatState.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.command = $root.SessionCommand.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.sessionSubID = reader.string();
                    break;
                case 9:
                    message.text = $root.SessionText.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.textConfirmation = $root.SessionTextConfirmation.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.transfer = $root.SessionTransfer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("timestamp"))
                throw $util.ProtocolError("missing required 'timestamp'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionMessageData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionMessageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionMessageData} SessionMessageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessageData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionMessageData message.
         * @function verify
         * @memberof SessionMessageData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionMessageData.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                if (!$util.isString(message.authorID))
                    return "authorID: string expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            if (typeof message.timestamp !== "number")
                return "timestamp: number expected";
            if (message.bytes != undefined && message.hasOwnProperty("bytes"))
                if (!(message.bytes && typeof message.bytes.length === "number" || $util.isString(message.bytes)))
                    return "bytes: buffer expected";
            if (message.capabilities != undefined && message.hasOwnProperty("capabilities")) {
                var error = $root.SessionCapabilities.verify(message.capabilities);
                if (error)
                    return "capabilities." + error;
            }
            if (message.chatState != undefined && message.hasOwnProperty("chatState")) {
                var error = $root.SessionChatState.verify(message.chatState);
                if (error)
                    return "chatState." + error;
            }
            if (message.command != undefined && message.hasOwnProperty("command")) {
                var error = $root.SessionCommand.verify(message.command);
                if (error)
                    return "command." + error;
            }
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                if (!$util.isString(message.sessionSubID))
                    return "sessionSubID: string expected";
            if (message.text != undefined && message.hasOwnProperty("text")) {
                var error = $root.SessionText.verify(message.text);
                if (error)
                    return "text." + error;
            }
            if (message.textConfirmation != undefined && message.hasOwnProperty("textConfirmation")) {
                var error = $root.SessionTextConfirmation.verify(message.textConfirmation);
                if (error)
                    return "textConfirmation." + error;
            }
            if (message.transfer != undefined && message.hasOwnProperty("transfer")) {
                var error = $root.SessionTransfer.verify(message.transfer);
                if (error)
                    return "transfer." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a SessionMessageData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionMessageData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionMessageData} SessionMessageData
         */
        SessionMessageData.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionMessageData)
                return object;
            var message = new $root.SessionMessageData();
            if (object.authorID != undefined)
                message.authorID = String(object.authorID);
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.timestamp != undefined)
                message.timestamp = Number(object.timestamp);
            if (object.bytes != undefined)
                if (typeof object.bytes === "string")
                    $util.base64.decode(object.bytes, message.bytes = $util.newBuffer($util.base64.length(object.bytes)), 0);
                else if (object.bytes.length)
                    message.bytes = object.bytes;
            if (object.capabilities != undefined) {
                if (typeof object.capabilities !== "object")
                    throw TypeError(".SessionMessageData.capabilities: object expected");
                message.capabilities = $root.SessionCapabilities.fromObject(object.capabilities);
            }
            if (object.chatState != undefined) {
                if (typeof object.chatState !== "object")
                    throw TypeError(".SessionMessageData.chatState: object expected");
                message.chatState = $root.SessionChatState.fromObject(object.chatState);
            }
            if (object.command != undefined) {
                if (typeof object.command !== "object")
                    throw TypeError(".SessionMessageData.command: object expected");
                message.command = $root.SessionCommand.fromObject(object.command);
            }
            if (object.sessionSubID != undefined)
                message.sessionSubID = String(object.sessionSubID);
            if (object.text != undefined) {
                if (typeof object.text !== "object")
                    throw TypeError(".SessionMessageData.text: object expected");
                message.text = $root.SessionText.fromObject(object.text);
            }
            if (object.textConfirmation != undefined) {
                if (typeof object.textConfirmation !== "object")
                    throw TypeError(".SessionMessageData.textConfirmation: object expected");
                message.textConfirmation = $root.SessionTextConfirmation.fromObject(object.textConfirmation);
            }
            if (object.transfer != undefined) {
                if (typeof object.transfer !== "object")
                    throw TypeError(".SessionMessageData.transfer: object expected");
                message.transfer = $root.SessionTransfer.fromObject(object.transfer);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SessionMessageData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionMessageData
         * @static
         * @param {SessionMessageData} message SessionMessageData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionMessageData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.authorID = "";
                object.id = "";
                object.timestamp = 0;
                object.bytes = options.bytes === String ? "" : [];
                object.capabilities = undefined;
                object.chatState = undefined;
                object.command = undefined;
                object.sessionSubID = "";
                object.text = undefined;
                object.textConfirmation = undefined;
                object.transfer = undefined;
            }
            if (message.authorID != undefined && message.hasOwnProperty("authorID"))
                object.authorID = message.authorID;
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.timestamp != undefined && message.hasOwnProperty("timestamp"))
                object.timestamp = options.json && !isFinite(message.timestamp) ? String(message.timestamp) : message.timestamp;
            if (message.bytes != undefined && message.hasOwnProperty("bytes"))
                object.bytes = options.bytes === String ? $util.base64.encode(message.bytes, 0, message.bytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytes) : message.bytes;
            if (message.capabilities != undefined && message.hasOwnProperty("capabilities"))
                object.capabilities = $root.SessionCapabilities.toObject(message.capabilities, options);
            if (message.chatState != undefined && message.hasOwnProperty("chatState"))
                object.chatState = $root.SessionChatState.toObject(message.chatState, options);
            if (message.command != undefined && message.hasOwnProperty("command"))
                object.command = $root.SessionCommand.toObject(message.command, options);
            if (message.sessionSubID != undefined && message.hasOwnProperty("sessionSubID"))
                object.sessionSubID = message.sessionSubID;
            if (message.text != undefined && message.hasOwnProperty("text"))
                object.text = $root.SessionText.toObject(message.text, options);
            if (message.textConfirmation != undefined && message.hasOwnProperty("textConfirmation"))
                object.textConfirmation = $root.SessionTextConfirmation.toObject(message.textConfirmation, options);
            if (message.transfer != undefined && message.hasOwnProperty("transfer"))
                object.transfer = $root.SessionTransfer.toObject(message.transfer, options);
            return object;
        };
    
        /**
         * Converts this SessionMessageData to JSON.
         * @function toJSON
         * @memberof SessionMessageData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionMessageData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionMessageData;
    })();
    
    $root.SessionMessageList = (function() {
    
        /**
         * Properties of a SessionMessageList.
         * @exports ISessionMessageList
         * @interface ISessionMessageList
         * @property {Array.<ISessionMessage>|undefined} [messages] Messages.
         */
    
        /**
         * Constructs a new SessionMessageList.
         * @exports SessionMessageList
         * @classdesc Array of session messages.
         * @implements ISessionMessageList
         * @constructor
         * @param {ISessionMessageList=} [properties] Properties to set
         */
        function SessionMessageList(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Messages.
         * @member {Array.<ISessionMessage>} messages
         * @memberof SessionMessageList
         * @instance
         */
        SessionMessageList.prototype.messages = $util.emptyArray;
    
        /**
         * Creates a new SessionMessageList instance using the specified properties.
         * @function create
         * @memberof SessionMessageList
         * @static
         * @param {ISessionMessageList=} [properties] Properties to set
         * @returns {SessionMessageList} SessionMessageList instance
         */
        SessionMessageList.create = function create(properties) {
            return new SessionMessageList(properties);
        };
    
        /**
         * Encodes the specified SessionMessageList message. Does not implicitly {@link SessionMessageList.verify|verify} messages.
         * @function encode
         * @memberof SessionMessageList
         * @static
         * @param {ISessionMessageList} message SessionMessageList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessageList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != undefined && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.SessionMessage.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified SessionMessageList message, length delimited. Does not implicitly {@link SessionMessageList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionMessageList
         * @static
         * @param {ISessionMessageList} message SessionMessageList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionMessageList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionMessageList message from the specified reader or buffer.
         * @function decode
         * @memberof SessionMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionMessageList} SessionMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessageList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionMessageList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.SessionMessage.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes a SessionMessageList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionMessageList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionMessageList} SessionMessageList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionMessageList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionMessageList message.
         * @function verify
         * @memberof SessionMessageList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionMessageList.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.messages != undefined && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.SessionMessage.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            return undefined;
        };
    
        /**
         * Creates a SessionMessageList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionMessageList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionMessageList} SessionMessageList
         */
        SessionMessageList.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionMessageList)
                return object;
            var message = new $root.SessionMessageList();
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".SessionMessageList.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".SessionMessageList.messages: object expected");
                    message.messages[i] = $root.SessionMessage.fromObject(object.messages[i]);
                }
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SessionMessageList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionMessageList
         * @static
         * @param {SessionMessageList} message SessionMessageList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionMessageList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.SessionMessage.toObject(message.messages[j], options);
            }
            return object;
        };
    
        /**
         * Converts this SessionMessageList to JSON.
         * @function toJSON
         * @memberof SessionMessageList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionMessageList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionMessageList;
    })();
    
    $root.SessionText = (function() {
    
        /**
         * Properties of a SessionText.
         * @exports ISessionText
         * @interface ISessionText
         * @property {Array.<IChatMessageLine>|undefined} [dimensions] @see ChatMessage.dimensions
         * @property {boolean|undefined} [selfDestructChat] Indicates whether entire chat should be self-destructed (only valid for first message).
         * @property {number|undefined} [selfDestructTimeout] Self-destruction timeout.
         * @property {IChatMessageValue} value @see ChatMessageValue
         */
    
        /**
         * Constructs a new SessionText.
         * @exports SessionText
         * @classdesc Contains an actual chat text message.
         * @implements ISessionText
         * @constructor
         * @param {ISessionText=} [properties] Properties to set
         */
        function SessionText(properties) {
            this.dimensions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * @see ChatMessage.dimensions
         * @member {Array.<IChatMessageLine>} dimensions
         * @memberof SessionText
         * @instance
         */
        SessionText.prototype.dimensions = $util.emptyArray;
    
        /**
         * Indicates whether entire chat should be self-destructed (only valid for first message).
         * @member {boolean} selfDestructChat
         * @memberof SessionText
         * @instance
         */
        SessionText.prototype.selfDestructChat = false;
    
        /**
         * Self-destruction timeout.
         * @member {number} selfDestructTimeout
         * @memberof SessionText
         * @instance
         */
        SessionText.prototype.selfDestructTimeout = 0;
    
        /**
         * @see ChatMessageValue
         * @member {IChatMessageValue} value
         * @memberof SessionText
         * @instance
         */
        SessionText.prototype.value = undefined;
    
        /**
         * Creates a new SessionText instance using the specified properties.
         * @function create
         * @memberof SessionText
         * @static
         * @param {ISessionText=} [properties] Properties to set
         * @returns {SessionText} SessionText instance
         */
        SessionText.create = function create(properties) {
            return new SessionText(properties);
        };
    
        /**
         * Encodes the specified SessionText message. Does not implicitly {@link SessionText.verify|verify} messages.
         * @function encode
         * @memberof SessionText
         * @static
         * @param {ISessionText} message SessionText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionText.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dimensions != undefined && message.dimensions.length)
                for (var i = 0; i < message.dimensions.length; ++i)
                    $root.ChatMessageLine.encode(message.dimensions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.selfDestructChat != undefined && message.hasOwnProperty("selfDestructChat"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.selfDestructChat);
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.selfDestructTimeout);
            $root.ChatMessageValue.encode(message.value, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };
    
        /**
         * Encodes the specified SessionText message, length delimited. Does not implicitly {@link SessionText.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionText
         * @static
         * @param {ISessionText} message SessionText message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionText.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionText message from the specified reader or buffer.
         * @function decode
         * @memberof SessionText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionText} SessionText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionText.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionText();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.dimensions && message.dimensions.length))
                        message.dimensions = [];
                    message.dimensions.push($root.ChatMessageLine.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.selfDestructChat = reader.bool();
                    break;
                case 3:
                    message.selfDestructTimeout = reader.uint32();
                    break;
                case 4:
                    message.value = $root.ChatMessageValue.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("value"))
                throw $util.ProtocolError("missing required 'value'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionText message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionText
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionText} SessionText
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionText.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionText message.
         * @function verify
         * @memberof SessionText
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionText.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (message.dimensions != undefined && message.hasOwnProperty("dimensions")) {
                if (!Array.isArray(message.dimensions))
                    return "dimensions: array expected";
                for (var i = 0; i < message.dimensions.length; ++i) {
                    var error = $root.ChatMessageLine.verify(message.dimensions[i]);
                    if (error)
                        return "dimensions." + error;
                }
            }
            if (message.selfDestructChat != undefined && message.hasOwnProperty("selfDestructChat"))
                if (typeof message.selfDestructChat !== "boolean")
                    return "selfDestructChat: boolean expected";
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                if (!$util.isInteger(message.selfDestructTimeout))
                    return "selfDestructTimeout: integer expected";
            {
                var error = $root.ChatMessageValue.verify(message.value);
                if (error)
                    return "value." + error;
            }
            return undefined;
        };
    
        /**
         * Creates a SessionText message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionText
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionText} SessionText
         */
        SessionText.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionText)
                return object;
            var message = new $root.SessionText();
            if (object.dimensions) {
                if (!Array.isArray(object.dimensions))
                    throw TypeError(".SessionText.dimensions: array expected");
                message.dimensions = [];
                for (var i = 0; i < object.dimensions.length; ++i) {
                    if (typeof object.dimensions[i] !== "object")
                        throw TypeError(".SessionText.dimensions: object expected");
                    message.dimensions[i] = $root.ChatMessageLine.fromObject(object.dimensions[i]);
                }
            }
            if (object.selfDestructChat != undefined)
                message.selfDestructChat = Boolean(object.selfDestructChat);
            if (object.selfDestructTimeout != undefined)
                message.selfDestructTimeout = object.selfDestructTimeout >>> 0;
            if (object.value != undefined) {
                if (typeof object.value !== "object")
                    throw TypeError(".SessionText.value: object expected");
                message.value = $root.ChatMessageValue.fromObject(object.value);
            }
            return message;
        };
    
        /**
         * Creates a plain object from a SessionText message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionText
         * @static
         * @param {SessionText} message SessionText
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionText.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.dimensions = [];
            if (options.defaults) {
                object.selfDestructChat = false;
                object.selfDestructTimeout = 0;
                object.value = undefined;
            }
            if (message.dimensions && message.dimensions.length) {
                object.dimensions = [];
                for (var j = 0; j < message.dimensions.length; ++j)
                    object.dimensions[j] = $root.ChatMessageLine.toObject(message.dimensions[j], options);
            }
            if (message.selfDestructChat != undefined && message.hasOwnProperty("selfDestructChat"))
                object.selfDestructChat = message.selfDestructChat;
            if (message.selfDestructTimeout != undefined && message.hasOwnProperty("selfDestructTimeout"))
                object.selfDestructTimeout = message.selfDestructTimeout;
            if (message.value != undefined && message.hasOwnProperty("value"))
                object.value = $root.ChatMessageValue.toObject(message.value, options);
            return object;
        };
    
        /**
         * Converts this SessionText to JSON.
         * @function toJSON
         * @memberof SessionText
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionText.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionText;
    })();
    
    $root.SessionTextConfirmation = (function() {
    
        /**
         * Properties of a SessionTextConfirmation.
         * @exports ISessionTextConfirmation
         * @interface ISessionTextConfirmation
         * @property {string} id SessionText ID to be confirmed.
         */
    
        /**
         * Constructs a new SessionTextConfirmation.
         * @exports SessionTextConfirmation
         * @classdesc Receipt confirmation for a SessionText.
         * @implements ISessionTextConfirmation
         * @constructor
         * @param {ISessionTextConfirmation=} [properties] Properties to set
         */
        function SessionTextConfirmation(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * SessionText ID to be confirmed.
         * @member {string} id
         * @memberof SessionTextConfirmation
         * @instance
         */
        SessionTextConfirmation.prototype.id = "";
    
        /**
         * Creates a new SessionTextConfirmation instance using the specified properties.
         * @function create
         * @memberof SessionTextConfirmation
         * @static
         * @param {ISessionTextConfirmation=} [properties] Properties to set
         * @returns {SessionTextConfirmation} SessionTextConfirmation instance
         */
        SessionTextConfirmation.create = function create(properties) {
            return new SessionTextConfirmation(properties);
        };
    
        /**
         * Encodes the specified SessionTextConfirmation message. Does not implicitly {@link SessionTextConfirmation.verify|verify} messages.
         * @function encode
         * @memberof SessionTextConfirmation
         * @static
         * @param {ISessionTextConfirmation} message SessionTextConfirmation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionTextConfirmation.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };
    
        /**
         * Encodes the specified SessionTextConfirmation message, length delimited. Does not implicitly {@link SessionTextConfirmation.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionTextConfirmation
         * @static
         * @param {ISessionTextConfirmation} message SessionTextConfirmation message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionTextConfirmation.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionTextConfirmation message from the specified reader or buffer.
         * @function decode
         * @memberof SessionTextConfirmation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionTextConfirmation} SessionTextConfirmation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionTextConfirmation.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionTextConfirmation();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionTextConfirmation message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionTextConfirmation
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionTextConfirmation} SessionTextConfirmation
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionTextConfirmation.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionTextConfirmation message.
         * @function verify
         * @memberof SessionTextConfirmation
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionTextConfirmation.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            if (!$util.isString(message.id))
                return "id: string expected";
            return undefined;
        };
    
        /**
         * Creates a SessionTextConfirmation message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionTextConfirmation
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionTextConfirmation} SessionTextConfirmation
         */
        SessionTextConfirmation.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionTextConfirmation)
                return object;
            var message = new $root.SessionTextConfirmation();
            if (object.id != undefined)
                message.id = String(object.id);
            return message;
        };
    
        /**
         * Creates a plain object from a SessionTextConfirmation message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionTextConfirmation
         * @static
         * @param {SessionTextConfirmation} message SessionTextConfirmation
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionTextConfirmation.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };
    
        /**
         * Converts this SessionTextConfirmation to JSON.
         * @function toJSON
         * @memberof SessionTextConfirmation
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionTextConfirmation.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        return SessionTextConfirmation;
    })();
    
    $root.SessionTransfer = (function() {
    
        /**
         * Properties of a SessionTransfer.
         * @exports ISessionTransfer
         * @interface ISessionTransfer
         * @property {SessionTransfer.Answers} answer Indicates a non-response to, acceptance of, or rejection of a file transfer.
         * @property {string} id Unique ID to represent this file transfer.
         * @property {boolean} image Indicates whether file should be handled as an image.
         * @property {number} imageSelfDestructTimeout If image is true, this will be used as a self-destruct timeout for the message.
         * @property {boolean} isOutgoing Indicates whether file is being sent from this Cyph instance.
         * @property {Uint8Array} key Symmetric key used for encrypting file over the wire.
         * @property {string} mediaType MIME type.
         * @property {string} name File name.
         * @property {number|undefined} [receiptTimestamp] Indicates the time at which the file was received.
         * @property {number} size File size in bytes.
         * @property {string} url File URL.
         */
    
        /**
         * Constructs a new SessionTransfer.
         * @exports SessionTransfer
         * @classdesc Represents an active file transfer.
         * @implements ISessionTransfer
         * @constructor
         * @param {ISessionTransfer=} [properties] Properties to set
         */
        function SessionTransfer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Indicates a non-response to, acceptance of, or rejection of a file transfer.
         * @member {SessionTransfer.Answers} answer
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.answer = 0;
    
        /**
         * Unique ID to represent this file transfer.
         * @member {string} id
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.id = "";
    
        /**
         * Indicates whether file should be handled as an image.
         * @member {boolean} image
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.image = false;
    
        /**
         * If image is true, this will be used as a self-destruct timeout for the message.
         * @member {number} imageSelfDestructTimeout
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.imageSelfDestructTimeout = 0;
    
        /**
         * Indicates whether file is being sent from this Cyph instance.
         * @member {boolean} isOutgoing
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.isOutgoing = false;
    
        /**
         * Symmetric key used for encrypting file over the wire.
         * @member {Uint8Array} key
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.key = $util.newBuffer([]);
    
        /**
         * MIME type.
         * @member {string} mediaType
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.mediaType = "";
    
        /**
         * File name.
         * @member {string} name
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.name = "";
    
        /**
         * Indicates the time at which the file was received.
         * @member {number} receiptTimestamp
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.receiptTimestamp = 0;
    
        /**
         * File size in bytes.
         * @member {number} size
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.size = 0;
    
        /**
         * File URL.
         * @member {string} url
         * @memberof SessionTransfer
         * @instance
         */
        SessionTransfer.prototype.url = "";
    
        /**
         * Creates a new SessionTransfer instance using the specified properties.
         * @function create
         * @memberof SessionTransfer
         * @static
         * @param {ISessionTransfer=} [properties] Properties to set
         * @returns {SessionTransfer} SessionTransfer instance
         */
        SessionTransfer.create = function create(properties) {
            return new SessionTransfer(properties);
        };
    
        /**
         * Encodes the specified SessionTransfer message. Does not implicitly {@link SessionTransfer.verify|verify} messages.
         * @function encode
         * @memberof SessionTransfer
         * @static
         * @param {ISessionTransfer} message SessionTransfer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionTransfer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.answer);
            writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            writer.uint32(/* id 3, wireType 0 =*/24).bool(message.image);
            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.imageSelfDestructTimeout);
            writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isOutgoing);
            writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.key);
            writer.uint32(/* id 7, wireType 2 =*/58).string(message.mediaType);
            writer.uint32(/* id 8, wireType 2 =*/66).string(message.name);
            if (message.receiptTimestamp != undefined && message.hasOwnProperty("receiptTimestamp"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.receiptTimestamp);
            writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.size);
            writer.uint32(/* id 11, wireType 2 =*/90).string(message.url);
            return writer;
        };
    
        /**
         * Encodes the specified SessionTransfer message, length delimited. Does not implicitly {@link SessionTransfer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof SessionTransfer
         * @static
         * @param {ISessionTransfer} message SessionTransfer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SessionTransfer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes a SessionTransfer message from the specified reader or buffer.
         * @function decode
         * @memberof SessionTransfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {SessionTransfer} SessionTransfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionTransfer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.SessionTransfer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.answer = reader.int32();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                case 3:
                    message.image = reader.bool();
                    break;
                case 4:
                    message.imageSelfDestructTimeout = reader.uint32();
                    break;
                case 5:
                    message.isOutgoing = reader.bool();
                    break;
                case 6:
                    message.key = reader.bytes();
                    break;
                case 7:
                    message.mediaType = reader.string();
                    break;
                case 8:
                    message.name = reader.string();
                    break;
                case 9:
                    message.receiptTimestamp = reader.double();
                    break;
                case 10:
                    message.size = reader.uint32();
                    break;
                case 11:
                    message.url = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            if (!message.hasOwnProperty("answer"))
                throw $util.ProtocolError("missing required 'answer'", { instance: message });
            if (!message.hasOwnProperty("id"))
                throw $util.ProtocolError("missing required 'id'", { instance: message });
            if (!message.hasOwnProperty("image"))
                throw $util.ProtocolError("missing required 'image'", { instance: message });
            if (!message.hasOwnProperty("imageSelfDestructTimeout"))
                throw $util.ProtocolError("missing required 'imageSelfDestructTimeout'", { instance: message });
            if (!message.hasOwnProperty("isOutgoing"))
                throw $util.ProtocolError("missing required 'isOutgoing'", { instance: message });
            if (!message.hasOwnProperty("key"))
                throw $util.ProtocolError("missing required 'key'", { instance: message });
            if (!message.hasOwnProperty("mediaType"))
                throw $util.ProtocolError("missing required 'mediaType'", { instance: message });
            if (!message.hasOwnProperty("name"))
                throw $util.ProtocolError("missing required 'name'", { instance: message });
            if (!message.hasOwnProperty("size"))
                throw $util.ProtocolError("missing required 'size'", { instance: message });
            if (!message.hasOwnProperty("url"))
                throw $util.ProtocolError("missing required 'url'", { instance: message });
            return message;
        };
    
        /**
         * Decodes a SessionTransfer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof SessionTransfer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {SessionTransfer} SessionTransfer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SessionTransfer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies a SessionTransfer message.
         * @function verify
         * @memberof SessionTransfer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        SessionTransfer.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            switch (message.answer) {
            default:
                return "answer: enum value expected";
            case 0:
            case 1:
            case 2:
                break;
            }
            if (!$util.isString(message.id))
                return "id: string expected";
            if (typeof message.image !== "boolean")
                return "image: boolean expected";
            if (!$util.isInteger(message.imageSelfDestructTimeout))
                return "imageSelfDestructTimeout: integer expected";
            if (typeof message.isOutgoing !== "boolean")
                return "isOutgoing: boolean expected";
            if (!(message.key && typeof message.key.length === "number" || $util.isString(message.key)))
                return "key: buffer expected";
            if (!$util.isString(message.mediaType))
                return "mediaType: string expected";
            if (!$util.isString(message.name))
                return "name: string expected";
            if (message.receiptTimestamp != undefined && message.hasOwnProperty("receiptTimestamp"))
                if (typeof message.receiptTimestamp !== "number")
                    return "receiptTimestamp: number expected";
            if (!$util.isInteger(message.size))
                return "size: integer expected";
            if (!$util.isString(message.url))
                return "url: string expected";
            return undefined;
        };
    
        /**
         * Creates a SessionTransfer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof SessionTransfer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {SessionTransfer} SessionTransfer
         */
        SessionTransfer.fromObject = function fromObject(object) {
            if (object instanceof $root.SessionTransfer)
                return object;
            var message = new $root.SessionTransfer();
            switch (object.answer) {
            case "Empty":
            case 0:
                message.answer = 0;
                break;
            case "Accepted":
            case 1:
                message.answer = 1;
                break;
            case "Rejected":
            case 2:
                message.answer = 2;
                break;
            }
            if (object.id != undefined)
                message.id = String(object.id);
            if (object.image != undefined)
                message.image = Boolean(object.image);
            if (object.imageSelfDestructTimeout != undefined)
                message.imageSelfDestructTimeout = object.imageSelfDestructTimeout >>> 0;
            if (object.isOutgoing != undefined)
                message.isOutgoing = Boolean(object.isOutgoing);
            if (object.key != undefined)
                if (typeof object.key === "string")
                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);
                else if (object.key.length)
                    message.key = object.key;
            if (object.mediaType != undefined)
                message.mediaType = String(object.mediaType);
            if (object.name != undefined)
                message.name = String(object.name);
            if (object.receiptTimestamp != undefined)
                message.receiptTimestamp = Number(object.receiptTimestamp);
            if (object.size != undefined)
                message.size = object.size >>> 0;
            if (object.url != undefined)
                message.url = String(object.url);
            return message;
        };
    
        /**
         * Creates a plain object from a SessionTransfer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof SessionTransfer
         * @static
         * @param {SessionTransfer} message SessionTransfer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SessionTransfer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.answer = options.enums === String ? "Empty" : 0;
                object.id = "";
                object.image = false;
                object.imageSelfDestructTimeout = 0;
                object.isOutgoing = false;
                object.key = options.bytes === String ? "" : [];
                object.mediaType = "";
                object.name = "";
                object.receiptTimestamp = 0;
                object.size = 0;
                object.url = "";
            }
            if (message.answer != undefined && message.hasOwnProperty("answer"))
                object.answer = options.enums === String ? $root.SessionTransfer.Answers[message.answer] : message.answer;
            if (message.id != undefined && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.image != undefined && message.hasOwnProperty("image"))
                object.image = message.image;
            if (message.imageSelfDestructTimeout != undefined && message.hasOwnProperty("imageSelfDestructTimeout"))
                object.imageSelfDestructTimeout = message.imageSelfDestructTimeout;
            if (message.isOutgoing != undefined && message.hasOwnProperty("isOutgoing"))
                object.isOutgoing = message.isOutgoing;
            if (message.key != undefined && message.hasOwnProperty("key"))
                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;
            if (message.mediaType != undefined && message.hasOwnProperty("mediaType"))
                object.mediaType = message.mediaType;
            if (message.name != undefined && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.receiptTimestamp != undefined && message.hasOwnProperty("receiptTimestamp"))
                object.receiptTimestamp = options.json && !isFinite(message.receiptTimestamp) ? String(message.receiptTimestamp) : message.receiptTimestamp;
            if (message.size != undefined && message.hasOwnProperty("size"))
                object.size = message.size;
            if (message.url != undefined && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };
    
        /**
         * Converts this SessionTransfer to JSON.
         * @function toJSON
         * @memberof SessionTransfer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SessionTransfer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        /**
         * Possible responses to a transfer request.
         * @name SessionTransfer.Answers
         * @enum {string}
         * @property {number} Empty=0 Empty value
         * @property {number} Accepted=1 Accepted value
         * @property {number} Rejected=2 Rejected value
         */
        SessionTransfer.Answers = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Empty"] = 0;
            values[valuesById[1] = "Accepted"] = 1;
            values[valuesById[2] = "Rejected"] = 2;
            return values;
        })();
    
        return SessionTransfer;
    })();
    
    $root.Internal = (function() {
    
        /**
         * Properties of an Internal.
         * @exports IInternal
         * @interface IInternal
         */
    
        /**
         * Constructs a new Internal.
         * @exports Internal
         * @classdesc Represents an Internal.
         * @implements IInternal
         * @constructor
         * @param {IInternal=} [properties] Properties to set
         */
        function Internal(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != undefined)
                        this[keys[i]] = properties[keys[i]];
        }
    
        /**
         * Creates a new Internal instance using the specified properties.
         * @function create
         * @memberof Internal
         * @static
         * @param {IInternal=} [properties] Properties to set
         * @returns {Internal} Internal instance
         */
        Internal.create = function create(properties) {
            return new Internal(properties);
        };
    
        /**
         * Encodes the specified Internal message. Does not implicitly {@link Internal.verify|verify} messages.
         * @function encode
         * @memberof Internal
         * @static
         * @param {IInternal} message Internal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Internal.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };
    
        /**
         * Encodes the specified Internal message, length delimited. Does not implicitly {@link Internal.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Internal
         * @static
         * @param {IInternal} message Internal message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Internal.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };
    
        /**
         * Decodes an Internal message from the specified reader or buffer.
         * @function decode
         * @memberof Internal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Internal} Internal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Internal.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };
    
        /**
         * Decodes an Internal message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Internal
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Internal} Internal
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Internal.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };
    
        /**
         * Verifies an Internal message.
         * @function verify
         * @memberof Internal
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
         */
        Internal.verify = function verify(message) {
            if (typeof message !== "object" || message === undefined)
                return "object expected";
            return undefined;
        };
    
        /**
         * Creates an Internal message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof Internal
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {Internal} Internal
         */
        Internal.fromObject = function fromObject(object) {
            if (object instanceof $root.Internal)
                return object;
            return new $root.Internal();
        };
    
        /**
         * Creates a plain object from an Internal message. Also converts values to other types if specified.
         * @function toObject
         * @memberof Internal
         * @static
         * @param {Internal} message Internal
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Internal.toObject = function toObject() {
            return {};
        };
    
        /**
         * Converts this Internal to JSON.
         * @function toJSON
         * @memberof Internal
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Internal.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
    
        Internal.BooleanArray = (function() {
    
            /**
             * Properties of a BooleanArray.
             * @memberof Internal
             * @interface IBooleanArray
             * @property {Array.<boolean>|undefined} [data] BooleanArray data
             */
    
            /**
             * Constructs a new BooleanArray.
             * @memberof Internal
             * @classdesc Represents a BooleanArray.
             * @implements IBooleanArray
             * @constructor
             * @param {Internal.IBooleanArray=} [properties] Properties to set
             */
            function BooleanArray(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BooleanArray data.
             * @member {Array.<boolean>} data
             * @memberof Internal.BooleanArray
             * @instance
             */
            BooleanArray.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new BooleanArray instance using the specified properties.
             * @function create
             * @memberof Internal.BooleanArray
             * @static
             * @param {Internal.IBooleanArray=} [properties] Properties to set
             * @returns {Internal.BooleanArray} BooleanArray instance
             */
            BooleanArray.create = function create(properties) {
                return new BooleanArray(properties);
            };
    
            /**
             * Encodes the specified BooleanArray message. Does not implicitly {@link Internal.BooleanArray.verify|verify} messages.
             * @function encode
             * @memberof Internal.BooleanArray
             * @static
             * @param {Internal.IBooleanArray} message BooleanArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanArray.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.data.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.bool(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified BooleanArray message, length delimited. Does not implicitly {@link Internal.BooleanArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.BooleanArray
             * @static
             * @param {Internal.IBooleanArray} message BooleanArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanArray.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BooleanArray message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.BooleanArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.BooleanArray} BooleanArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanArray.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.BooleanArray();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.data.push(reader.bool());
                        } else
                            message.data.push(reader.bool());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BooleanArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.BooleanArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.BooleanArray} BooleanArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanArray.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BooleanArray message.
             * @function verify
             * @memberof Internal.BooleanArray
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            BooleanArray.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (typeof message.data[i] !== "boolean")
                            return "data: boolean[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a BooleanArray message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.BooleanArray
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.BooleanArray} BooleanArray
             */
            BooleanArray.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.BooleanArray)
                    return object;
                var message = new $root.Internal.BooleanArray();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".Internal.BooleanArray.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = Boolean(object.data[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BooleanArray message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.BooleanArray
             * @static
             * @param {Internal.BooleanArray} message BooleanArray
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BooleanArray.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this BooleanArray to JSON.
             * @function toJSON
             * @memberof Internal.BooleanArray
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BooleanArray.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BooleanArray;
        })();
    
        Internal.BooleanMap = (function() {
    
            /**
             * Properties of a BooleanMap.
             * @memberof Internal
             * @interface IBooleanMap
             * @property {Object.<string,boolean>|undefined} [data] BooleanMap data
             */
    
            /**
             * Constructs a new BooleanMap.
             * @memberof Internal
             * @classdesc Represents a BooleanMap.
             * @implements IBooleanMap
             * @constructor
             * @param {Internal.IBooleanMap=} [properties] Properties to set
             */
            function BooleanMap(properties) {
                this.data = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BooleanMap data.
             * @member {Object.<string,boolean>} data
             * @memberof Internal.BooleanMap
             * @instance
             */
            BooleanMap.prototype.data = $util.emptyObject;
    
            /**
             * Creates a new BooleanMap instance using the specified properties.
             * @function create
             * @memberof Internal.BooleanMap
             * @static
             * @param {Internal.IBooleanMap=} [properties] Properties to set
             * @returns {Internal.BooleanMap} BooleanMap instance
             */
            BooleanMap.create = function create(properties) {
                return new BooleanMap(properties);
            };
    
            /**
             * Encodes the specified BooleanMap message. Does not implicitly {@link Internal.BooleanMap.verify|verify} messages.
             * @function encode
             * @memberof Internal.BooleanMap
             * @static
             * @param {Internal.IBooleanMap} message BooleanMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.hasOwnProperty("data"))
                    for (var keys = Object.keys(message.data), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).bool(message.data[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified BooleanMap message, length delimited. Does not implicitly {@link Internal.BooleanMap.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.BooleanMap
             * @static
             * @param {Internal.IBooleanMap} message BooleanMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanMap.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BooleanMap message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.BooleanMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.BooleanMap} BooleanMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.BooleanMap(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.data === $util.emptyObject)
                            message.data = {};
                        key = reader.string();
                        reader.pos++;
                        message.data[key] = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a BooleanMap message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.BooleanMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.BooleanMap} BooleanMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanMap.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BooleanMap message.
             * @function verify
             * @memberof Internal.BooleanMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            BooleanMap.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!$util.isObject(message.data))
                        return "data: object expected";
                    var key = Object.keys(message.data);
                    for (var i = 0; i < key.length; ++i)
                        if (typeof message.data[key[i]] !== "boolean")
                            return "data: boolean{k:string} expected";
                }
                return undefined;
            };
    
            /**
             * Creates a BooleanMap message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.BooleanMap
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.BooleanMap} BooleanMap
             */
            BooleanMap.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.BooleanMap)
                    return object;
                var message = new $root.Internal.BooleanMap();
                if (object.data) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Internal.BooleanMap.data: object expected");
                    message.data = {};
                    for (var keys = Object.keys(object.data), i = 0; i < keys.length; ++i)
                        message.data[keys[i]] = Boolean(object.data[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a BooleanMap message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.BooleanMap
             * @static
             * @param {Internal.BooleanMap} message BooleanMap
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BooleanMap.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.data = {};
                var keys2;
                if (message.data && (keys2 = Object.keys(message.data)).length) {
                    object.data = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.data[keys2[j]] = message.data[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this BooleanMap to JSON.
             * @function toJSON
             * @memberof Internal.BooleanMap
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BooleanMap.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BooleanMap;
        })();
    
        Internal.BooleanValue = (function() {
    
            /**
             * Properties of a BooleanValue.
             * @memberof Internal
             * @interface IBooleanValue
             * @property {boolean} data BooleanValue data
             */
    
            /**
             * Constructs a new BooleanValue.
             * @memberof Internal
             * @classdesc Represents a BooleanValue.
             * @implements IBooleanValue
             * @constructor
             * @param {Internal.IBooleanValue=} [properties] Properties to set
             */
            function BooleanValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BooleanValue data.
             * @member {boolean} data
             * @memberof Internal.BooleanValue
             * @instance
             */
            BooleanValue.prototype.data = false;
    
            /**
             * Creates a new BooleanValue instance using the specified properties.
             * @function create
             * @memberof Internal.BooleanValue
             * @static
             * @param {Internal.IBooleanValue=} [properties] Properties to set
             * @returns {Internal.BooleanValue} BooleanValue instance
             */
            BooleanValue.create = function create(properties) {
                return new BooleanValue(properties);
            };
    
            /**
             * Encodes the specified BooleanValue message. Does not implicitly {@link Internal.BooleanValue.verify|verify} messages.
             * @function encode
             * @memberof Internal.BooleanValue
             * @static
             * @param {Internal.IBooleanValue} message BooleanValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified BooleanValue message, length delimited. Does not implicitly {@link Internal.BooleanValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.BooleanValue
             * @static
             * @param {Internal.IBooleanValue} message BooleanValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BooleanValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a BooleanValue message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.BooleanValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.BooleanValue} BooleanValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.BooleanValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("data"))
                    throw $util.ProtocolError("missing required 'data'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a BooleanValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.BooleanValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.BooleanValue} BooleanValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BooleanValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a BooleanValue message.
             * @function verify
             * @memberof Internal.BooleanValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            BooleanValue.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (typeof message.data !== "boolean")
                    return "data: boolean expected";
                return undefined;
            };
    
            /**
             * Creates a BooleanValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.BooleanValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.BooleanValue} BooleanValue
             */
            BooleanValue.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.BooleanValue)
                    return object;
                var message = new $root.Internal.BooleanValue();
                if (object.data != undefined)
                    message.data = Boolean(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a BooleanValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.BooleanValue
             * @static
             * @param {Internal.BooleanValue} message BooleanValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BooleanValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = false;
                if (message.data != undefined && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this BooleanValue to JSON.
             * @function toJSON
             * @memberof Internal.BooleanValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BooleanValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return BooleanValue;
        })();
    
        Internal.NumberArray = (function() {
    
            /**
             * Properties of a NumberArray.
             * @memberof Internal
             * @interface INumberArray
             * @property {Array.<number>|undefined} [data] NumberArray data
             */
    
            /**
             * Constructs a new NumberArray.
             * @memberof Internal
             * @classdesc Represents a NumberArray.
             * @implements INumberArray
             * @constructor
             * @param {Internal.INumberArray=} [properties] Properties to set
             */
            function NumberArray(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NumberArray data.
             * @member {Array.<number>} data
             * @memberof Internal.NumberArray
             * @instance
             */
            NumberArray.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new NumberArray instance using the specified properties.
             * @function create
             * @memberof Internal.NumberArray
             * @static
             * @param {Internal.INumberArray=} [properties] Properties to set
             * @returns {Internal.NumberArray} NumberArray instance
             */
            NumberArray.create = function create(properties) {
                return new NumberArray(properties);
            };
    
            /**
             * Encodes the specified NumberArray message. Does not implicitly {@link Internal.NumberArray.verify|verify} messages.
             * @function encode
             * @memberof Internal.NumberArray
             * @static
             * @param {Internal.INumberArray} message NumberArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumberArray.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.data.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.double(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified NumberArray message, length delimited. Does not implicitly {@link Internal.NumberArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.NumberArray
             * @static
             * @param {Internal.INumberArray} message NumberArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumberArray.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NumberArray message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.NumberArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.NumberArray} NumberArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumberArray.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.NumberArray();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.data.push(reader.double());
                        } else
                            message.data.push(reader.double());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a NumberArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.NumberArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.NumberArray} NumberArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumberArray.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NumberArray message.
             * @function verify
             * @memberof Internal.NumberArray
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            NumberArray.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (typeof message.data[i] !== "number")
                            return "data: number[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a NumberArray message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.NumberArray
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.NumberArray} NumberArray
             */
            NumberArray.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.NumberArray)
                    return object;
                var message = new $root.Internal.NumberArray();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".Internal.NumberArray.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = Number(object.data[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a NumberArray message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.NumberArray
             * @static
             * @param {Internal.NumberArray} message NumberArray
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NumberArray.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = options.json && !isFinite(message.data[j]) ? String(message.data[j]) : message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this NumberArray to JSON.
             * @function toJSON
             * @memberof Internal.NumberArray
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NumberArray.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NumberArray;
        })();
    
        Internal.NumberValue = (function() {
    
            /**
             * Properties of a NumberValue.
             * @memberof Internal
             * @interface INumberValue
             * @property {number} data NumberValue data
             */
    
            /**
             * Constructs a new NumberValue.
             * @memberof Internal
             * @classdesc Represents a NumberValue.
             * @implements INumberValue
             * @constructor
             * @param {Internal.INumberValue=} [properties] Properties to set
             */
            function NumberValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NumberValue data.
             * @member {number} data
             * @memberof Internal.NumberValue
             * @instance
             */
            NumberValue.prototype.data = 0;
    
            /**
             * Creates a new NumberValue instance using the specified properties.
             * @function create
             * @memberof Internal.NumberValue
             * @static
             * @param {Internal.INumberValue=} [properties] Properties to set
             * @returns {Internal.NumberValue} NumberValue instance
             */
            NumberValue.create = function create(properties) {
                return new NumberValue(properties);
            };
    
            /**
             * Encodes the specified NumberValue message. Does not implicitly {@link Internal.NumberValue.verify|verify} messages.
             * @function encode
             * @memberof Internal.NumberValue
             * @static
             * @param {Internal.INumberValue} message NumberValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumberValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified NumberValue message, length delimited. Does not implicitly {@link Internal.NumberValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.NumberValue
             * @static
             * @param {Internal.INumberValue} message NumberValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NumberValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a NumberValue message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.NumberValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.NumberValue} NumberValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumberValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.NumberValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("data"))
                    throw $util.ProtocolError("missing required 'data'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a NumberValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.NumberValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.NumberValue} NumberValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NumberValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a NumberValue message.
             * @function verify
             * @memberof Internal.NumberValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            NumberValue.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (typeof message.data !== "number")
                    return "data: number expected";
                return undefined;
            };
    
            /**
             * Creates a NumberValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.NumberValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.NumberValue} NumberValue
             */
            NumberValue.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.NumberValue)
                    return object;
                var message = new $root.Internal.NumberValue();
                if (object.data != undefined)
                    message.data = Number(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a NumberValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.NumberValue
             * @static
             * @param {Internal.NumberValue} message NumberValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NumberValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = 0;
                if (message.data != undefined && message.hasOwnProperty("data"))
                    object.data = options.json && !isFinite(message.data) ? String(message.data) : message.data;
                return object;
            };
    
            /**
             * Converts this NumberValue to JSON.
             * @function toJSON
             * @memberof Internal.NumberValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NumberValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return NumberValue;
        })();
    
        Internal.StringArray = (function() {
    
            /**
             * Properties of a StringArray.
             * @memberof Internal
             * @interface IStringArray
             * @property {Array.<string>|undefined} [data] StringArray data
             */
    
            /**
             * Constructs a new StringArray.
             * @memberof Internal
             * @classdesc Represents a StringArray.
             * @implements IStringArray
             * @constructor
             * @param {Internal.IStringArray=} [properties] Properties to set
             */
            function StringArray(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StringArray data.
             * @member {Array.<string>} data
             * @memberof Internal.StringArray
             * @instance
             */
            StringArray.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new StringArray instance using the specified properties.
             * @function create
             * @memberof Internal.StringArray
             * @static
             * @param {Internal.IStringArray=} [properties] Properties to set
             * @returns {Internal.StringArray} StringArray instance
             */
            StringArray.create = function create(properties) {
                return new StringArray(properties);
            };
    
            /**
             * Encodes the specified StringArray message. Does not implicitly {@link Internal.StringArray.verify|verify} messages.
             * @function encode
             * @memberof Internal.StringArray
             * @static
             * @param {Internal.IStringArray} message StringArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringArray.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.data[i]);
                return writer;
            };
    
            /**
             * Encodes the specified StringArray message, length delimited. Does not implicitly {@link Internal.StringArray.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.StringArray
             * @static
             * @param {Internal.IStringArray} message StringArray message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringArray.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StringArray message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.StringArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.StringArray} StringArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringArray.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.StringArray();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StringArray message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.StringArray
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.StringArray} StringArray
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringArray.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StringArray message.
             * @function verify
             * @memberof Internal.StringArray
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            StringArray.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isString(message.data[i]))
                            return "data: string[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates a StringArray message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.StringArray
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.StringArray} StringArray
             */
            StringArray.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.StringArray)
                    return object;
                var message = new $root.Internal.StringArray();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".Internal.StringArray.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = String(object.data[i]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StringArray message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.StringArray
             * @static
             * @param {Internal.StringArray} message StringArray
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringArray.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this StringArray to JSON.
             * @function toJSON
             * @memberof Internal.StringArray
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringArray.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StringArray;
        })();
    
        Internal.StringMap = (function() {
    
            /**
             * Properties of a StringMap.
             * @memberof Internal
             * @interface IStringMap
             * @property {Object.<string,string>|undefined} [data] StringMap data
             */
    
            /**
             * Constructs a new StringMap.
             * @memberof Internal
             * @classdesc Represents a StringMap.
             * @implements IStringMap
             * @constructor
             * @param {Internal.IStringMap=} [properties] Properties to set
             */
            function StringMap(properties) {
                this.data = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StringMap data.
             * @member {Object.<string,string>} data
             * @memberof Internal.StringMap
             * @instance
             */
            StringMap.prototype.data = $util.emptyObject;
    
            /**
             * Creates a new StringMap instance using the specified properties.
             * @function create
             * @memberof Internal.StringMap
             * @static
             * @param {Internal.IStringMap=} [properties] Properties to set
             * @returns {Internal.StringMap} StringMap instance
             */
            StringMap.create = function create(properties) {
                return new StringMap(properties);
            };
    
            /**
             * Encodes the specified StringMap message. Does not implicitly {@link Internal.StringMap.verify|verify} messages.
             * @function encode
             * @memberof Internal.StringMap
             * @static
             * @param {Internal.IStringMap} message StringMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringMap.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.hasOwnProperty("data"))
                    for (var keys = Object.keys(message.data), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.data[keys[i]]).ldelim();
                return writer;
            };
    
            /**
             * Encodes the specified StringMap message, length delimited. Does not implicitly {@link Internal.StringMap.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.StringMap
             * @static
             * @param {Internal.IStringMap} message StringMap message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringMap.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StringMap message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.StringMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.StringMap} StringMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringMap.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.StringMap(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.data === $util.emptyObject)
                            message.data = {};
                        key = reader.string();
                        reader.pos++;
                        message.data[key] = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes a StringMap message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.StringMap
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.StringMap} StringMap
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringMap.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StringMap message.
             * @function verify
             * @memberof Internal.StringMap
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            StringMap.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!$util.isObject(message.data))
                        return "data: object expected";
                    var key = Object.keys(message.data);
                    for (var i = 0; i < key.length; ++i)
                        if (!$util.isString(message.data[key[i]]))
                            return "data: string{k:string} expected";
                }
                return undefined;
            };
    
            /**
             * Creates a StringMap message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.StringMap
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.StringMap} StringMap
             */
            StringMap.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.StringMap)
                    return object;
                var message = new $root.Internal.StringMap();
                if (object.data) {
                    if (typeof object.data !== "object")
                        throw TypeError(".Internal.StringMap.data: object expected");
                    message.data = {};
                    for (var keys = Object.keys(object.data), i = 0; i < keys.length; ++i)
                        message.data[keys[i]] = String(object.data[keys[i]]);
                }
                return message;
            };
    
            /**
             * Creates a plain object from a StringMap message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.StringMap
             * @static
             * @param {Internal.StringMap} message StringMap
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringMap.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.data = {};
                var keys2;
                if (message.data && (keys2 = Object.keys(message.data)).length) {
                    object.data = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.data[keys2[j]] = message.data[keys2[j]];
                }
                return object;
            };
    
            /**
             * Converts this StringMap to JSON.
             * @function toJSON
             * @memberof Internal.StringMap
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringMap.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StringMap;
        })();
    
        Internal.StringValue = (function() {
    
            /**
             * Properties of a StringValue.
             * @memberof Internal
             * @interface IStringValue
             * @property {string} data StringValue data
             */
    
            /**
             * Constructs a new StringValue.
             * @memberof Internal
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {Internal.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StringValue data.
             * @member {string} data
             * @memberof Internal.StringValue
             * @instance
             */
            StringValue.prototype.data = "";
    
            /**
             * Creates a new StringValue instance using the specified properties.
             * @function create
             * @memberof Internal.StringValue
             * @static
             * @param {Internal.IStringValue=} [properties] Properties to set
             * @returns {Internal.StringValue} StringValue instance
             */
            StringValue.create = function create(properties) {
                return new StringValue(properties);
            };
    
            /**
             * Encodes the specified StringValue message. Does not implicitly {@link Internal.StringValue.verify|verify} messages.
             * @function encode
             * @memberof Internal.StringValue
             * @static
             * @param {Internal.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified StringValue message, length delimited. Does not implicitly {@link Internal.StringValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.StringValue
             * @static
             * @param {Internal.IStringValue} message StringValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StringValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes a StringValue message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.StringValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("data"))
                    throw $util.ProtocolError("missing required 'data'", { instance: message });
                return message;
            };
    
            /**
             * Decodes a StringValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.StringValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.StringValue} StringValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StringValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof Internal.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (!$util.isString(message.data))
                    return "data: string expected";
                return undefined;
            };
    
            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.StringValue)
                    return object;
                var message = new $root.Internal.StringValue();
                if (object.data != undefined)
                    message.data = String(object.data);
                return message;
            };
    
            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.StringValue
             * @static
             * @param {Internal.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = "";
                if (message.data != undefined && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof Internal.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return StringValue;
        })();
    
        Internal.Uint32Array = (function() {
    
            /**
             * Properties of an Uint32Array.
             * @memberof Internal
             * @interface IUint32Array
             * @property {Array.<number>|undefined} [data] Uint32Array data
             */
    
            /**
             * Constructs a new Uint32Array.
             * @memberof Internal
             * @classdesc Represents an Uint32Array.
             * @implements IUint32Array
             * @constructor
             * @param {Internal.IUint32Array=} [properties] Properties to set
             */
            function Uint32Array(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Uint32Array data.
             * @member {Array.<number>} data
             * @memberof Internal.Uint32Array
             * @instance
             */
            Uint32Array.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new Uint32Array instance using the specified properties.
             * @function create
             * @memberof Internal.Uint32Array
             * @static
             * @param {Internal.IUint32Array=} [properties] Properties to set
             * @returns {Internal.Uint32Array} Uint32Array instance
             */
            Uint32Array.create = function create(properties) {
                return new Uint32Array(properties);
            };
    
            /**
             * Encodes the specified Uint32Array message. Does not implicitly {@link Internal.Uint32Array.verify|verify} messages.
             * @function encode
             * @memberof Internal.Uint32Array
             * @static
             * @param {Internal.IUint32Array} message Uint32Array message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uint32Array.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != undefined && message.data.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.data.length; ++i)
                        writer.uint32(message.data[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Encodes the specified Uint32Array message, length delimited. Does not implicitly {@link Internal.Uint32Array.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.Uint32Array
             * @static
             * @param {Internal.IUint32Array} message Uint32Array message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uint32Array.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Uint32Array message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.Uint32Array
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.Uint32Array} Uint32Array
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uint32Array.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.Uint32Array();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.data.push(reader.uint32());
                        } else
                            message.data.push(reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            /**
             * Decodes an Uint32Array message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.Uint32Array
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.Uint32Array} Uint32Array
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uint32Array.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Uint32Array message.
             * @function verify
             * @memberof Internal.Uint32Array
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Uint32Array.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (message.data != undefined && message.hasOwnProperty("data")) {
                    if (!Array.isArray(message.data))
                        return "data: array expected";
                    for (var i = 0; i < message.data.length; ++i)
                        if (!$util.isInteger(message.data[i]))
                            return "data: integer[] expected";
                }
                return undefined;
            };
    
            /**
             * Creates an Uint32Array message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.Uint32Array
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.Uint32Array} Uint32Array
             */
            Uint32Array.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.Uint32Array)
                    return object;
                var message = new $root.Internal.Uint32Array();
                if (object.data) {
                    if (!Array.isArray(object.data))
                        throw TypeError(".Internal.Uint32Array.data: array expected");
                    message.data = [];
                    for (var i = 0; i < object.data.length; ++i)
                        message.data[i] = object.data[i] >>> 0;
                }
                return message;
            };
    
            /**
             * Creates a plain object from an Uint32Array message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.Uint32Array
             * @static
             * @param {Internal.Uint32Array} message Uint32Array
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Uint32Array.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.data = [];
                if (message.data && message.data.length) {
                    object.data = [];
                    for (var j = 0; j < message.data.length; ++j)
                        object.data[j] = message.data[j];
                }
                return object;
            };
    
            /**
             * Converts this Uint32Array to JSON.
             * @function toJSON
             * @memberof Internal.Uint32Array
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Uint32Array.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Uint32Array;
        })();
    
        Internal.Uint32Value = (function() {
    
            /**
             * Properties of an Uint32Value.
             * @memberof Internal
             * @interface IUint32Value
             * @property {number} data Uint32Value data
             */
    
            /**
             * Constructs a new Uint32Value.
             * @memberof Internal
             * @classdesc Represents an Uint32Value.
             * @implements IUint32Value
             * @constructor
             * @param {Internal.IUint32Value=} [properties] Properties to set
             */
            function Uint32Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != undefined)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Uint32Value data.
             * @member {number} data
             * @memberof Internal.Uint32Value
             * @instance
             */
            Uint32Value.prototype.data = 0;
    
            /**
             * Creates a new Uint32Value instance using the specified properties.
             * @function create
             * @memberof Internal.Uint32Value
             * @static
             * @param {Internal.IUint32Value=} [properties] Properties to set
             * @returns {Internal.Uint32Value} Uint32Value instance
             */
            Uint32Value.create = function create(properties) {
                return new Uint32Value(properties);
            };
    
            /**
             * Encodes the specified Uint32Value message. Does not implicitly {@link Internal.Uint32Value.verify|verify} messages.
             * @function encode
             * @memberof Internal.Uint32Value
             * @static
             * @param {Internal.IUint32Value} message Uint32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uint32Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.data);
                return writer;
            };
    
            /**
             * Encodes the specified Uint32Value message, length delimited. Does not implicitly {@link Internal.Uint32Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof Internal.Uint32Value
             * @static
             * @param {Internal.IUint32Value} message Uint32Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Uint32Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };
    
            /**
             * Decodes an Uint32Value message from the specified reader or buffer.
             * @function decode
             * @memberof Internal.Uint32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {Internal.Uint32Value} Uint32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uint32Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Internal.Uint32Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                if (!message.hasOwnProperty("data"))
                    throw $util.ProtocolError("missing required 'data'", { instance: message });
                return message;
            };
    
            /**
             * Decodes an Uint32Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof Internal.Uint32Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {Internal.Uint32Value} Uint32Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Uint32Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };
    
            /**
             * Verifies an Uint32Value message.
             * @function verify
             * @memberof Internal.Uint32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|undefined} `undefined` if valid, otherwise the reason why it is not
             */
            Uint32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === undefined)
                    return "object expected";
                if (!$util.isInteger(message.data))
                    return "data: integer expected";
                return undefined;
            };
    
            /**
             * Creates an Uint32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof Internal.Uint32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {Internal.Uint32Value} Uint32Value
             */
            Uint32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.Internal.Uint32Value)
                    return object;
                var message = new $root.Internal.Uint32Value();
                if (object.data != undefined)
                    message.data = object.data >>> 0;
                return message;
            };
    
            /**
             * Creates a plain object from an Uint32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof Internal.Uint32Value
             * @static
             * @param {Internal.Uint32Value} message Uint32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Uint32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.data = 0;
                if (message.data != undefined && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };
    
            /**
             * Converts this Uint32Value to JSON.
             * @function toJSON
             * @memberof Internal.Uint32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Uint32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
    
            return Uint32Value;
        })();
    
        return Internal;
    })();

    return $root;
});
